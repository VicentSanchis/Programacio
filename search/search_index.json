{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u00cdndex Tema 1. Introducci\u00f3 a la programaci\u00f3 Tema 2. Programaci\u00f3 Estructurada Tema 03. El llenguatge Java Tema 04. Programaci\u00f3 Modular Tema 05. Tipus Compostos de Dades Tema 06. Programaci\u00f3 Orientada a Objectes Tema 07. Her\u00e8ncia, polimorfisme i interf\u00edcies Tema 08. Entrada, eixida i excepcions Tema 09. Gr\u00e0fics. Java Swing Tema 10. Acc\u00e9s a dades","title":"\u00cdndex"},{"location":"#index","text":"","title":"\u00cdndex"},{"location":"#tema-1-introduccio-a-la-programacio","text":"","title":"Tema 1. Introducci\u00f3 a la programaci\u00f3"},{"location":"#tema-2-programacio-estructurada","text":"","title":"Tema 2. Programaci\u00f3 Estructurada"},{"location":"#tema-03-el-llenguatge-java","text":"","title":"Tema 03. El llenguatge Java"},{"location":"#tema-04-programacio-modular","text":"","title":"Tema 04. Programaci\u00f3 Modular"},{"location":"#tema-05-tipus-compostos-de-dades","text":"","title":"Tema 05. Tipus Compostos de Dades"},{"location":"#tema-06-programacio-orientada-a-objectes","text":"","title":"Tema 06. Programaci\u00f3 Orientada a Objectes"},{"location":"#tema-07-herencia-polimorfisme-i-interficies","text":"","title":"Tema 07. Her\u00e8ncia, polimorfisme i interf\u00edcies"},{"location":"#tema-08-entrada-eixida-i-excepcions","text":"","title":"Tema 08. Entrada, eixida i excepcions"},{"location":"#tema-09-grafics-java-swing","text":"","title":"Tema 09. Gr\u00e0fics. Java Swing"},{"location":"#tema-10-acces-a-dades","text":"","title":"Tema 10. Acc\u00e9s a dades"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/","text":"Tema 1. Introducci\u00f3 a la programaci\u00f3 Introducci\u00f3 Un programa \u00e9s: Segons el diccionari normatiu valenci\u00e0 (DNV) Conjunt d'instruccions detallades i codificades que es donen a un sistema inform\u00e0tic perqu\u00e8 execute unes determinades operacions. Segons el Termcat: Conjunt de dades i d'instruccions codificades que s\u00f3n l'expressi\u00f3 completa d'un procediment que pot executar un sistema inform\u00e0tic. Per tant podr\u00edem dir que programar \u00e9s l\u2019acci\u00f3 d\u2019elaborar un programa. En altres paraules un programa \u00e9s un conjunt d\u2019instruccions escrites en un llenguatge de programaci\u00f3 que s\u2019utilitzen per donar ordres o indicacions a un ordinador. El m\u00e9s paregut a programar que hi ha en el m\u00f3n real seria elaborar un conjunt d'instruccions de tal forma que una altra persona siga capa\u00e7 de llegir, interpretar i executar satisfact\u00f2riament obtenint un resultat. Una recepta de cuina per exemple \u00e9s un conjunt d'instruccions que \"qualsevol\" \u00e9s capa\u00e7 de llegir, interpretar i executar obtenint al final un resultat. En aquest escenari els elements que ens podem trobar s\u00f3n: origen (persona que diu les instruccions o ordres, el que escriu la recepte), dest\u00ed (persona que les ha de llegir, interpretar i executar, el cuiner) i el llenguatge usat (valenci\u00e0). Doncs b\u00e9, en inform\u00e0tica tindr\u00edem els mateixos elements on l'origen seria el programador, el dest\u00ed l'ordinador i el llenguatge seria el llenguatge de programaci\u00f3. Podriem concloure que aprendre a programar \u00e9s aprendre l'idioma que parlen els ordinadors per tal de poder comunicar-nos amb ells i donar-los ordres. En aquest primer tema, veurem una s\u00e8rie de conceptes b\u00e0sics que seran necessaris per entendre que \u00e9s la programaci\u00f3. Conceptes b\u00e0sics Com ja hem explicat a la introducci\u00f3 d'aquest tema, programar consisteix en b\u00e0sicament donar ordres a un dispositiu mitjan\u00e7ant un algorisme en un llenguatge de programaci\u00f3 concret que a l'executar-se en una m\u00e0quina es converteix en programa . Veiem amb un poc m\u00e9s de detall aquestos conceptes: Algorisme vs Programa Un algorisme \u00e9s un conjunt ordenat i finit d\u2019operacions o instruccions a seguir que permeten trobar la soluci\u00f3 a un problema. Per exemple: algorisme de la suma, la resta, la multiplicaci\u00f3 o la divisi\u00f3. Per tal de fer una suma de xifres de m\u00e9s d\u2019un digit cadascuna, el que es diu comunament sumar portant, hem de seguir unes instruccions que si les realitzem de forma correcta, obtenim el resultat. Doncs b\u00e9, eixes \u2018instruccions\u2019 serien l\u2019algorisme. Un programa no \u00e9s m\u00e9s que un algorisme les \u2018instruccions\u2019 del qual les executa un ordinador. Caracter\u00edstiques d'un programa Un algorisme posteriorment convertit a programa ha de complir una s\u00e8rie de caracter\u00edstiques: Finit: ha de comen\u00e7ar i acabar. Llegible: un programa s'escriu una vegada per\u00f2 es llig moltes. Modificable: ha de poder evolucionar. Eficient: No utilitza m\u00e9s recursos dels necessaris Modular: s'ha de dividir en parts el qual millora la legibilitat. Estructurat: utilitza les estructures del paradigma de la programaci\u00f3 estructurada. Llenguatges de programaci\u00f3 De la mateixa manera que dues persones es comuniquen entre s\u00ed utilitzant un llenguatge natural, una persona es comunica amb una m\u00e0quina utilitzant un llenguatge de programaci\u00f3. Evidentment, un llenguatge de programaci\u00f3 ha de ser m\u00e9s simple i gens ambigu al contrari de com passa amb els llenguatges naturals. Els llenguatges de programaci\u00f3 solen complir les seg\u00fcents caracter\u00edstiques: Existeix un nombre finit de paraules reservades que podem usar: for, var, int, while... \u00c9s a dir, un llenguatge de programaci\u00f3 t\u00e9 un conjunt l\u00e8xic de paraules amb un significat associat com passa amb els llenguatges naturals. Les frases com a combinaci\u00f3 de diferents paraules amb les que ens comuniquem en llenguatge natural es diuen instruccions Cada instrucci\u00f3 finalitza d\u2019una manera concreta, per exemple, utilitzant un \u2018;\u2019 per tal que la m\u00e0quina sapiga quan acaba una instrucci\u00f3 i comen\u00e7a una altra. Classificaci\u00f3 Els llenguatges de programaci\u00f3 es poden classificar segons els seg\u00fcents criteris PROXIMITAT A LA M\u00c0QUINA Les m\u00e0quines en realitat nom\u00e9s entenen 0 i 1, hi han llenguatges de programaci\u00f3 molts pr\u00f2xims a aquest tipus de codificaci\u00f3 bin\u00e0ria per\u00f2 que s\u00f3n complicats d\u2019entendre per un \u00e9sser hum\u00e0. D\u2019una altra banda existeixen llenguatges que utilitzen un conjunt de paraules reservades que fan que siga m\u00e9s f\u00e0cil d\u2019entendre per una persona. Al final de tot aquest llenguatge m\u00e9s pr\u00f2xim al llenguatge hum\u00e0 acaba convertint-se en una seq\u00fc\u00e8ncia de 0 i 1 la m\u00e0quina pot entendre en el proc\u00e9s de compilaci\u00f3 que veurem m\u00e9s endavant. Llenguatges de baix nivell: s\u00f3n els llenguatges m\u00e9s pr\u00f2xims al llenguatge m\u00e0quina com per exemple el llenguatge assemblador. Llenguatges de nivell mitj\u00e0: llenguatges que s\u2019aproximen un poc m\u00e9s al llenguatge natural utilitzant una s\u00e8rie de paraules reservades que s\u2019utilitzen en llenguatge natural com per exemple el llenguatge C Llenguatges d\u2019alt nivell: Els m\u00e9s pr\u00f2xims al llenguatge natural per\u00f2 sense ambig\u00fcitats. PROPOSIT DEL LLENGUATGE \u00c9s a dir segons quins tipus de programes poden generar, quina \u00e9s la seua finalitat. Llenguatges de prop\u00f2sit general que s\u00f3n capa\u00e7os de crear qualsevol tipus de programa. Llenguatge C Llenguatges de prop\u00f2sit espec\u00edfic que es dissenyen per trEn realitat aquesta faselenguatges de programaci\u00f3, aquests han anat evolucionant i adaptant-se a les noves caracter\u00edstiques tant f\u00edsiques com d\u2019\u00fas del maquinari i els dispositius. SEGONS GENERACI\u00d3 Primera Generaci\u00f3: llenguatges m\u00e0quina i llenguatges assemblador. Anys 40 \u2013 50. En aquesta \u00e8poca s\u2019usaven targetes perforades i es programava utilitzant seq\u00fcencies d\u2019uns i zeros indicant quin c\u00e0lcul havien de realitzar els programes. Els llenguatges assemblador afegeixen la primera capa d\u2019abstracci\u00f3 sobre el binari de forma que una s\u00e8rie d\u2019instruccions simples s\u00f3n despr\u00e9s tradu\u00efdes a binari per la mateixa m\u00e0quina. Aquestes instruccions estaven directament relacionades amb el processador, \u00e9s a dir, cada processador tenia el seu conjunt d'instruccions propi. Segona Generaci\u00f3: Apareixen els llenguatges de nivell mitj\u00e0 i els primers compiladors, que per que ho entenem de moment, s\u00f3n els encarregats de traduir d\u2019un llenguatge de programaci\u00f3 a llenguatge m\u00e0quina o binari. Exemple de llenguatge de nivell mitj\u00e0: FORTRAN (FORmula TRANSlating system) de l\u2019any 1956 Tercera Generaci\u00f3: Apareix la programaci\u00f3 estructurada, ja no nom\u00e9s s\u2019utilitzen els llenguatges de programaci\u00f3 per realitzar c\u00e0lculs matem\u00e0tics com fins ara. Apareix tamb\u00e9 l\u2019\u00fas de variables, subprogrames, estructures etc.. En aquesta generaci\u00f3 podem trobar llenguatges de programaci\u00f3 com C, Pascal o Modula. Quarta Generaci\u00f3: En aquesta generaci\u00f3 trobarem llenguatges desenvolupats per crear un determinat tipus de programari, es configuren per tasques molt concretes. Cinquena Generaci\u00f3: on estarien els llenguatges dissenyats per afrontar la intel\u00b7lig\u00e8ncia artificial com per exemple Prolog. Comen\u00e7a tamb\u00e9 a posar-se en pr\u00e0ctica la programaci\u00f3 orientada a objectes com a nou paradigma de programaci\u00f3. Generaci\u00f3 Visual: nascuda a principis dels anys 90 i com a conseq\u00fc\u00e8ncia de la necessitat de usar interf\u00edcies cada vegada m\u00e9s amigables i f\u00e0cils. FORMA D'EXECUCI\u00d3 Com havien dit abans, abans d\u2019executar un programa escrit en un llenguatge de programaci\u00f3 qualsevol, s\u2019ha de traduir al llenguatge que pot entendre la m\u00e0quina, binari. Aquest proc\u00e9s es pot fer de dues formes: Llenguatges compilats: per tal de compilar un programa es realitzen les seg\u00fcents tasques: an\u00e0lisi l\u00e8xic, sint\u00e0ctic i sem\u00e0ntic del programa, traducci\u00f3 a codi objecte, enlla\u00e7 amb altres llibreries i creaci\u00f3 de l\u2019executable. Llenguatges interpretats: Aquest tipus de codis es lligen,Un diagrama de flux \u00e9s una representaci\u00f3 gr\u00e0fica d'un algorisme. S'utilitza en disciplines com la programaci\u00f3 inform\u00e0tica, l'economia, els processos industrials o la psicologia cognitiva. Aquests diagrames utilitzen s\u00edmbols amb significats ben definits que representen els passos de l'algorisme, i representen el flux d'execuci\u00f3 mitjan\u00e7ant fletxes que connecten els punts d'inici i de finalitzaci\u00f3. Un diagrama de flux sempre t\u00e9 un \u00fanic punt d'inici i un \u00fanic punt de finalitzaci\u00f3. A m\u00e9s, tot cam\u00ed d'execuci\u00f3 ha de permetre arribar des de l'inici fins al final. PARADIGMA DE PROGRAMACI\u00d3 Programaci\u00f3 estructurada: Utilitzen les estructures b\u00e0siques de programaci\u00f3: seq\u00fcencial, alternativa i iterativa combinats amb la programaci\u00f3 modular per dissenyar programes. Programaci\u00f3 orientada a objectes: Entenen els programes com un conjunt d\u2019objectes que tenen unes caracter\u00edstiques pr\u00f2pies, uns m\u00e8todes i que interactuen amb els altres objectes que formen part del sistema. SEGONS NOMBRE DE PROCESSOS \u00c9s a dir, si permeten la execuci\u00f3 concurrent, m\u00e9s d\u2019un proc\u00e9s al mateix temps o no. Per tant ens podem trobar: Llenguatges de programaci\u00f3 concurrent que permeten la concurr\u00e8ncia Llenguatges de programaci\u00f3 no concurrent. SEGONS INTERACTIVITAT Si permeten la interacci\u00f3 amb l\u2019usuari o no. VISUALS O NO ten la programaci\u00f3 per reutilitzaci\u00f3 de components mitjan\u00e7ant drag and drop en un entorn gr\u00e0fic o no. Paraules reservades Els llenguatges de programaci\u00f3 utilitzen una s\u00e8rie de paraules o s\u00edmbols que fan una funci\u00f3 espec\u00edfica dins d\u2019un programa. A aquest conjunt de signes o combinaci\u00f3 d\u2019ells se les anomena paraules reservades. Aquestes paraules nom\u00e9s poden usar-se en un concepte determinat, mai lliurement per l\u2019usuari. Per exemple, el llenguatge C t\u00e9 com a paraules reservades if o while. Ambdues nom\u00e9s podran ser utilitzades en cas que es vullga iniciar una sent\u00e8ncia de control condicional o bucle. Fases de desenvolupament d'un programa A l\u2019hora d\u2019afrontar la realitzaci\u00f3 d\u2019un programa hem de tindre clar que hem de fer. \u00c9s un error comen\u00e7ar a crear programari a lo loco ja que nom\u00e9s conseguirem deicar a aquest menester m\u00e9s temps que el que es necessita. A m\u00e9s a m\u00e9s el proc\u00e9s de creaci\u00f3 d\u2019un programa no nom\u00e9s \u00e9s picar codi. D\u2019aquesta manera a l\u2019hora de construir un programa es deurien seguir una s\u00e8rie de fases o pautes: An\u00e0lisi del problema Estudi del problema, quina \u00e9s la seua finalitat, a qui va dirigit, quins elements ha d\u2019incloure, quines tasques ha de realitzar. En aquesta fase es realitzen entrevistes amb els usuaris o clients entre d\u2019altres t\u00e8cniques. La finalitat d\u2019aquesta fase \u00e9s fer un recull dels diferents requeriments que ha de tenir el nostre producte. Exemple: Imaginem que ens disposem a fer una aplicaci\u00f3 que gestione la fruteria del barri. En aquesta fase \u00e9s on hauriem d'esbrinar, entre altres coses: quins productes es venen, quin preu tenen, l'agenda de clients, quina informaci\u00f3 volem saber dels clients, quina informaci\u00f3 volem saber de prove\u00efdors etc. Suposem que ens farem c\u00e0rrec d'una part xicoteta d'aquesta aplicaci\u00f3: la introducci\u00f3 de tickets de compra nous . En aquesta fase podriem extreure que a un ticket de compra necessitaria que es reflexara la seg\u00fcent informaci\u00f3: Data i hora de la compra. Llista de productes comprats: producte, preu uniitari, quantitat i total. Subtotal de la compra. IVA i descomptes aplicats. Total de la compra. Producte: Requeriments del sistema o aplicaci\u00f3. En base a la informaci\u00f3 que hem aconseguit per mitja d'entrevistes, enquestes etc.. En altres paraules: el que ha de fer la nostra aplicaci\u00f3, finalitat, objectius. Disseny de l'algorisme Es refereix a com anem a sol\u00b7lucionar els requeriments obtiguts a la fase anterior. En aquesta fase s'estudien possibles opcions d'implementaci\u00f3 per a l'aplicaci\u00f3 que hem de construir, aix\u00ed com decidir l'estructura general de la mateixa. El disseny \u00e9s una estapa complexa i el seu proc\u00e9s s'ha de realitzar d'una forma iterativa. Es possible que la soluci\u00f3 inicial no siga la m\u00e9s adequada, per tant en tal cas s'hauria de redefinir. Tammateix, hi ha cat\u00e0legs de patrons de disseny molt \u00fatils que recullen errades que altres han com\u00e9s per no caure a la mateixa trampa. Exemple: Continuant en la nostra aplicaci\u00f3 de la fruteria, en aquesta fase i una vegada acabada la fase d'an\u00e0lisi d'on s'obtenen els requeriments, hauriem de, per un costat triar el paradigma de programaci\u00f3 que escollirem: programaci\u00f3 estructurada o programaci\u00f3 orientada a objectes (Normalment aquest \u00faltim). El llenguatge de programaci\u00f3 a utilitzar. Una vegada ja ho hem triat, hem de decidir com el nostre programa va a complir amb els requeriments obtesos a la fase d'analisi, \u00e9s a dir, com crearem el nou ticket de compra, com afegirem els productes i com calcularem el preu final i imprimirem el document. Producte: Si hem triat el paradigma de programaci\u00f3 estructurada hauriem de dissenyar els diagramres flux de les diferents funcionalitats de l'aplicaci\u00f3, el pseudocodi, etc.. Per exemple en aquesta fase es dissenyaria l'alogorisme en pseudocodi o diagrama de flux on s'indique pas a pas com es faria la introducci\u00f3 d'un ticket nou. En canvi, si pel contrari escollim el paradigma de programaci\u00f3 orientada a objectes obtindriem casos d'\u00fas, diagrames de classes, diagrames de comportament en UML. Codificaci\u00f3 Ha arribat el moment de picar codi. A la fase de codificaci\u00f3, ens arriben els documents (pseudocodi, flux, diagrames de classes, UML) necessaris per poder comen\u00e7ar a programar. En aquesta fase hem d'escollir les eines (IDEs) adequades per poder desenvolupar el nostre projecte i tamb\u00e9 escollirem (va lligat en realitat) el llenguatge de programaci\u00f3 Exemple: seguint amb la fruteria i suposant que ens han passat un pseudocodi de la nostra apliaci\u00f3 de generaci\u00f3 de tickets, podriem per exemple triar l'IDE Visual Studio Code i C# com a llenguatge de programaci\u00f3 o l'IDE Eclipse i Java o Visual Studio i Java... Producte: El projecte amb tots els fitxers que tenen el codi desenvolupat aix\u00ed com tamb\u00e9 els executables o binaris ja compilats i funcionant. Prova i depuraci\u00f3 Com que errar es d'humans, la fase de proves del cicle de vida de programari busca detectar els errors comesos en les etapes anteriors per tal de poder corregir-los. Per supost, all\u00f2 ideal \u00e9s fer-ho abans que l'usuari final se'ls trobe. Es diu que una prova amb exit \u00e9s una prova que detecta algun error. Documentaci\u00f3 Aquesta \u00e9s la fase que a cap programador li agrada fer, per\u00f2 en realitat \u00e9s una fase que no est\u00e0 necess\u00e0riament al final del cicle de vida del programa, sino que es fa de forma transversal en totes les etapes del desenvolupament. Es considera documentaci\u00f3 des dels requeriments inicials al manual d'usuari passant per el pseudocodi, diagrames de classes i \u00fas, i tamb\u00e9 els comentaris que es posen al codi. Diagrames de flux Un diagrama de flux \u00e9s una representaci\u00f3 gr\u00e0fica d'un algorisme. S'utilitza en disciplines com la programaci\u00f3 inform\u00e0tica, l'economia, els processos industrials o la psicologia cognitiva. Aquests diagrames utilitzen s\u00edmbols amb significats ben definits que representen els passos de l'algorisme, i representen el flux d'execuci\u00f3 mitjan\u00e7ant fletxes que connecten els punts d'inici i de finalitzaci\u00f3. Un diagrama de flux sempre t\u00e9 un \u00fanic punt d'inici i un \u00fanic punt de finalitzaci\u00f3. A m\u00e9s, tot cam\u00ed d'execuci\u00f3 ha de permetre arribar des de l'inici fins al final. Les seg\u00fcents s\u00f3n accions pr\u00e8vies a la realitzaci\u00f3 del diagrama de flux: Identificar les idees principals que s'han d'incloure en el diagrama de flux. Han d'estar presents el propietari o responsable del proc\u00e9s, els propietaris o responsables del proc\u00e9s anterior i posterior i d'altres processos interrelacionats, aix\u00ed com les terceres parts interessades. Definir qu\u00e8 s'espera obtenir del diagrama de flux. Identificar qui ho far\u00e0 servir i com. Establir el nivell de detall requerit. Determinar els l\u00edmits del proc\u00e9s a descriure. Els passos a seguir per construir el diagrama de flux s\u00f3n: Establir l'abast del proc\u00e9s a descriure. D'aquesta manera quedar\u00e0 fixat el comen\u00e7ament i el final del diagrama. Sovint el comen\u00e7ament \u00e9s la sortida del proc\u00e9s previ i el final l'entrada al proc\u00e9s seg\u00fcent. Identificar i llistar les principals activitats/subprocessos que estan incloses en el proc\u00e9s a descriure i el seu ordre cronol\u00f2gic. Si el nivell de detall definit inclou activitats menors, llistar-les tamb\u00e9. Identificar i llistar els punts de decisi\u00f3. Construir el diagrama respectant la seq\u00fc\u00e8ncia cronol\u00f2gica i assignant els corresponents s\u00edmbols. Assignar un t\u00edtol al diagrama i verificar que estigui complet i descrigui amb exactitud el proc\u00e9s escollit. Simbologia i significat Oval o el\u00b7lipse: inici i final (obre i/o tanca el diagrama). Rectangle: activitat (representa l'execuci\u00f3 d'una o m\u00e9s activitats o procediments). Rombe: decisi\u00f3 (formula una pregunta o q\u00fcesti\u00f3). Cercle: connector (representa l'enlla\u00e7 d'activitats amb una altra dins d'un procediment). Triangle cap per avall: fitxer definitiu (guarda un document de forma permanent). Triangle cap per amunt: fitxer temporal (proporciona un temps per a l'emmagatzematge del document). Exemples A continuaci\u00f3 vegem alguns exemples que ens ajudaran a entendre-ho millor: Exemple 1. La nostra fruiteria A la imatge seg\u00fcent podem observar un exemple d'algorisme de creaci\u00f3 d'un nou ticket (nova compra). Expliquem breument el que fa aquest diagrama: primer crea un nou ticket i afegeix un nou element (fruta o verdura), aquesta acci\u00f3 \u00faltima es repeteix fins que acabe de comprar. Quan s'acaba d'afegir items al nou ticket, es calcula el preu final i s'imprimeix. Exemple 2. Trobar les claus de casa. Imagineu que vull eixir de casa per\u00f2 no recorde on he posat les claus i sense elles no puc anar a cap lloc. Les he de buscar. El seg\u00fcent algorisme representat utilitzant un diagrama de flux, ens podria ajudar a trobar-les. Exemple 3. Com anar de l'ajuntament al passeig. Ens trobem a la pla\u00e7a de l'ajuntament i un visitant ens pregunta com arribar al passeig Cervantes. Oberva el seg\u00fcent diagrama de flux. Al tractar-se d'un exemple un poc m\u00e9s extens, primer descriurem les instruccions en llenguatge natural i despr\u00e9s farem el diagrama. Camina pel carrer major en direcci\u00f3 sud Quan arribes a l'encreuament amb el Carrer Ramon y Cajal gira a la dreta Camina fins la farmacia Quan arribes a la farm\u00e0cia gira a l'esquerra Caminar fins encreuament amb el carrer Moreral. Agafa el carrer moreral Al final del carrer moreral a l'esquerra. Una possible soluci\u00f3 a aquest problema podria ser: Exemple 4. Fer Zapping. Agafare el commandament Engegar la tele M'agrada el canal? Si no m'agrada canvie de canal Si s\u00ed que m'agrada, deixe el commandament i em pose comode. Exemple 5. Adolesc\u00e8ncia Pseudocodi El pseudocodi (o fals llenguatge) \u00e9s una descripci\u00f3 a molt alt nivell de l'estructura d'un programa. Encara que utilitze estructures t\u00edpiques de la programaci\u00f3 es diu que \u00e9s a alt nivell perqu\u00e8 una persona amb pocs o sense coneixements inform\u00e0tics puga entendre i interpretar la porci\u00f3 de codi que estiga llegint. El principal objectiu del pseudocodi \u00e9s el de representar la soluci\u00f3 a un algorisme de la manera m\u00e9s detallada possible, i al mateix temps el m\u00e9s semblant possible al llenguatge que s'utilitzar\u00e0 a la fase de codificaci\u00f3. No existeix una sintaxis est\u00e0ndard de pseudocodi per\u00f2 amb ell s'han de poder escriure totes les estructures de control de la programaci\u00f3 estructurada. De totes formes, en aquest tema utilitzarem la seg\u00fcent sintaxi: ESTRUCTURA SEQ\u00dcENCIAL: 1 2 accio (); accio ( parametres ); ESTRUCTURA ITERATIVA: - fer .. mentre: 1 2 3 fer accions (); mentre ( condicio ); - mentre .. fer: 1 2 3 mentre ( condicio ) fer accions (); fimentre - repetir .. fins: 1 2 3 repetir accions (); fins ( condicio ); ESTRUCTURA ALTERNATIVA O CONDICIONAL: - si .. fsi: 1 2 3 si ( condicio ) aleshores accions (); fisi si .. sino: 1 2 3 4 5 si ( condicio ) aleshores accions1 (); sino accions2 (); fisi si .. sinosi .. sino: 1 2 3 4 5 6 7 si ( condicio1 ) aleshores accions1 (); sino si ( condicio2 ) aleshores accions2 (); sino accions3 (); fisi A continuaci\u00f3 farem els mateixos exemples que hem fet en diagrames de flux per\u00f2 en pseudocodi: ### Exemple 1. La nostra fruiteria. ```java linenums=\"1\" createTicket(); fer { afegirElement(); } mentre continue comprant calcularPreuFinal(); ImprimirTicket(); Exemple 2.Trobar les claus de casa. 1 2 3 4 5 buscaClausOnSempre (); mentre ( noTrobabesLesClaus ()) fes buscaClausEnUnAltreLloc () fiMentre EixirDeCasa (); Exemple 3. Com anar de l'ajuntament al passeig. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 fer caminarNord (); fins ( arribarAlCarre ( \"Ramon i Cajal\" )); fifer repetir caminar fins arribar ( Farmacia ); firepetir girarEsquerra () mentre NoArribesA ( \"Mestre Esteve\" ) caminar () fimentre AgafarCarrer ( \"Moreral\" ); fins arribarA ( \"Passeig\" ); caminar (); fifins Exemple 4. Fer Zapping. 1 2 3 4 5 6 engegarTele (); fer si ( noAgradaCanal () ) fes canviaCanal (); fsi fins ( trobarCanalQueAgrade ) Proc\u00e9s de compilaci\u00f3 \u00c9s el proc\u00e9s pel qual es tradueixen les instruccions escrites en un determinat llenguatge de programaci\u00f3 a llenguatge m\u00e0quina. A m\u00e9s d'un traductor, es poden necessitar altres programes per crear un programa objecte executable. Un programa font es pot dividir en m\u00f2duls emmagatzemats en arxius diferents. La tasca de reunir el programa font sovint es confia a un programa diferent, anomenat preprocessador. El preprocessador tamb\u00e9 pot expandir abreviatures, crides a macros, a proposicions del llenguatge font. Normalment la creaci\u00f3 d'un programa executable (un t\u00edpic.exe per a Microsoft Windows o DOS) comporta dos passos. El primer pas es diu compilaci\u00f3 ( pr\u00f2piament dit) i tradueix el codi font escrit en un llenguatge de programaci\u00f3 emmagatzemat en un arxiu a codi de baix nivell (normalment en codi objecte, no directament a llenguatge m\u00e0quina). El segon pas es diu enlla\u00e7at en el qual s'enlla\u00e7a el codi de baix nivell generat de tots els fitxers i subprogrames que s'han enviat compilar i s'afegeix el codi de les funcions que hi ha a les biblioteques del compilador perqu\u00e8 l'executable pugui comunicar-se directament amb el sistema operatiu, traduint aix\u00ed finalment el codi objecte a codi m\u00e0quina, i generant un m\u00f2dul executable. Aquests dos passos es poden fer per separat, emmagatzemant el resultat de la fase de compilaci\u00f3 en arxius objectes (un t\u00edpic .obj per a Microsoft Windows, DOS o per a Unix ), per a enlla\u00e7ar-los en fases posteriors, o crear directament l'executable, amb la qual cosa la fase de compilaci\u00f3 s'emmagatzema nom\u00e9s temporalment. Un programa podria tenir parts escrites en diversos llenguatges (per exemple C, C + + i Asm), que es podrien compilar de forma independent i despr\u00e9s enlla\u00e7ar juntes per formar un \u00fanic m\u00f2dul executable.","title":"Tema 1. Introducci\u00f3 a la programaci\u00f3"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#tema-1-introduccio-a-la-programacio","text":"","title":"Tema 1. Introducci\u00f3 a la programaci\u00f3"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#introduccio","text":"Un programa \u00e9s: Segons el diccionari normatiu valenci\u00e0 (DNV) Conjunt d'instruccions detallades i codificades que es donen a un sistema inform\u00e0tic perqu\u00e8 execute unes determinades operacions. Segons el Termcat: Conjunt de dades i d'instruccions codificades que s\u00f3n l'expressi\u00f3 completa d'un procediment que pot executar un sistema inform\u00e0tic. Per tant podr\u00edem dir que programar \u00e9s l\u2019acci\u00f3 d\u2019elaborar un programa. En altres paraules un programa \u00e9s un conjunt d\u2019instruccions escrites en un llenguatge de programaci\u00f3 que s\u2019utilitzen per donar ordres o indicacions a un ordinador. El m\u00e9s paregut a programar que hi ha en el m\u00f3n real seria elaborar un conjunt d'instruccions de tal forma que una altra persona siga capa\u00e7 de llegir, interpretar i executar satisfact\u00f2riament obtenint un resultat. Una recepta de cuina per exemple \u00e9s un conjunt d'instruccions que \"qualsevol\" \u00e9s capa\u00e7 de llegir, interpretar i executar obtenint al final un resultat. En aquest escenari els elements que ens podem trobar s\u00f3n: origen (persona que diu les instruccions o ordres, el que escriu la recepte), dest\u00ed (persona que les ha de llegir, interpretar i executar, el cuiner) i el llenguatge usat (valenci\u00e0). Doncs b\u00e9, en inform\u00e0tica tindr\u00edem els mateixos elements on l'origen seria el programador, el dest\u00ed l'ordinador i el llenguatge seria el llenguatge de programaci\u00f3. Podriem concloure que aprendre a programar \u00e9s aprendre l'idioma que parlen els ordinadors per tal de poder comunicar-nos amb ells i donar-los ordres. En aquest primer tema, veurem una s\u00e8rie de conceptes b\u00e0sics que seran necessaris per entendre que \u00e9s la programaci\u00f3.","title":"Introducci\u00f3"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#conceptes-basics","text":"Com ja hem explicat a la introducci\u00f3 d'aquest tema, programar consisteix en b\u00e0sicament donar ordres a un dispositiu mitjan\u00e7ant un algorisme en un llenguatge de programaci\u00f3 concret que a l'executar-se en una m\u00e0quina es converteix en programa . Veiem amb un poc m\u00e9s de detall aquestos conceptes:","title":"Conceptes b\u00e0sics"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#algorisme-vs-programa","text":"Un algorisme \u00e9s un conjunt ordenat i finit d\u2019operacions o instruccions a seguir que permeten trobar la soluci\u00f3 a un problema. Per exemple: algorisme de la suma, la resta, la multiplicaci\u00f3 o la divisi\u00f3. Per tal de fer una suma de xifres de m\u00e9s d\u2019un digit cadascuna, el que es diu comunament sumar portant, hem de seguir unes instruccions que si les realitzem de forma correcta, obtenim el resultat. Doncs b\u00e9, eixes \u2018instruccions\u2019 serien l\u2019algorisme. Un programa no \u00e9s m\u00e9s que un algorisme les \u2018instruccions\u2019 del qual les executa un ordinador.","title":"Algorisme vs Programa"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#caracteristiques-dun-programa","text":"Un algorisme posteriorment convertit a programa ha de complir una s\u00e8rie de caracter\u00edstiques: Finit: ha de comen\u00e7ar i acabar. Llegible: un programa s'escriu una vegada per\u00f2 es llig moltes. Modificable: ha de poder evolucionar. Eficient: No utilitza m\u00e9s recursos dels necessaris Modular: s'ha de dividir en parts el qual millora la legibilitat. Estructurat: utilitza les estructures del paradigma de la programaci\u00f3 estructurada.","title":"Caracter\u00edstiques d'un programa"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#llenguatges-de-programacio","text":"De la mateixa manera que dues persones es comuniquen entre s\u00ed utilitzant un llenguatge natural, una persona es comunica amb una m\u00e0quina utilitzant un llenguatge de programaci\u00f3. Evidentment, un llenguatge de programaci\u00f3 ha de ser m\u00e9s simple i gens ambigu al contrari de com passa amb els llenguatges naturals. Els llenguatges de programaci\u00f3 solen complir les seg\u00fcents caracter\u00edstiques: Existeix un nombre finit de paraules reservades que podem usar: for, var, int, while... \u00c9s a dir, un llenguatge de programaci\u00f3 t\u00e9 un conjunt l\u00e8xic de paraules amb un significat associat com passa amb els llenguatges naturals. Les frases com a combinaci\u00f3 de diferents paraules amb les que ens comuniquem en llenguatge natural es diuen instruccions Cada instrucci\u00f3 finalitza d\u2019una manera concreta, per exemple, utilitzant un \u2018;\u2019 per tal que la m\u00e0quina sapiga quan acaba una instrucci\u00f3 i comen\u00e7a una altra.","title":"Llenguatges de programaci\u00f3"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#classificacio","text":"Els llenguatges de programaci\u00f3 es poden classificar segons els seg\u00fcents criteris PROXIMITAT A LA M\u00c0QUINA Les m\u00e0quines en realitat nom\u00e9s entenen 0 i 1, hi han llenguatges de programaci\u00f3 molts pr\u00f2xims a aquest tipus de codificaci\u00f3 bin\u00e0ria per\u00f2 que s\u00f3n complicats d\u2019entendre per un \u00e9sser hum\u00e0. D\u2019una altra banda existeixen llenguatges que utilitzen un conjunt de paraules reservades que fan que siga m\u00e9s f\u00e0cil d\u2019entendre per una persona. Al final de tot aquest llenguatge m\u00e9s pr\u00f2xim al llenguatge hum\u00e0 acaba convertint-se en una seq\u00fc\u00e8ncia de 0 i 1 la m\u00e0quina pot entendre en el proc\u00e9s de compilaci\u00f3 que veurem m\u00e9s endavant. Llenguatges de baix nivell: s\u00f3n els llenguatges m\u00e9s pr\u00f2xims al llenguatge m\u00e0quina com per exemple el llenguatge assemblador. Llenguatges de nivell mitj\u00e0: llenguatges que s\u2019aproximen un poc m\u00e9s al llenguatge natural utilitzant una s\u00e8rie de paraules reservades que s\u2019utilitzen en llenguatge natural com per exemple el llenguatge C Llenguatges d\u2019alt nivell: Els m\u00e9s pr\u00f2xims al llenguatge natural per\u00f2 sense ambig\u00fcitats. PROPOSIT DEL LLENGUATGE \u00c9s a dir segons quins tipus de programes poden generar, quina \u00e9s la seua finalitat. Llenguatges de prop\u00f2sit general que s\u00f3n capa\u00e7os de crear qualsevol tipus de programa. Llenguatge C Llenguatges de prop\u00f2sit espec\u00edfic que es dissenyen per trEn realitat aquesta faselenguatges de programaci\u00f3, aquests han anat evolucionant i adaptant-se a les noves caracter\u00edstiques tant f\u00edsiques com d\u2019\u00fas del maquinari i els dispositius. SEGONS GENERACI\u00d3 Primera Generaci\u00f3: llenguatges m\u00e0quina i llenguatges assemblador. Anys 40 \u2013 50. En aquesta \u00e8poca s\u2019usaven targetes perforades i es programava utilitzant seq\u00fcencies d\u2019uns i zeros indicant quin c\u00e0lcul havien de realitzar els programes. Els llenguatges assemblador afegeixen la primera capa d\u2019abstracci\u00f3 sobre el binari de forma que una s\u00e8rie d\u2019instruccions simples s\u00f3n despr\u00e9s tradu\u00efdes a binari per la mateixa m\u00e0quina. Aquestes instruccions estaven directament relacionades amb el processador, \u00e9s a dir, cada processador tenia el seu conjunt d'instruccions propi. Segona Generaci\u00f3: Apareixen els llenguatges de nivell mitj\u00e0 i els primers compiladors, que per que ho entenem de moment, s\u00f3n els encarregats de traduir d\u2019un llenguatge de programaci\u00f3 a llenguatge m\u00e0quina o binari. Exemple de llenguatge de nivell mitj\u00e0: FORTRAN (FORmula TRANSlating system) de l\u2019any 1956 Tercera Generaci\u00f3: Apareix la programaci\u00f3 estructurada, ja no nom\u00e9s s\u2019utilitzen els llenguatges de programaci\u00f3 per realitzar c\u00e0lculs matem\u00e0tics com fins ara. Apareix tamb\u00e9 l\u2019\u00fas de variables, subprogrames, estructures etc.. En aquesta generaci\u00f3 podem trobar llenguatges de programaci\u00f3 com C, Pascal o Modula. Quarta Generaci\u00f3: En aquesta generaci\u00f3 trobarem llenguatges desenvolupats per crear un determinat tipus de programari, es configuren per tasques molt concretes. Cinquena Generaci\u00f3: on estarien els llenguatges dissenyats per afrontar la intel\u00b7lig\u00e8ncia artificial com per exemple Prolog. Comen\u00e7a tamb\u00e9 a posar-se en pr\u00e0ctica la programaci\u00f3 orientada a objectes com a nou paradigma de programaci\u00f3. Generaci\u00f3 Visual: nascuda a principis dels anys 90 i com a conseq\u00fc\u00e8ncia de la necessitat de usar interf\u00edcies cada vegada m\u00e9s amigables i f\u00e0cils. FORMA D'EXECUCI\u00d3 Com havien dit abans, abans d\u2019executar un programa escrit en un llenguatge de programaci\u00f3 qualsevol, s\u2019ha de traduir al llenguatge que pot entendre la m\u00e0quina, binari. Aquest proc\u00e9s es pot fer de dues formes: Llenguatges compilats: per tal de compilar un programa es realitzen les seg\u00fcents tasques: an\u00e0lisi l\u00e8xic, sint\u00e0ctic i sem\u00e0ntic del programa, traducci\u00f3 a codi objecte, enlla\u00e7 amb altres llibreries i creaci\u00f3 de l\u2019executable. Llenguatges interpretats: Aquest tipus de codis es lligen,Un diagrama de flux \u00e9s una representaci\u00f3 gr\u00e0fica d'un algorisme. S'utilitza en disciplines com la programaci\u00f3 inform\u00e0tica, l'economia, els processos industrials o la psicologia cognitiva. Aquests diagrames utilitzen s\u00edmbols amb significats ben definits que representen els passos de l'algorisme, i representen el flux d'execuci\u00f3 mitjan\u00e7ant fletxes que connecten els punts d'inici i de finalitzaci\u00f3. Un diagrama de flux sempre t\u00e9 un \u00fanic punt d'inici i un \u00fanic punt de finalitzaci\u00f3. A m\u00e9s, tot cam\u00ed d'execuci\u00f3 ha de permetre arribar des de l'inici fins al final. PARADIGMA DE PROGRAMACI\u00d3 Programaci\u00f3 estructurada: Utilitzen les estructures b\u00e0siques de programaci\u00f3: seq\u00fcencial, alternativa i iterativa combinats amb la programaci\u00f3 modular per dissenyar programes. Programaci\u00f3 orientada a objectes: Entenen els programes com un conjunt d\u2019objectes que tenen unes caracter\u00edstiques pr\u00f2pies, uns m\u00e8todes i que interactuen amb els altres objectes que formen part del sistema. SEGONS NOMBRE DE PROCESSOS \u00c9s a dir, si permeten la execuci\u00f3 concurrent, m\u00e9s d\u2019un proc\u00e9s al mateix temps o no. Per tant ens podem trobar: Llenguatges de programaci\u00f3 concurrent que permeten la concurr\u00e8ncia Llenguatges de programaci\u00f3 no concurrent. SEGONS INTERACTIVITAT Si permeten la interacci\u00f3 amb l\u2019usuari o no. VISUALS O NO ten la programaci\u00f3 per reutilitzaci\u00f3 de components mitjan\u00e7ant drag and drop en un entorn gr\u00e0fic o no.","title":"Classificaci\u00f3"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#paraules-reservades","text":"Els llenguatges de programaci\u00f3 utilitzen una s\u00e8rie de paraules o s\u00edmbols que fan una funci\u00f3 espec\u00edfica dins d\u2019un programa. A aquest conjunt de signes o combinaci\u00f3 d\u2019ells se les anomena paraules reservades. Aquestes paraules nom\u00e9s poden usar-se en un concepte determinat, mai lliurement per l\u2019usuari. Per exemple, el llenguatge C t\u00e9 com a paraules reservades if o while. Ambdues nom\u00e9s podran ser utilitzades en cas que es vullga iniciar una sent\u00e8ncia de control condicional o bucle.","title":"Paraules reservades"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#fases-de-desenvolupament-dun-programa","text":"A l\u2019hora d\u2019afrontar la realitzaci\u00f3 d\u2019un programa hem de tindre clar que hem de fer. \u00c9s un error comen\u00e7ar a crear programari a lo loco ja que nom\u00e9s conseguirem deicar a aquest menester m\u00e9s temps que el que es necessita. A m\u00e9s a m\u00e9s el proc\u00e9s de creaci\u00f3 d\u2019un programa no nom\u00e9s \u00e9s picar codi. D\u2019aquesta manera a l\u2019hora de construir un programa es deurien seguir una s\u00e8rie de fases o pautes:","title":"Fases de desenvolupament d'un programa"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#analisi-del-problema","text":"Estudi del problema, quina \u00e9s la seua finalitat, a qui va dirigit, quins elements ha d\u2019incloure, quines tasques ha de realitzar. En aquesta fase es realitzen entrevistes amb els usuaris o clients entre d\u2019altres t\u00e8cniques. La finalitat d\u2019aquesta fase \u00e9s fer un recull dels diferents requeriments que ha de tenir el nostre producte. Exemple: Imaginem que ens disposem a fer una aplicaci\u00f3 que gestione la fruteria del barri. En aquesta fase \u00e9s on hauriem d'esbrinar, entre altres coses: quins productes es venen, quin preu tenen, l'agenda de clients, quina informaci\u00f3 volem saber dels clients, quina informaci\u00f3 volem saber de prove\u00efdors etc. Suposem que ens farem c\u00e0rrec d'una part xicoteta d'aquesta aplicaci\u00f3: la introducci\u00f3 de tickets de compra nous . En aquesta fase podriem extreure que a un ticket de compra necessitaria que es reflexara la seg\u00fcent informaci\u00f3: Data i hora de la compra. Llista de productes comprats: producte, preu uniitari, quantitat i total. Subtotal de la compra. IVA i descomptes aplicats. Total de la compra. Producte: Requeriments del sistema o aplicaci\u00f3. En base a la informaci\u00f3 que hem aconseguit per mitja d'entrevistes, enquestes etc.. En altres paraules: el que ha de fer la nostra aplicaci\u00f3, finalitat, objectius.","title":"An\u00e0lisi del problema"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#disseny-de-lalgorisme","text":"Es refereix a com anem a sol\u00b7lucionar els requeriments obtiguts a la fase anterior. En aquesta fase s'estudien possibles opcions d'implementaci\u00f3 per a l'aplicaci\u00f3 que hem de construir, aix\u00ed com decidir l'estructura general de la mateixa. El disseny \u00e9s una estapa complexa i el seu proc\u00e9s s'ha de realitzar d'una forma iterativa. Es possible que la soluci\u00f3 inicial no siga la m\u00e9s adequada, per tant en tal cas s'hauria de redefinir. Tammateix, hi ha cat\u00e0legs de patrons de disseny molt \u00fatils que recullen errades que altres han com\u00e9s per no caure a la mateixa trampa. Exemple: Continuant en la nostra aplicaci\u00f3 de la fruteria, en aquesta fase i una vegada acabada la fase d'an\u00e0lisi d'on s'obtenen els requeriments, hauriem de, per un costat triar el paradigma de programaci\u00f3 que escollirem: programaci\u00f3 estructurada o programaci\u00f3 orientada a objectes (Normalment aquest \u00faltim). El llenguatge de programaci\u00f3 a utilitzar. Una vegada ja ho hem triat, hem de decidir com el nostre programa va a complir amb els requeriments obtesos a la fase d'analisi, \u00e9s a dir, com crearem el nou ticket de compra, com afegirem els productes i com calcularem el preu final i imprimirem el document. Producte: Si hem triat el paradigma de programaci\u00f3 estructurada hauriem de dissenyar els diagramres flux de les diferents funcionalitats de l'aplicaci\u00f3, el pseudocodi, etc.. Per exemple en aquesta fase es dissenyaria l'alogorisme en pseudocodi o diagrama de flux on s'indique pas a pas com es faria la introducci\u00f3 d'un ticket nou. En canvi, si pel contrari escollim el paradigma de programaci\u00f3 orientada a objectes obtindriem casos d'\u00fas, diagrames de classes, diagrames de comportament en UML.","title":"Disseny de l'algorisme"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#codificacio","text":"Ha arribat el moment de picar codi. A la fase de codificaci\u00f3, ens arriben els documents (pseudocodi, flux, diagrames de classes, UML) necessaris per poder comen\u00e7ar a programar. En aquesta fase hem d'escollir les eines (IDEs) adequades per poder desenvolupar el nostre projecte i tamb\u00e9 escollirem (va lligat en realitat) el llenguatge de programaci\u00f3 Exemple: seguint amb la fruteria i suposant que ens han passat un pseudocodi de la nostra apliaci\u00f3 de generaci\u00f3 de tickets, podriem per exemple triar l'IDE Visual Studio Code i C# com a llenguatge de programaci\u00f3 o l'IDE Eclipse i Java o Visual Studio i Java... Producte: El projecte amb tots els fitxers que tenen el codi desenvolupat aix\u00ed com tamb\u00e9 els executables o binaris ja compilats i funcionant.","title":"Codificaci\u00f3"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#prova-i-depuracio","text":"Com que errar es d'humans, la fase de proves del cicle de vida de programari busca detectar els errors comesos en les etapes anteriors per tal de poder corregir-los. Per supost, all\u00f2 ideal \u00e9s fer-ho abans que l'usuari final se'ls trobe. Es diu que una prova amb exit \u00e9s una prova que detecta algun error.","title":"Prova i depuraci\u00f3"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#documentacio","text":"Aquesta \u00e9s la fase que a cap programador li agrada fer, per\u00f2 en realitat \u00e9s una fase que no est\u00e0 necess\u00e0riament al final del cicle de vida del programa, sino que es fa de forma transversal en totes les etapes del desenvolupament. Es considera documentaci\u00f3 des dels requeriments inicials al manual d'usuari passant per el pseudocodi, diagrames de classes i \u00fas, i tamb\u00e9 els comentaris que es posen al codi.","title":"Documentaci\u00f3"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#diagrames-de-flux","text":"Un diagrama de flux \u00e9s una representaci\u00f3 gr\u00e0fica d'un algorisme. S'utilitza en disciplines com la programaci\u00f3 inform\u00e0tica, l'economia, els processos industrials o la psicologia cognitiva. Aquests diagrames utilitzen s\u00edmbols amb significats ben definits que representen els passos de l'algorisme, i representen el flux d'execuci\u00f3 mitjan\u00e7ant fletxes que connecten els punts d'inici i de finalitzaci\u00f3. Un diagrama de flux sempre t\u00e9 un \u00fanic punt d'inici i un \u00fanic punt de finalitzaci\u00f3. A m\u00e9s, tot cam\u00ed d'execuci\u00f3 ha de permetre arribar des de l'inici fins al final. Les seg\u00fcents s\u00f3n accions pr\u00e8vies a la realitzaci\u00f3 del diagrama de flux: Identificar les idees principals que s'han d'incloure en el diagrama de flux. Han d'estar presents el propietari o responsable del proc\u00e9s, els propietaris o responsables del proc\u00e9s anterior i posterior i d'altres processos interrelacionats, aix\u00ed com les terceres parts interessades. Definir qu\u00e8 s'espera obtenir del diagrama de flux. Identificar qui ho far\u00e0 servir i com. Establir el nivell de detall requerit. Determinar els l\u00edmits del proc\u00e9s a descriure. Els passos a seguir per construir el diagrama de flux s\u00f3n: Establir l'abast del proc\u00e9s a descriure. D'aquesta manera quedar\u00e0 fixat el comen\u00e7ament i el final del diagrama. Sovint el comen\u00e7ament \u00e9s la sortida del proc\u00e9s previ i el final l'entrada al proc\u00e9s seg\u00fcent. Identificar i llistar les principals activitats/subprocessos que estan incloses en el proc\u00e9s a descriure i el seu ordre cronol\u00f2gic. Si el nivell de detall definit inclou activitats menors, llistar-les tamb\u00e9. Identificar i llistar els punts de decisi\u00f3. Construir el diagrama respectant la seq\u00fc\u00e8ncia cronol\u00f2gica i assignant els corresponents s\u00edmbols. Assignar un t\u00edtol al diagrama i verificar que estigui complet i descrigui amb exactitud el proc\u00e9s escollit.","title":"Diagrames de flux"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#simbologia-i-significat","text":"Oval o el\u00b7lipse: inici i final (obre i/o tanca el diagrama). Rectangle: activitat (representa l'execuci\u00f3 d'una o m\u00e9s activitats o procediments). Rombe: decisi\u00f3 (formula una pregunta o q\u00fcesti\u00f3). Cercle: connector (representa l'enlla\u00e7 d'activitats amb una altra dins d'un procediment). Triangle cap per avall: fitxer definitiu (guarda un document de forma permanent). Triangle cap per amunt: fitxer temporal (proporciona un temps per a l'emmagatzematge del document).","title":"Simbologia i significat"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#exemples","text":"A continuaci\u00f3 vegem alguns exemples que ens ajudaran a entendre-ho millor:","title":"Exemples"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#exemple-1-la-nostra-fruiteria","text":"A la imatge seg\u00fcent podem observar un exemple d'algorisme de creaci\u00f3 d'un nou ticket (nova compra). Expliquem breument el que fa aquest diagrama: primer crea un nou ticket i afegeix un nou element (fruta o verdura), aquesta acci\u00f3 \u00faltima es repeteix fins que acabe de comprar. Quan s'acaba d'afegir items al nou ticket, es calcula el preu final i s'imprimeix.","title":"Exemple 1. La nostra fruiteria"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#exemple-2-trobar-les-claus-de-casa","text":"Imagineu que vull eixir de casa per\u00f2 no recorde on he posat les claus i sense elles no puc anar a cap lloc. Les he de buscar. El seg\u00fcent algorisme representat utilitzant un diagrama de flux, ens podria ajudar a trobar-les.","title":"Exemple 2. Trobar les claus de casa."},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#exemple-3-com-anar-de-lajuntament-al-passeig","text":"Ens trobem a la pla\u00e7a de l'ajuntament i un visitant ens pregunta com arribar al passeig Cervantes. Oberva el seg\u00fcent diagrama de flux. Al tractar-se d'un exemple un poc m\u00e9s extens, primer descriurem les instruccions en llenguatge natural i despr\u00e9s farem el diagrama. Camina pel carrer major en direcci\u00f3 sud Quan arribes a l'encreuament amb el Carrer Ramon y Cajal gira a la dreta Camina fins la farmacia Quan arribes a la farm\u00e0cia gira a l'esquerra Caminar fins encreuament amb el carrer Moreral. Agafa el carrer moreral Al final del carrer moreral a l'esquerra. Una possible soluci\u00f3 a aquest problema podria ser:","title":"Exemple 3. Com anar de l'ajuntament al passeig."},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#exemple-4-fer-zapping","text":"Agafare el commandament Engegar la tele M'agrada el canal? Si no m'agrada canvie de canal Si s\u00ed que m'agrada, deixe el commandament i em pose comode.","title":"Exemple 4. Fer Zapping."},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#exemple-5-adolescencia","text":"","title":"Exemple 5. Adolesc\u00e8ncia"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#pseudocodi","text":"El pseudocodi (o fals llenguatge) \u00e9s una descripci\u00f3 a molt alt nivell de l'estructura d'un programa. Encara que utilitze estructures t\u00edpiques de la programaci\u00f3 es diu que \u00e9s a alt nivell perqu\u00e8 una persona amb pocs o sense coneixements inform\u00e0tics puga entendre i interpretar la porci\u00f3 de codi que estiga llegint. El principal objectiu del pseudocodi \u00e9s el de representar la soluci\u00f3 a un algorisme de la manera m\u00e9s detallada possible, i al mateix temps el m\u00e9s semblant possible al llenguatge que s'utilitzar\u00e0 a la fase de codificaci\u00f3. No existeix una sintaxis est\u00e0ndard de pseudocodi per\u00f2 amb ell s'han de poder escriure totes les estructures de control de la programaci\u00f3 estructurada. De totes formes, en aquest tema utilitzarem la seg\u00fcent sintaxi: ESTRUCTURA SEQ\u00dcENCIAL: 1 2 accio (); accio ( parametres ); ESTRUCTURA ITERATIVA: - fer .. mentre: 1 2 3 fer accions (); mentre ( condicio ); - mentre .. fer: 1 2 3 mentre ( condicio ) fer accions (); fimentre - repetir .. fins: 1 2 3 repetir accions (); fins ( condicio ); ESTRUCTURA ALTERNATIVA O CONDICIONAL: - si .. fsi: 1 2 3 si ( condicio ) aleshores accions (); fisi si .. sino: 1 2 3 4 5 si ( condicio ) aleshores accions1 (); sino accions2 (); fisi si .. sinosi .. sino: 1 2 3 4 5 6 7 si ( condicio1 ) aleshores accions1 (); sino si ( condicio2 ) aleshores accions2 (); sino accions3 (); fisi A continuaci\u00f3 farem els mateixos exemples que hem fet en diagrames de flux per\u00f2 en pseudocodi: ### Exemple 1. La nostra fruiteria. ```java linenums=\"1\" createTicket(); fer { afegirElement(); } mentre continue comprant calcularPreuFinal(); ImprimirTicket();","title":"Pseudocodi"},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#exemple-2trobar-les-claus-de-casa","text":"1 2 3 4 5 buscaClausOnSempre (); mentre ( noTrobabesLesClaus ()) fes buscaClausEnUnAltreLloc () fiMentre EixirDeCasa ();","title":"Exemple 2.Trobar les claus de casa."},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#exemple-3-com-anar-de-lajuntament-al-passeig_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 fer caminarNord (); fins ( arribarAlCarre ( \"Ramon i Cajal\" )); fifer repetir caminar fins arribar ( Farmacia ); firepetir girarEsquerra () mentre NoArribesA ( \"Mestre Esteve\" ) caminar () fimentre AgafarCarrer ( \"Moreral\" ); fins arribarA ( \"Passeig\" ); caminar (); fifins","title":"Exemple 3. Com anar de l'ajuntament al passeig."},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#exemple-4-fer-zapping_1","text":"1 2 3 4 5 6 engegarTele (); fer si ( noAgradaCanal () ) fes canviaCanal (); fsi fins ( trobarCanalQueAgrade )","title":"Exemple 4. Fer Zapping."},{"location":"Tema%2001.%20Introducci%C3%B3%20a%20la%20programaci%C3%B3/#proces-de-compilacio","text":"\u00c9s el proc\u00e9s pel qual es tradueixen les instruccions escrites en un determinat llenguatge de programaci\u00f3 a llenguatge m\u00e0quina. A m\u00e9s d'un traductor, es poden necessitar altres programes per crear un programa objecte executable. Un programa font es pot dividir en m\u00f2duls emmagatzemats en arxius diferents. La tasca de reunir el programa font sovint es confia a un programa diferent, anomenat preprocessador. El preprocessador tamb\u00e9 pot expandir abreviatures, crides a macros, a proposicions del llenguatge font. Normalment la creaci\u00f3 d'un programa executable (un t\u00edpic.exe per a Microsoft Windows o DOS) comporta dos passos. El primer pas es diu compilaci\u00f3 ( pr\u00f2piament dit) i tradueix el codi font escrit en un llenguatge de programaci\u00f3 emmagatzemat en un arxiu a codi de baix nivell (normalment en codi objecte, no directament a llenguatge m\u00e0quina). El segon pas es diu enlla\u00e7at en el qual s'enlla\u00e7a el codi de baix nivell generat de tots els fitxers i subprogrames que s'han enviat compilar i s'afegeix el codi de les funcions que hi ha a les biblioteques del compilador perqu\u00e8 l'executable pugui comunicar-se directament amb el sistema operatiu, traduint aix\u00ed finalment el codi objecte a codi m\u00e0quina, i generant un m\u00f2dul executable. Aquests dos passos es poden fer per separat, emmagatzemant el resultat de la fase de compilaci\u00f3 en arxius objectes (un t\u00edpic .obj per a Microsoft Windows, DOS o per a Unix ), per a enlla\u00e7ar-los en fases posteriors, o crear directament l'executable, amb la qual cosa la fase de compilaci\u00f3 s'emmagatzema nom\u00e9s temporalment. Un programa podria tenir parts escrites en diversos llenguatges (per exemple C, C + + i Asm), que es podrien compilar de forma independent i despr\u00e9s enlla\u00e7ar juntes per formar un \u00fanic m\u00f2dul executable.","title":"Proc\u00e9s de compilaci\u00f3"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/","text":"Tema 2. Programaci\u00f3 Estructurada Introducci\u00f3 Al inici dels temps del la inform\u00e0tica moderna segona meitat dels segle XX) i considerant ordinador programable aquell que seguia l'arquitectura de von Neumann, els primers programes s'escrivien en binari (llenguatge m\u00e0quina) en tarjetes perforades. Aquestes targetes perforades s'utilitzaven per escriure programes sencers amb una finalitat molt concreta. Les targetes s'utilitzaven com a entrada de dades a la m\u00e0quina que s'encarregava de llegir les instruccions escrites en binari, i una a una, carregar-les a mem\u00f2ria i executar-les. Un problema d'aquest incipient paradigma de programaci\u00f3 \u00e9s que cada conjunt d'instruccions \u00e9s espec\u00edfic a cada m\u00e0quina. Amb el temps i conforme augmenta la capacitat de computaci\u00f3 dels ordinadors i tamb\u00e9 la complexitat dels programes, les targetes deixen de ser funcionals i apareixen els primers llenguatges de programaci\u00f3 generalistes com FORTRAN, COBOL o LISP per\u00f2 aquestos encara no utilitzen el paradigma de programaci\u00f3 estructurada. A la decada dels anys 60, B\u00f6hm i Jacopini escriuen el teorema de la programaci\u00f3 estructurada, basant-se per supost en part en aquells llenguatges de programaci\u00f3 que ja exisitien, i arriben a la conclusi\u00f3 qu\u00e8: la sent\u00e8ncia GOTO era una sent\u00e8ncia considerada perjudicial per a la programaci\u00f3 i per entendre els programes escrits en qualsevol llenguatge i tamb\u00e9 que amb nom\u00e9s les estructures seq\u00fcencial, iterativa i condicional era suficient per escriure qualsevol programa. En aquest tema veurem quine s\u00f3n les estructures de control de la programaci\u00f3 estructurada i com s'utilitzen, aix\u00ed com tamb\u00e9 les seues corresponents representacions gr\u00e0fiques en programes escrits en diagrames de flux, pseudocodi o algun llenguatge de programaci\u00f3 d'alt nivell. Conceptes b\u00e0sics El teorema de el programa estructurat \u00e9s un resultat en la teoria de llenguatges de programaci\u00f3. Estableix que tota funci\u00f3 computable pot ser implementada en un llenguatge de programaci\u00f3 que combine nom\u00e9s tres estructures l\u00f2giques. Aquestes tres formes tamb\u00e9 anomenades estructures de control espec\u00edficament s\u00f3n: Seq\u00fc\u00e8ncia: execuci\u00f3 d'una instrucci\u00f3 despr\u00e9s d'una altra. Selecci\u00f3: execuci\u00f3 d'una de dues instruccions (o conjunts), segons el valor d'una variable booleana. Iteraci\u00f3: execuci\u00f3 d'una instrucci\u00f3 (o conjunt) mentre una variable booleana siga 'veritable'. Aquesta estructura l\u00f2gica tamb\u00e9 es coneix com a cicle o bucle. Aquest teorema demostra que la instrucci\u00f3 GOTO no \u00e9s estrictament necess\u00e0ria i que per a tot programa que l'utilitze existeix un altre equivalent que no fa \u00fas d'aquesta instrucci\u00f3. Els cient\u00edfics de la computaci\u00f3 usualment acrediten el teorema a un article de 1966 escrit per Corrado B\u00f6hm i Giuseppe Jacopini . No obstant aix\u00f2, David Harel va rastrejar els seus or\u00edgens fins a la descripci\u00f3 de 1946 de l'arquitectura de von Neumann i el teorema de la forma normal de Kleene. Estructures Com ja hem anomenat als primers putns d'aquest tema, el teorema de la programaci\u00f3 estructurada preveu una s\u00e8rie d'estrucutures b\u00e0siques amb les quals es podr\u00eden codificar tots els algorismes sense necessitat d'usar cap sent\u00e8ncia GOTO o similar. Aquestes estructures s\u00f3n: - Seq\u00fcencial - Condicional - Repetitiva Al final tot algorisme escrit en un llenguatge de programaci\u00f3 estrucuturada s'executa de forma seq\u00fcencial, \u00e9s a dir, es llig la primera sent\u00e8ncia s'executa i despr\u00e8s passem a la seg\u00fcent fins arribar al final. Les estructures condicional i repetitiva es poden interpretar com estructures seq\u00fcencials amb algunes particularitats. L'estructura condicional potser s'execute o no i l'estructura repetitiva s'executara un nombre de vegades. Estructura Seq\u00fcencial Les ordres d'un programa s'executen per defecte en ordre seq\u00fcencial. El que significa que les instruccions s'executen, com hem comentat abans, una darrere de l'altra en el mateix ordre que apareixen escrites al programa. L'estructura seq\u00fcencial \u00e9s l'ordre natura d'execuci\u00f3. Les instruccions que formen part d'aquesta estructura s'executen en ordre una a continuaci\u00f3 de l'altra. Al final de cada instrucci\u00f3 hi ha un punt i coma per indicar-li al compilador el final de la sent\u00e8ncia individual. Les instruccions dintre d'una estructura seq\u00fcencial es solen agrupar en blocs ( {...} ) 1 2 3 4 5 6 7 // Exemple de bloc - estructura seq\u00fcencial { Instrucci\u00f31 ; Instrucci\u00f32 ; ... Instrucci\u00f3N ; } Exemple d'estructura seq\u00fcencial Un exemple d'estructura seq\u00fcencial al m\u00f3n real seria com li podem donar ordres a alg\u00fa per tal que obriga la porta de casa 1 2 3 4 5 6 7 // Exemple d'estructura seq\u00fcencial. // Com engegar la TV { AgafarCommandament (); PremerBotoOn (); TriarCanal (); } En resum podr\u00edem dir que l'estructura seq\u00fcencial no \u00e9s m\u00e9s que un conjunt de sent\u00e8ncies o instruccions individuals agrupades. Estructures de selecci\u00f3 \u00c9s una de les estructures que permeten modificar l'ordre d'execuci\u00f3 de les instruccions del programa. Una estructura condicional determina si s'executen unes accions o altres segons es compleixca o no una determinada condici\u00f3. La condici\u00f3 que es comprova per decidir si unes instruccions s'executen o no deu ser una expressi\u00f3 booleana, \u00e9s a dir, ha de donar com a resultat un valor boole\u00e0 true o false. En programaci\u00f3 estructurada ens podem trobar lse seg\u00fcents: - Selecci\u00f3 simple - Selecci\u00f3 doble - Selecci\u00f3 multiple - Operador condicional ? Selecci\u00f3 Simple \u00c9s l'estructura condicional m\u00e9s simple en programaci\u00f3 estructurada. S'utilitza per determinar si una instrucci\u00f3 o bloc d'instruccions s'executa basat en una condici\u00f3. S'avalua la condici\u00f3 i si es true, s'executa la instrucci\u00f3 o bloc d'instruccions associat a la condici\u00f3. Si mirem b\u00e9 la imatge anterior, el codi que s'executaria seria: S'executa la instrucci\u00f3 1 S'executa la instrucci\u00f3 2 S'avalua a condici\u00f3 Si s'acompleix: S'executa la instrucci\u00f3 3 S'executa la instruccio 4 S'executa la instrucci\u00f3 5 S'executa la instrucci\u00f3 6 En definitiva, al codi anterior podr\u00eden passar dues coses: que s'acompleixca la condici\u00f3 (true) o que no s'acompleixca (false). Si s'avalua true la condici\u00f3 el codi seria: Instrucci\u00f31, Instrucci\u00f32, Instrucci\u00f33, Instrucci\u00f34, Instrucci\u00f35 i Instrucci\u00f36. Pel contrari si s'avalua la condici\u00f3 a false, les instruccions a executar serien: Instrucci\u00f31, Instrucci\u00f32, Instrucci\u00f35 i Instrucci\u00f36. \u00c9s a dir, no s'executarien la 3 i la 4. El seu codi en pseudocodi seria: 1 2 3 4 5 6 7 8 9 10 11 si ( condicio ) aleshores instruccio fsi // O tamb\u00e9 si ( condicio ) aleshores instruccio1 instruccio2 ... instruccioN fsi En el primer cas si quan s'avalua la condici\u00f3 aquesta \u00e9s veritat, s'executaria la instrucci\u00f3 si pel contrari la condici\u00f3 \u00e9s falsa, no es fa res. Al segon cas \u00e9s igual que el primer per\u00f2 en cas d'avaluar-se possitivament la condici\u00f3 no s'executaria una sola instrucci\u00f3 si no que s'executaria (seq\u00fcencialment) el bloc d'instruccions seg\u00fcent: instrucci\u00f31, instrucci\u00f32 fins instrucci\u00f3N. Exemple de selecci\u00f3 simple 1 2 3 4 5 // Exemple de selecci\u00f3 simple si ( tensClausPantalo ) aleshores TreuClau (); ObrelaPorta (); fsi Selecci\u00f3 doble Amb aquesta estructura condicional de la programaci\u00f3 estructurada es poden seguir camins distints depenent de si l'avaluaci\u00f3 de la condici\u00f3 \u00e9s true o false. En altres paraules, si la condici\u00f3 \u00e9s true, executaria una instrucci\u00f3 o bloc d'instruccions mentre que si s'avalua a false executaria una altra instrucci\u00f3 o bloc d'instruccions. El codi en pseudocodi seria 1 2 3 4 5 6 7 8 9 10 11 instruccio1 instruccio2 si ( condicio ) aleshores instruccio3 instruccio4 sino instruccio5 instruccio6 fsi instruccio7 instruccio8 Si ens fixem en el codi anterior, podem trobar dues seq\u00fc\u00e8ncies d'execucio d'instruccions depenenet si la condici\u00f3 del 'si' s'avalua 'veritable' o 'fals'. En el primer cas, amb la condici\u00f3 a veritat, s'executarien: instrucci\u00f31, instrucci\u00f32, instrucci\u00f33, instrucci\u00f34, instrucci\u00f37 i instrucci\u00f38. Mentre que si la condici\u00f3 del 'si' s'avaluara a 'fals', les instruccions a executar serien: instrucci\u00f31, instrucci\u00f32, instrucci\u00f35, instrucci\u00f36, instrucci\u00f37 i instrucci\u00f38. Exemple de selecci\u00f3 doble 1 2 3 4 5 6 7 // Exemple de selecci\u00f3 doble si ( tensClausPantalo ) aleshores TreuClau (); ObrelaPorta (); sino cridarAlTimbre (); fsi Condicinals niats Si volem avaluar m\u00e9s d'una condici\u00f3 al nostre codi, estariem parlant d'una estructura condicional m\u00faltiple que b\u00e0sicament consisteix en encadenar varios if..else. A continuaci\u00f3 es pot veure com seria un exemple de condicional m\u00faltiple en diagrama de flux. El mateix exemple en pseudocodi que teniu a la imatge anterior seria: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 instruccio1 si ( condicio1 ) aleshores instruccio2 instruccio3 sino si ( condicio2 ) aleshores instruccio4 sino si ( condicio3 ) aleshores instruccio5 instruccio6 instruccio7 sino instruccio8 instruccio9 fsi instruccio10 Al codi anterior l'\u00fanic que s\u00ed sabem cert \u00e9s que s'executaran les instruccions 1 i 2 i depenent de quina condici\u00f3 s'avalua a true s'executar\u00e0 algun bloc d'instruccions que estan dins de l'estructura condicional. Exemple d'estructura condicional niada Un repatidor de Mirinda segueix el seg\u00fcent horari de feina: el dilluns reparteix a Pego, el dimarts a Oliva, el dimecres a Ondara, el dijous a El Verger i el divendres a Els poblets. Al seg\u00fcent algorisme s'explica: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Exemple: El repartidor de Mirinda si huiEsDilluns aleshores repartirPego (); sino si huiEsDimarts aleshores repartir ( Oliva (); sino si huiEsDimecres aleshores repartirOndara (); sino si huiEsDijous aleshores repartirElVerger (); sino si huiEsDivendres aleshores repartirElsPoblets (); sino NoEsTreballaHui (); fsi Condicional m\u00faltiple La sent\u00e8ncia de control 'switch' \u00e9s una altra forma de codificar la condici\u00f3 m\u00f9ltiple que hem vist a l'apartat anterior per\u00f2 m\u00e9s senzilla de visualitzar a primer cop d'ull 1 2 3 4 5 6 7 8 9 10 11 12 13 enCasDe ( expressi\u00f3 ) fer cas < opcio1 > Instruccio1 Instruccio2 cas < opcio2 > Instruccio3 Instruccio4 sino Instruccio5 Instruccio6 fiCas L'exemple del repartidor ens serveriria per veure aquesta estructura 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 enCasDe ( huiQuinDiaEs ) fer cas < Dilluns > RepartirPego (); cas < Dimarts > RepartirOliva (); cas < Dimecres > RepartirOndara (); cas < Dijous > RepartirElVerger (); cas < Divendres > RepartirElsPoblets (); sino HuiNoEsTreballa (); fiCas Estructures de repetici\u00f3 Si les estructures condicionals serveixen per determinar quines instruccions o bloc d'instruccions s'executen, la programaci\u00f3 estructurada tamb\u00e9 disposa d'estrutctures repetitives o tamb\u00e9 anomenades bucles, que ens permeten executar una instrucci\u00f3 o bloc d'instruccions diverses vegades. mentre Mentre la condici\u00f3 (tamb\u00e9 anomenada condici\u00f3 d'eixida) siga avaluada com a true, s'executar\u00eden les instruccions que hi ha dins del bucle while. En aquest tipus de bucle, el bloc d'instruccions del bucle while, es poden executar zero o m\u00e9s vegades. Els passos que representen el diagrama anterior s\u00f3n: 1. S'executa la instrucci\u00f3 1 2. S'avalua la condici\u00f3 3. Si la condici\u00f3 \u00e9s true, s'executa el bloc d'instruccions del bucle i es torna a avaluar la condici\u00f3. 4. En cas que la condici\u00f3 s'avalue com a false, passar\u00edem a executar la instrucci\u00f3 2. Exemple: Com far\u00edem el codi necessari per rec\u00f2rrer el nostre array de 100 elements fins trobar el n\u00famero que busquem? 1 2 3 4 mentre ( condicio ) fer Instruccio1 Instruccio2 fmentre repetir .. mentre Molt semblant al bucle while per\u00f2 amb la difer\u00e8ncia que el bloc s'instruccions que cont\u00e9 l'estructura s'executaria almenys una vegada ja que la condici\u00f3 d'eixida s'avalua despr\u00e9s d'executar les instruccions. Els passos que representen el diagrama anterior s\u00f3n: 1. S'executa la instrucci\u00f3 1 2. S'executen les instruccions que cont\u00e9 el bloc 3. S'avalua la condici\u00f3 4. Si la condici\u00f3 \u00e9s true, s'executa el bloc d'instruccions del bucle i es torna a avaluar la condici\u00f3. 5. En cas que la condici\u00f3 s'avalue com a false, passar\u00edem a executar la instrucci\u00f3 2. Exemple: Com far\u00edem el codi necessari per rec\u00f2rrer el nostre array de 100 elements fins trobar el n\u00famero que busquem? 1 2 3 4 fer Instruccio1 Instruccio2 mentre ( condicio ) bucle per La m\u00e9s complicada de comprendre per\u00f2 tamb\u00e9 possiblement la m\u00e9s utilitzada. Mirem un exemple. Executem instrucci\u00f3 1 (aliena al bucle for) Inicialitzaci\u00f3 Avaluaci\u00f3 de la condici\u00f3 Si la condici\u00f3 \u00e9s true Executem les instruccions del bucle for Actualitzem \u00edndex Si la condici\u00f3 es false eixim del bucle i executem instrucci\u00f3 2 1 2 3 4 per i = 0 a 100 fer Instruccio1 Instruccio2 fiper Al codi anterior: 1. Inicialitzaci\u00f3: int i = 0; 2. Avaluaci\u00f3 de la condici\u00f3: \u00e9s i < 100 ? 3. Instruccio1 i Instruccio2 4. Actualitzaci\u00f3: i ++ Activitats Activitat 1. Iniciar sessi\u00f3 a Facebook Dibuixa un diagrama de flux per iniciar sessi\u00f3 en un compte de Facebook. Obrim el navegador web. Escrivim facebook.com Aquesta solicitud s'envia a Facebook i respon enviant-nos a la p\u00e0gina d'inici o login. Escrivim les nostres credencials, email i contrasenya i fem clic a inciar. Si es correcte es mostrar\u00e0 la p\u00e0gina del nostre perfil. En cas contrari, es produir\u00e0 un error i ens demanar\u00e0 una altra vegada usuari i contrasenya. Acitivitat 2. Area d'un rectangle Calcula l'area d'un rectangle donades les seues dimensions Inserim la base. Especifiquem l'al\u00e7ada. Calculem l'\u00e0rea: base x al\u00e7ada Mostrem el resultat per pantalla. Activitat 3. Hola m\u00f3n 10 vegades Escriu el diagrama de flux necessari per imprimr per pantalla 10 vegades \"hola m\u00f3n\" Resolem aquesta activitat utilitzant el concepte bucle. Creem la variable \"cuenta\" i l'incialitzem a 0. Despr\u00e9s imprimim \"Hola m\u00f3n\" i incrementem la variable \"cuenta\" en uno. Verifiquem si \"cuenta\" encara \u00e9s menor que 10. En cas veritable, imprimim \"Hola m\u00f3n\" i tornem a incrementar. Quan la \"cuenta\" valga 10 eixim del programa. Cuneta = 0; Imprimir \"Hola m\u00f3n\" Incrementem cuenta Si cuenta < 10 tornem al pas 2 en cas contrari s'acaba l'execucui\u00f3 Activitat 4. Preparar el t\u00e9 Dibuixa el diagrama de flux amb els passos necessaris per preparar el t\u00e9. Comprar t\u00e9 i/o sucre. Tindre tassa i cullera. Posar a bollir aigua. Posar la bossa de t\u00e9 a la tassa. Posar aigua a la tassa amb la bossa (de t\u00e9). Esperar uns minuts a que es disolga el t\u00e9. Retirar la bossa (de t\u00e9) Vols sucre? Si la resposta \u00e9s s\u00ed, posar sucre i remenejar. Si la resposta \u00e9s no s'acabat el proc\u00e9s. Activitat 5. N\u00famero major Escriu el diagrama de flux de tal forma que donats dos n\u00fameros ens indique quin \u00e9s m\u00e9s gran. Introudir els valors A i B Llegir els seus valors Si A == B tornar al pas 1 Si A > B escriure per pantalla: \"A \u00e9s major que B\" En cas contrari escriure: \"B \u00e9s major que A\". Acabar el proc\u00e9s, Activitat 6. Suma dos n\u00fameros Algorisme que demana dos n\u00fameros i els suma mostrant el resultat per pantalla. Declarem la variable suma i la inicialitzem a 0. Inserim dos n\u00fameros. Sumem els dos n\u00fameros i els afegim a suma. Mostrem suma per pantalla. Activitat 7. Llevar la fam Ens trobem a casa i tenim fam. Qu\u00e8 fem? Preguntem si tenim fam. Si la resposta \u00e9s no s'acaba el procediment, ja estem satisfets. Si la resposta \u00e9s si busquem el menjar a la nevera. Si hi ha menjar a la nevera la calfem i mengem Si no hi ha res a la nevera, eixim de compres i tornem, preparem algo i mengem. Activitat 8. Par o impar Algorisme que determina si el n\u00famero que inserim \u00e9s parell o senar. Introduim un n\u00famero 'N' Si 'N' es divideix entre 2 i el residu \u00e9s 0 (N mod 2 = 0), aleshores 'N' \u00e9s parell. En cas contrari \u00e9s senar. Activitat 9. Agafar el paraig\u00fces Algorisme per determinar quan ixc de casa si necessite o no agafar un paraig\u00fces. Comprovem si est\u00e0 plovent. Si la resposta \u00e9s No, eixim al carrer sense paraig\u00fces. Si la resposta \u00e9s S\u00ed, busquem el paraig\u00fces Si el trobem eixim al carrer En cas contrari tornem al pas 1. Activitat 10. Mitjana Algorisme que calcula la mitjana d'un alumne amb tres notes i mostra per pantalla si est\u00e0 \"Aprovat\" o \"Susp\u00e9s\". La nota m\u00ednima per aprovar \u00e9s 11. Declarem les variables a utilitzar: Nota1, Nota2, Nota3, Mitjana. Inserim les notes per teclat. Calculem la mitjana Verifiquem si la mitjana \u00e9s major o igual a 11. Si \u00e9s major que 11, escrivim per pantalla \"Aprovat\" En cas contrari escrivim \"Susp\u00e9s\" Activitat 11. Pseudocodi Passa a pseudocodi els diagrames de flux anteriors","title":"Tema 2. Programaci\u00f3 Estructurada"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#tema-2-programacio-estructurada","text":"","title":"Tema 2. Programaci\u00f3 Estructurada"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#introduccio","text":"Al inici dels temps del la inform\u00e0tica moderna segona meitat dels segle XX) i considerant ordinador programable aquell que seguia l'arquitectura de von Neumann, els primers programes s'escrivien en binari (llenguatge m\u00e0quina) en tarjetes perforades. Aquestes targetes perforades s'utilitzaven per escriure programes sencers amb una finalitat molt concreta. Les targetes s'utilitzaven com a entrada de dades a la m\u00e0quina que s'encarregava de llegir les instruccions escrites en binari, i una a una, carregar-les a mem\u00f2ria i executar-les. Un problema d'aquest incipient paradigma de programaci\u00f3 \u00e9s que cada conjunt d'instruccions \u00e9s espec\u00edfic a cada m\u00e0quina. Amb el temps i conforme augmenta la capacitat de computaci\u00f3 dels ordinadors i tamb\u00e9 la complexitat dels programes, les targetes deixen de ser funcionals i apareixen els primers llenguatges de programaci\u00f3 generalistes com FORTRAN, COBOL o LISP per\u00f2 aquestos encara no utilitzen el paradigma de programaci\u00f3 estructurada. A la decada dels anys 60, B\u00f6hm i Jacopini escriuen el teorema de la programaci\u00f3 estructurada, basant-se per supost en part en aquells llenguatges de programaci\u00f3 que ja exisitien, i arriben a la conclusi\u00f3 qu\u00e8: la sent\u00e8ncia GOTO era una sent\u00e8ncia considerada perjudicial per a la programaci\u00f3 i per entendre els programes escrits en qualsevol llenguatge i tamb\u00e9 que amb nom\u00e9s les estructures seq\u00fcencial, iterativa i condicional era suficient per escriure qualsevol programa. En aquest tema veurem quine s\u00f3n les estructures de control de la programaci\u00f3 estructurada i com s'utilitzen, aix\u00ed com tamb\u00e9 les seues corresponents representacions gr\u00e0fiques en programes escrits en diagrames de flux, pseudocodi o algun llenguatge de programaci\u00f3 d'alt nivell.","title":"Introducci\u00f3"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#conceptes-basics","text":"El teorema de el programa estructurat \u00e9s un resultat en la teoria de llenguatges de programaci\u00f3. Estableix que tota funci\u00f3 computable pot ser implementada en un llenguatge de programaci\u00f3 que combine nom\u00e9s tres estructures l\u00f2giques. Aquestes tres formes tamb\u00e9 anomenades estructures de control espec\u00edficament s\u00f3n: Seq\u00fc\u00e8ncia: execuci\u00f3 d'una instrucci\u00f3 despr\u00e9s d'una altra. Selecci\u00f3: execuci\u00f3 d'una de dues instruccions (o conjunts), segons el valor d'una variable booleana. Iteraci\u00f3: execuci\u00f3 d'una instrucci\u00f3 (o conjunt) mentre una variable booleana siga 'veritable'. Aquesta estructura l\u00f2gica tamb\u00e9 es coneix com a cicle o bucle. Aquest teorema demostra que la instrucci\u00f3 GOTO no \u00e9s estrictament necess\u00e0ria i que per a tot programa que l'utilitze existeix un altre equivalent que no fa \u00fas d'aquesta instrucci\u00f3. Els cient\u00edfics de la computaci\u00f3 usualment acrediten el teorema a un article de 1966 escrit per Corrado B\u00f6hm i Giuseppe Jacopini . No obstant aix\u00f2, David Harel va rastrejar els seus or\u00edgens fins a la descripci\u00f3 de 1946 de l'arquitectura de von Neumann i el teorema de la forma normal de Kleene.","title":"Conceptes b\u00e0sics"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#estructures","text":"Com ja hem anomenat als primers putns d'aquest tema, el teorema de la programaci\u00f3 estructurada preveu una s\u00e8rie d'estrucutures b\u00e0siques amb les quals es podr\u00eden codificar tots els algorismes sense necessitat d'usar cap sent\u00e8ncia GOTO o similar. Aquestes estructures s\u00f3n: - Seq\u00fcencial - Condicional - Repetitiva Al final tot algorisme escrit en un llenguatge de programaci\u00f3 estrucuturada s'executa de forma seq\u00fcencial, \u00e9s a dir, es llig la primera sent\u00e8ncia s'executa i despr\u00e8s passem a la seg\u00fcent fins arribar al final. Les estructures condicional i repetitiva es poden interpretar com estructures seq\u00fcencials amb algunes particularitats. L'estructura condicional potser s'execute o no i l'estructura repetitiva s'executara un nombre de vegades.","title":"Estructures"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#estructura-sequencial","text":"Les ordres d'un programa s'executen per defecte en ordre seq\u00fcencial. El que significa que les instruccions s'executen, com hem comentat abans, una darrere de l'altra en el mateix ordre que apareixen escrites al programa. L'estructura seq\u00fcencial \u00e9s l'ordre natura d'execuci\u00f3. Les instruccions que formen part d'aquesta estructura s'executen en ordre una a continuaci\u00f3 de l'altra. Al final de cada instrucci\u00f3 hi ha un punt i coma per indicar-li al compilador el final de la sent\u00e8ncia individual. Les instruccions dintre d'una estructura seq\u00fcencial es solen agrupar en blocs ( {...} ) 1 2 3 4 5 6 7 // Exemple de bloc - estructura seq\u00fcencial { Instrucci\u00f31 ; Instrucci\u00f32 ; ... Instrucci\u00f3N ; }","title":"Estructura Seq\u00fcencial"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#exemple-destructura-sequencial","text":"Un exemple d'estructura seq\u00fcencial al m\u00f3n real seria com li podem donar ordres a alg\u00fa per tal que obriga la porta de casa 1 2 3 4 5 6 7 // Exemple d'estructura seq\u00fcencial. // Com engegar la TV { AgafarCommandament (); PremerBotoOn (); TriarCanal (); } En resum podr\u00edem dir que l'estructura seq\u00fcencial no \u00e9s m\u00e9s que un conjunt de sent\u00e8ncies o instruccions individuals agrupades.","title":"Exemple d'estructura seq\u00fcencial"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#estructures-de-seleccio","text":"\u00c9s una de les estructures que permeten modificar l'ordre d'execuci\u00f3 de les instruccions del programa. Una estructura condicional determina si s'executen unes accions o altres segons es compleixca o no una determinada condici\u00f3. La condici\u00f3 que es comprova per decidir si unes instruccions s'executen o no deu ser una expressi\u00f3 booleana, \u00e9s a dir, ha de donar com a resultat un valor boole\u00e0 true o false. En programaci\u00f3 estructurada ens podem trobar lse seg\u00fcents: - Selecci\u00f3 simple - Selecci\u00f3 doble - Selecci\u00f3 multiple - Operador condicional ?","title":"Estructures de selecci\u00f3"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#seleccio-simple","text":"\u00c9s l'estructura condicional m\u00e9s simple en programaci\u00f3 estructurada. S'utilitza per determinar si una instrucci\u00f3 o bloc d'instruccions s'executa basat en una condici\u00f3. S'avalua la condici\u00f3 i si es true, s'executa la instrucci\u00f3 o bloc d'instruccions associat a la condici\u00f3. Si mirem b\u00e9 la imatge anterior, el codi que s'executaria seria: S'executa la instrucci\u00f3 1 S'executa la instrucci\u00f3 2 S'avalua a condici\u00f3 Si s'acompleix: S'executa la instrucci\u00f3 3 S'executa la instruccio 4 S'executa la instrucci\u00f3 5 S'executa la instrucci\u00f3 6 En definitiva, al codi anterior podr\u00eden passar dues coses: que s'acompleixca la condici\u00f3 (true) o que no s'acompleixca (false). Si s'avalua true la condici\u00f3 el codi seria: Instrucci\u00f31, Instrucci\u00f32, Instrucci\u00f33, Instrucci\u00f34, Instrucci\u00f35 i Instrucci\u00f36. Pel contrari si s'avalua la condici\u00f3 a false, les instruccions a executar serien: Instrucci\u00f31, Instrucci\u00f32, Instrucci\u00f35 i Instrucci\u00f36. \u00c9s a dir, no s'executarien la 3 i la 4. El seu codi en pseudocodi seria: 1 2 3 4 5 6 7 8 9 10 11 si ( condicio ) aleshores instruccio fsi // O tamb\u00e9 si ( condicio ) aleshores instruccio1 instruccio2 ... instruccioN fsi En el primer cas si quan s'avalua la condici\u00f3 aquesta \u00e9s veritat, s'executaria la instrucci\u00f3 si pel contrari la condici\u00f3 \u00e9s falsa, no es fa res. Al segon cas \u00e9s igual que el primer per\u00f2 en cas d'avaluar-se possitivament la condici\u00f3 no s'executaria una sola instrucci\u00f3 si no que s'executaria (seq\u00fcencialment) el bloc d'instruccions seg\u00fcent: instrucci\u00f31, instrucci\u00f32 fins instrucci\u00f3N.","title":"Selecci\u00f3 Simple"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#exemple-de-seleccio-simple","text":"1 2 3 4 5 // Exemple de selecci\u00f3 simple si ( tensClausPantalo ) aleshores TreuClau (); ObrelaPorta (); fsi","title":"Exemple de selecci\u00f3 simple"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#seleccio-doble","text":"Amb aquesta estructura condicional de la programaci\u00f3 estructurada es poden seguir camins distints depenent de si l'avaluaci\u00f3 de la condici\u00f3 \u00e9s true o false. En altres paraules, si la condici\u00f3 \u00e9s true, executaria una instrucci\u00f3 o bloc d'instruccions mentre que si s'avalua a false executaria una altra instrucci\u00f3 o bloc d'instruccions. El codi en pseudocodi seria 1 2 3 4 5 6 7 8 9 10 11 instruccio1 instruccio2 si ( condicio ) aleshores instruccio3 instruccio4 sino instruccio5 instruccio6 fsi instruccio7 instruccio8 Si ens fixem en el codi anterior, podem trobar dues seq\u00fc\u00e8ncies d'execucio d'instruccions depenenet si la condici\u00f3 del 'si' s'avalua 'veritable' o 'fals'. En el primer cas, amb la condici\u00f3 a veritat, s'executarien: instrucci\u00f31, instrucci\u00f32, instrucci\u00f33, instrucci\u00f34, instrucci\u00f37 i instrucci\u00f38. Mentre que si la condici\u00f3 del 'si' s'avaluara a 'fals', les instruccions a executar serien: instrucci\u00f31, instrucci\u00f32, instrucci\u00f35, instrucci\u00f36, instrucci\u00f37 i instrucci\u00f38.","title":"Selecci\u00f3 doble"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#exemple-de-seleccio-doble","text":"1 2 3 4 5 6 7 // Exemple de selecci\u00f3 doble si ( tensClausPantalo ) aleshores TreuClau (); ObrelaPorta (); sino cridarAlTimbre (); fsi","title":"Exemple de selecci\u00f3 doble"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#condicinals-niats","text":"Si volem avaluar m\u00e9s d'una condici\u00f3 al nostre codi, estariem parlant d'una estructura condicional m\u00faltiple que b\u00e0sicament consisteix en encadenar varios if..else. A continuaci\u00f3 es pot veure com seria un exemple de condicional m\u00faltiple en diagrama de flux. El mateix exemple en pseudocodi que teniu a la imatge anterior seria: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 instruccio1 si ( condicio1 ) aleshores instruccio2 instruccio3 sino si ( condicio2 ) aleshores instruccio4 sino si ( condicio3 ) aleshores instruccio5 instruccio6 instruccio7 sino instruccio8 instruccio9 fsi instruccio10 Al codi anterior l'\u00fanic que s\u00ed sabem cert \u00e9s que s'executaran les instruccions 1 i 2 i depenent de quina condici\u00f3 s'avalua a true s'executar\u00e0 algun bloc d'instruccions que estan dins de l'estructura condicional.","title":"Condicinals niats"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#exemple-destructura-condicional-niada","text":"Un repatidor de Mirinda segueix el seg\u00fcent horari de feina: el dilluns reparteix a Pego, el dimarts a Oliva, el dimecres a Ondara, el dijous a El Verger i el divendres a Els poblets. Al seg\u00fcent algorisme s'explica: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Exemple: El repartidor de Mirinda si huiEsDilluns aleshores repartirPego (); sino si huiEsDimarts aleshores repartir ( Oliva (); sino si huiEsDimecres aleshores repartirOndara (); sino si huiEsDijous aleshores repartirElVerger (); sino si huiEsDivendres aleshores repartirElsPoblets (); sino NoEsTreballaHui (); fsi","title":"Exemple d'estructura condicional niada"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#condicional-multiple","text":"La sent\u00e8ncia de control 'switch' \u00e9s una altra forma de codificar la condici\u00f3 m\u00f9ltiple que hem vist a l'apartat anterior per\u00f2 m\u00e9s senzilla de visualitzar a primer cop d'ull 1 2 3 4 5 6 7 8 9 10 11 12 13 enCasDe ( expressi\u00f3 ) fer cas < opcio1 > Instruccio1 Instruccio2 cas < opcio2 > Instruccio3 Instruccio4 sino Instruccio5 Instruccio6 fiCas L'exemple del repartidor ens serveriria per veure aquesta estructura 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 enCasDe ( huiQuinDiaEs ) fer cas < Dilluns > RepartirPego (); cas < Dimarts > RepartirOliva (); cas < Dimecres > RepartirOndara (); cas < Dijous > RepartirElVerger (); cas < Divendres > RepartirElsPoblets (); sino HuiNoEsTreballa (); fiCas","title":"Condicional m\u00faltiple"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#estructures-de-repeticio","text":"Si les estructures condicionals serveixen per determinar quines instruccions o bloc d'instruccions s'executen, la programaci\u00f3 estructurada tamb\u00e9 disposa d'estrutctures repetitives o tamb\u00e9 anomenades bucles, que ens permeten executar una instrucci\u00f3 o bloc d'instruccions diverses vegades.","title":"Estructures de repetici\u00f3"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#mentre","text":"Mentre la condici\u00f3 (tamb\u00e9 anomenada condici\u00f3 d'eixida) siga avaluada com a true, s'executar\u00eden les instruccions que hi ha dins del bucle while. En aquest tipus de bucle, el bloc d'instruccions del bucle while, es poden executar zero o m\u00e9s vegades. Els passos que representen el diagrama anterior s\u00f3n: 1. S'executa la instrucci\u00f3 1 2. S'avalua la condici\u00f3 3. Si la condici\u00f3 \u00e9s true, s'executa el bloc d'instruccions del bucle i es torna a avaluar la condici\u00f3. 4. En cas que la condici\u00f3 s'avalue com a false, passar\u00edem a executar la instrucci\u00f3 2. Exemple: Com far\u00edem el codi necessari per rec\u00f2rrer el nostre array de 100 elements fins trobar el n\u00famero que busquem? 1 2 3 4 mentre ( condicio ) fer Instruccio1 Instruccio2 fmentre","title":"mentre"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#repetir-mentre","text":"Molt semblant al bucle while per\u00f2 amb la difer\u00e8ncia que el bloc s'instruccions que cont\u00e9 l'estructura s'executaria almenys una vegada ja que la condici\u00f3 d'eixida s'avalua despr\u00e9s d'executar les instruccions. Els passos que representen el diagrama anterior s\u00f3n: 1. S'executa la instrucci\u00f3 1 2. S'executen les instruccions que cont\u00e9 el bloc 3. S'avalua la condici\u00f3 4. Si la condici\u00f3 \u00e9s true, s'executa el bloc d'instruccions del bucle i es torna a avaluar la condici\u00f3. 5. En cas que la condici\u00f3 s'avalue com a false, passar\u00edem a executar la instrucci\u00f3 2. Exemple: Com far\u00edem el codi necessari per rec\u00f2rrer el nostre array de 100 elements fins trobar el n\u00famero que busquem? 1 2 3 4 fer Instruccio1 Instruccio2 mentre ( condicio )","title":"repetir .. mentre"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#bucle-per","text":"La m\u00e9s complicada de comprendre per\u00f2 tamb\u00e9 possiblement la m\u00e9s utilitzada. Mirem un exemple. Executem instrucci\u00f3 1 (aliena al bucle for) Inicialitzaci\u00f3 Avaluaci\u00f3 de la condici\u00f3 Si la condici\u00f3 \u00e9s true Executem les instruccions del bucle for Actualitzem \u00edndex Si la condici\u00f3 es false eixim del bucle i executem instrucci\u00f3 2 1 2 3 4 per i = 0 a 100 fer Instruccio1 Instruccio2 fiper Al codi anterior: 1. Inicialitzaci\u00f3: int i = 0; 2. Avaluaci\u00f3 de la condici\u00f3: \u00e9s i < 100 ? 3. Instruccio1 i Instruccio2 4. Actualitzaci\u00f3: i ++","title":"bucle per"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#activitats","text":"","title":"Activitats"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#activitat-1-iniciar-sessio-a-facebook","text":"Dibuixa un diagrama de flux per iniciar sessi\u00f3 en un compte de Facebook. Obrim el navegador web. Escrivim facebook.com Aquesta solicitud s'envia a Facebook i respon enviant-nos a la p\u00e0gina d'inici o login. Escrivim les nostres credencials, email i contrasenya i fem clic a inciar. Si es correcte es mostrar\u00e0 la p\u00e0gina del nostre perfil. En cas contrari, es produir\u00e0 un error i ens demanar\u00e0 una altra vegada usuari i contrasenya.","title":"Activitat 1. Iniciar sessi\u00f3 a Facebook"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#acitivitat-2-area-dun-rectangle","text":"Calcula l'area d'un rectangle donades les seues dimensions Inserim la base. Especifiquem l'al\u00e7ada. Calculem l'\u00e0rea: base x al\u00e7ada Mostrem el resultat per pantalla.","title":"Acitivitat 2. Area d'un rectangle"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#activitat-3-hola-mon-10-vegades","text":"Escriu el diagrama de flux necessari per imprimr per pantalla 10 vegades \"hola m\u00f3n\" Resolem aquesta activitat utilitzant el concepte bucle. Creem la variable \"cuenta\" i l'incialitzem a 0. Despr\u00e9s imprimim \"Hola m\u00f3n\" i incrementem la variable \"cuenta\" en uno. Verifiquem si \"cuenta\" encara \u00e9s menor que 10. En cas veritable, imprimim \"Hola m\u00f3n\" i tornem a incrementar. Quan la \"cuenta\" valga 10 eixim del programa. Cuneta = 0; Imprimir \"Hola m\u00f3n\" Incrementem cuenta Si cuenta < 10 tornem al pas 2 en cas contrari s'acaba l'execucui\u00f3","title":"Activitat 3. Hola m\u00f3n 10 vegades"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#activitat-4-preparar-el-te","text":"Dibuixa el diagrama de flux amb els passos necessaris per preparar el t\u00e9. Comprar t\u00e9 i/o sucre. Tindre tassa i cullera. Posar a bollir aigua. Posar la bossa de t\u00e9 a la tassa. Posar aigua a la tassa amb la bossa (de t\u00e9). Esperar uns minuts a que es disolga el t\u00e9. Retirar la bossa (de t\u00e9) Vols sucre? Si la resposta \u00e9s s\u00ed, posar sucre i remenejar. Si la resposta \u00e9s no s'acabat el proc\u00e9s.","title":"Activitat 4. Preparar el t\u00e9"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#activitat-5-numero-major","text":"Escriu el diagrama de flux de tal forma que donats dos n\u00fameros ens indique quin \u00e9s m\u00e9s gran. Introudir els valors A i B Llegir els seus valors Si A == B tornar al pas 1 Si A > B escriure per pantalla: \"A \u00e9s major que B\" En cas contrari escriure: \"B \u00e9s major que A\". Acabar el proc\u00e9s,","title":"Activitat 5. N\u00famero major"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#activitat-6-suma-dos-numeros","text":"Algorisme que demana dos n\u00fameros i els suma mostrant el resultat per pantalla. Declarem la variable suma i la inicialitzem a 0. Inserim dos n\u00fameros. Sumem els dos n\u00fameros i els afegim a suma. Mostrem suma per pantalla.","title":"Activitat 6. Suma dos n\u00fameros"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#activitat-7-llevar-la-fam","text":"Ens trobem a casa i tenim fam. Qu\u00e8 fem? Preguntem si tenim fam. Si la resposta \u00e9s no s'acaba el procediment, ja estem satisfets. Si la resposta \u00e9s si busquem el menjar a la nevera. Si hi ha menjar a la nevera la calfem i mengem Si no hi ha res a la nevera, eixim de compres i tornem, preparem algo i mengem.","title":"Activitat 7. Llevar la fam"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#activitat-8-par-o-impar","text":"Algorisme que determina si el n\u00famero que inserim \u00e9s parell o senar. Introduim un n\u00famero 'N' Si 'N' es divideix entre 2 i el residu \u00e9s 0 (N mod 2 = 0), aleshores 'N' \u00e9s parell. En cas contrari \u00e9s senar.","title":"Activitat 8. Par o impar"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#activitat-9-agafar-el-paraigues","text":"Algorisme per determinar quan ixc de casa si necessite o no agafar un paraig\u00fces. Comprovem si est\u00e0 plovent. Si la resposta \u00e9s No, eixim al carrer sense paraig\u00fces. Si la resposta \u00e9s S\u00ed, busquem el paraig\u00fces Si el trobem eixim al carrer En cas contrari tornem al pas 1.","title":"Activitat 9. Agafar el paraig\u00fces"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#activitat-10-mitjana","text":"Algorisme que calcula la mitjana d'un alumne amb tres notes i mostra per pantalla si est\u00e0 \"Aprovat\" o \"Susp\u00e9s\". La nota m\u00ednima per aprovar \u00e9s 11. Declarem les variables a utilitzar: Nota1, Nota2, Nota3, Mitjana. Inserim les notes per teclat. Calculem la mitjana Verifiquem si la mitjana \u00e9s major o igual a 11. Si \u00e9s major que 11, escrivim per pantalla \"Aprovat\" En cas contrari escrivim \"Susp\u00e9s\"","title":"Activitat 10. Mitjana"},{"location":"Tema%2002.%20Programaci%C3%B3%20Estructurada/#activitat-11-pseudocodi","text":"Passa a pseudocodi els diagrames de flux anteriors","title":"Activitat 11. Pseudocodi"},{"location":"Tema%2003.%20El%20llenguatge%20Java/","text":"Tema 3. El llenguatge Java Introducci\u00f3 Una vegada estudiat el teorema del programa estructurat juntamnet amb els diagrames de flux i psuedocodi, passem a veure aquestos conceptes te\u00f2rics en un llenguatge de programaci\u00f3 d'alt nivell concret com \u00e9s el llenguatge de programaci\u00f3 Java. En aquest tema veurem la sintaxis b\u00e0sica de Java: paraules reservades, dades, variables, constants, identificadors i com tamb\u00e9 es codifiquen les estructures de control vistes al tema anterior en llenguatge Java. Dades, Variables i identificadors. Una dada per una altra banda \u00e9s: \"la representaci\u00f3 convencional de la informaci\u00f3 en un format adequat perqu\u00e8 puga ser processada, comunicada o interpretada per mitjans manuals o autom\u00e0tics.\" Per un altre costat una variable \u00e9s: \"una expressi\u00f3 matem\u00e0tica, s\u00edmbol que representa una quantitat el valor num\u00e8ric de la qual no s'especifica.\" En qualsevol llenguatge de programaci\u00f3 existeixen una s\u00e8rie d'elements com variables, constants, funcions, llibreries. Aquestos elements requereixen d'un nom per tal de distingir-lo de la resta. Aquestos noms es diuen identificadors Un identificador \u00e9s una cadena alfan\u00famerica que representa o dona un nom a un element dins del nostre programa. Els identificadors de les variables s\u00f3n noms que s'inventa el programador i s'hauria de tindre en consideraci\u00f3 al seg\u00fcent m\u00e0xima: Quan triem el nom per identificar a una variable, ha de ser significatiu, \u00e9s a dir, que el mateix identificador ja done alguna pista de que \u00e9s el que representa. Normes per construir identificadors en Java 1. Estan formats per caracters i/o digits. 2. No poden comen\u00e7ar per digit. 3. No poden usar els seg\u00fcents caracters especials: + - * / = % & # ! ? ^ \u201c \u2018 ~ \\ | < > ( ) [ ] { } : ; . , 4. No poden ser cap paraula reservada de Java 5. Els identificadors de Java distingeixen entre maj\u00fascules i min\u00fascules (case sensitive) 6. No hi ha l\u00edmit a la llarg\u00e0ria de l'identificador, per\u00f2 \u00e9s aconsellable utilitzar una grand\u00e0ria \u00f2ptima entre 4 i 15 caracters. Paraules reservades Uns dels principals identificadors que ens trobarem a tot llenguatge de programaci\u00f3 s\u00f3n les paraules reservades . Per entendre-ho, el conjunt de paraules reservades d'un llenguatge de programaci\u00f3 s\u00f3n el diccionari de totes les paraules que t\u00e9 aquest llenguatge. Aquetes paraules reservades no poden utilitzar-se per cap altra cosa m\u00e9s, per exemple, si Java t\u00e9 la paraula reservada public , el programador no podr\u00e0 crear cap variable utilitzant l'identificador public. Paraules reservadoes a Java abstract continue for new switch assert default goto package sychronized boolean do if private this break double implements protected throw byte else import public thows case enum instanceof return transient catch extends int short try char final interface static void class finally long strictfp volatile const float native super while Tipus de dades Tot llenguatge de programaci\u00f3 porta una s\u00e8rie de tipus de dades predefinits que es poden usar. Aquestos tipus de dades tamb\u00e9 es coneixen com a tipus primitius o tipus simples. . Java defineix 8 tipus diferents de dades: byte, short, int, long, char, float, double i boolean. Aquestos tipus es poden agrupar en quatre blocs: Nombres enters: on podem trobar el byte, short, long i int. Aquestos tipus admeten valors no fraccionables en parts m\u00e9s xicotetes que la unitat. Per exemple: 1, 3, 5, 15, 20, 132... Punt flotant: aquest grup inclou el float i el double on es representen els nombres decimals, \u00e9s a dir, aquells que s\u00ed admeten fraccions. Per exemple: 1.3, 5.802039, etc.. Caracters: char representa a tot el conjunt de caracters del nostre sistema alfab\u00e8tic inclosos els s\u00edmbols. Per exmple: a, b, c, $, ?... Boole\u00e0: boolean \u00e9s un tipus especial que nom\u00e9s pot tindre dos possibles valors: true o false. Qu\u00e8 s\u00f3n els dos valors l\u00f2gics de l'algebra de George Boole. Variables Al final tot programa s'encarrega de processar informaci\u00f3 i aquesta informaci\u00f3 ha d'estar disponible en algun lloc del nostre codi. Per exemple si volem fer un programa que sume dos n\u00fameros enters, haurem de tindre la informaci\u00f3 o el valor d'aquestos dos n\u00fameros en algun lloc. Una variable \u00e9s com un contenidor que t\u00e9 associat un tipus (int, float, double, char) i cont\u00e9 un valor, si es tracta d'una variable de tipus enter contindr\u00e0 un valor enter, si per contra es tracta d'una variable de tipus caracter contindr\u00e0 una lletra o s\u00edmbol alfanum\u00e8ric. La variable \u00e9s l'unitat b\u00e0sica d'emmagatzemament en Java. Una variable en java es defineix amb la combinaci\u00f3 d'un identificador i el seu tipus de dades 1 2 3 4 5 6 7 8 // Declaraci\u00f3 d'una variable en Java // type identifier; // Per exemple: int a ; // Declaraci\u00f3 d'una variable entera amb nom a float b ; // Variable flotant de nom b char c ; // Variable caracter amb nom c int i = 0 ; // En aquesta declaraci\u00f3 s'inclou tamb\u00e9 la inicialitzaci\u00f3 del seu valor. long j ; Les variables com a contenidors d'informaci\u00f3, poden variar el seu valor durant l'execuci\u00f3 del programa. Imaginem una aplicaci\u00f3 en la que volem controlar la posici\u00f3 d'un element qualsevol, per exemple un cercle a una pantalla 2D. Per determinar la poisci\u00f3 de qualsevol element en un escenari 2D necessitem dues coordenades: x i y. Les variables que podriem utiltizar serien dos variables de tipus enter on al seu nom s'indique clarament el que intenten representar. 1 2 int posX ; // Variables que representa la posici\u00f3 X de l'element. int posY ; // Variable que representa la posici\u00f3 Y de l'element. Declaraci\u00f3 i inicialitzaci\u00f3 Cal diferenciar entre la declaraci\u00f3 d'una variable, quan li donen nom, i la inicialitzaci\u00f3 d'aquesta mateixa, quan li donem valor. A l'exemple anterior haur\u00edem declarat les variables de tipus enter posX i posY per\u00f2 no els hauriem donat cap valor incial. Si per declarar una variable \u00e9s necessari l'\u00fas d'un identificador que ens servir\u00e0 d'etiqueta per poder accedir a dita variable, per tal d'assingar-li un valor hem de fer \u00fas d'un literal . Un literal \u00e9s un valor que poden assignar a les variables. Depenent del tipus de variable, podrem assignar uns valors o uns altres. Literals enters: 12, 2, -3, 12L (long), 0101010 (bin\u00e0ria), 0x1a (hexadecimal). Literals decimals: 12.2, 12.2F, 12.2D (double). Literals car\u00e0cter: 'a', 'b', '$'. Literals cadena: \"Bela\", \"Ciao\". Per defecte Java inicialitzaria aquestes dues variables a zero, \u00e9s a dir, dins la caixa (contenidor) de cada variable, tindriem el valor zero si no s'indica el contrari. 1 2 3 4 5 6 7 8 9 10 11 12 public class Activitat1 { public static void maing ( String [] args ) { int posX ; int poxY ; System . out . println ( \"PosX: \" + posX ); // PosX: 0 System . out . println ( \"PosY: \" + posY ); // PosY: 0 posX = 7 ; posY = 3 ; System . out . println ( \"PosX: \" + posX ); // PosX: 7 System . out . println ( \"PosY: \" + posY ); // PosY: 3 } } Activitat 1 Declara variables de tots els tipus disponibles en Java i digues-me quins s\u00f3n els valors que s'assignen per defecte a cadascuna d'elles. \u00c9s tan simple com declarar variables de tots els tipus buides (sense inicialitzar) i despr\u00e9s mostrar-les per pantalla. Aquesta activitat la pots fer tant en Eclipse com en Processing IDE. Quina difer\u00e8ncia hi ha entre el que passa en Eclipse i el que passa en Processing IDE? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Codi per a Processing IDE int iPosX ; int iPosY ; boolean bPrinted ; void setup () { bPrinted = false ; } void draw () { if ( ! bPrinted ) { println ( \"PosX: \" + iPosX ); // PosX: 0 println ( \"PosY: \" + iPosY ); // PosY: 0 iPosX = 7 ; iPosY = 3 ; println ( \"PosX: \" + iPosX ); // PosX: 7 println ( \"PosY: \" + iPosY ); // PosY: 3 bPrinted = true ; } } Codi mostrat a l'executar-se el programa en Eclipse IDE. Constants Les constants en java s\u00f3n semblants a les variables, \u00e9s a dir, s\u00f3n contenidors d'informaci\u00f3, tenen un identificador i un tipus b\u00e0sic associat per\u00f2 el seu valor no canvia durant l'execuci\u00f3 del programa. L'\u00fas de les constants sol ser per a definir valors immutables dins d'un programa com per exemple en un tauler d'escacs el n\u00famero de files i columnes \u00e9s 8 sempre. Les variables en java es defineixen de la seg\u00fcent forma: 1 2 // Constant en java static final int totalFiles = 8 ; // totalFiles valdr\u00e0 8 durant tot el programa. Activitat 2 Declara una constant de tipus enter amb valor 10 i l\u00ednies despr\u00e9s intenta canviar el valor i compila a veure que passa. Comentaris Els comentaris a qualsevol llenguatge de programaci\u00f3, s'utilitzen per fer que el codi siga m\u00e9s f\u00e0cil de llegir millorant aix\u00ed el manteniment. Els comentaris s\u00f3n totalment ignorats pel compilador. En java tenim tres tipus de comentaris: Comentaris en l\u00ednia: S'utilitzen per comentar parts concretes del codi. 1 // Comentari d'una sola l\u00ednia en Java Comentaris de v\u00e0ries l\u00ednies: Si un programador vol descriure m\u00e9s detalladament un codi m\u00e9s complex i no es pot utilitzar el comentari d'una l\u00ednia perqu\u00e8 requereix m\u00e9s text 1 2 3 4 5 /* Comentari de m\u00e9s d'una l\u00ednia linia 1 linia 2 linia 3 linia final */ Comentaris de documentaci\u00f3: Aquest tipus de comentaris ajuda a l'hora de generar documentaci\u00f3 de forma automatitzada per alguns dels IDEs que s'utilitzen a l'actualitat o les enies que porten amb ells. Un exemple d'eina de generar documentaci\u00f3 de refer\u00e8ncia \u00e9s javadoc 1 2 3 4 5 6 7 8 9 10 /** * Troba la mitjana de tres n\u00fameros! * El programa FindAvg implementa una aplicacio que * simplement calcula la mitjana de tres enteros i els mostra * a la eixida per pantalla. * * @author Aleix Caminou * @version 1.0 * @since 2020-2-2 */ Operadors i expressions Les expressions s\u00f3n equacions matem\u00e0tiques que solen representar c\u00e0lculs, per exemple: 3 x + 7 z. L'expressi\u00f3 anterior la formen els seg\u00fcents elements: dos literals enters: 3 i 7; dos identificadors de variables (no sabem el tipus) x i z; i els simbols * i +. Aquestos simbols s\u00f3n els operadors, concretament * \u00e9s l'operador aritm\u00e8tic de multiplicaci\u00f3 i el s\u00edmbol + representa l'operador de suma. Aquesta expressi\u00f3 tindr\u00e0 finalment un valor, per exemple, s\u00ed x val 3 i z val 2, el resultat de l'expressi\u00f3 seria 23. Operador assignaci\u00f3 L'operador assignaci\u00f3 en Java \u00e9s el s\u00edmbol '=' i s'utilitza de la seg\u00fcent forma 1 2 3 4 // variable = expressi\u00f3 // Seguint l'exemple anterior int x = 3 , y , z = 2 ; y = 3 * x + 7 * z ; On l'operador '=' assignaria el valor de l'expressi\u00f3 '3x+2z' a la variable y, \u00e9s a dir, executada aquesta acci\u00f3 dins de la variable y haur\u00edem depositat el valor 23. Altres exemples d'\u00fas de l'operador assignaci\u00f3: 1 2 3 4 5 6 7 8 9 10 11 int a , b , c ; a = b = c = 10 ; // Tant a com b com c tindr\u00eden valor 10 int i = 3 ; i = i * 3 ; // i valdria 9 int j = 2 ; j *= 2 ; // Aquesta manera peculiar d'usar l'operador assignaci\u00f3 \u00e9s el mateix que j = j * 2; Activitat 3 Escriu i executa el seg\u00fcent codi i digues que \u00e9s el que mostra. El codi est\u00e0 escrit per a Eclipse, per\u00f2 si vols, ho pots fer tamb\u00e9 amb Processing IDE. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // Codi per a Eclipse public class operadors { public static void main ( String [] args ) { int a = 20 , b = 10 , c , d , e = 10 , f = 4 , g = 9 ; c = b ; System . out . println ( \"Valor de c = \" + c ); a = a + 1 ; b = b - 1 ; e = e * 2 ; f = f / 2 ; System . out . println ( \"a,b,e,f = \" + a + \",\" + b + \",\" + e + \",\" + f ); a = a - 1 ; b = b + 1 ; e = e / 2 ; f = f * 2 ; a += 1 ; b -= 1 ; e *= 2 ; f /= 2 ; System . out . println ( \"a,b,e,f (utilitzan operador curst)= \" + a + \",\" + b + \",\" + e + \",\" + f ); } } El codi per a processing \u00e9s molt semblant, quines difer\u00e8ncies hi veus? // Codi per a Processing IDE void setup () { int a = 20 , b = 10 , c , d , e = 10 , f = 4 , g = 9 ; c = b ; System . out . println ( \"Valor de c = \" + c ); a = a + 1 ; b = b - 1 ; e = e * 2 ; f = f / 2 ; System . out . println ( \"a,b,e,f = \" + a + \",\" + b + \",\" + e + \",\" + f ); a = a - 1 ; b = b + 1 ; e = e / 2 ; f = f * 2 ; a += 1 ; b -= 1 ; e *= 2 ; f /= 2 ; System . out . println ( \"a,b,e,f (utilitzan operador curst)= \" + a + \",\" + b + \",\" + e + \",\" + f ); } Operadors aritm\u00e8tics Els operador aritm\u00e8tics en Java serveixen per realitzar operacions b\u00e0siques algebraiques com: la suma, resta, multiplicaci\u00f3 o divisi\u00f3. Suma: s\u00edmbol (+). Exemple: 4+5 Resta: s\u00edmbol (-). Exemple: 5-2 Multiplicaci\u00f3: s\u00edmbol ( ). Exemple: 3 7 Divisi\u00f3 (Quocient): s\u00edmbol (/). Exemple: 8/5. Divisi\u00f3 (Residu): s\u00edmbol (%). Exemple 10%2. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // OPERADORS ARITM\u00c8TICS public class operadors { public static void main ( String [] args ) { int a = 20 , b = 10 , c = 0 , d = 20 , e = 40 , f = 30 ; String x = \"Thank\" , y = \"You\" ; System . out . println ( \"a + b = \" + ( a + b )); System . out . println ( \"a - b = \" + ( a - b )); System . out . println ( \"x + y = \" + x + y ); System . out . println ( \"a * b = \" + ( a * b )); System . out . println ( \"a / b = \" + ( a / b )); System . out . println ( \"a % b = \" + ( a % b )); } } Activitat 4 C\u00f2pia i compila el codi anterior i observa el que mostra pel terminal. Pots executar el codi tant en Eclipse com en Processing IDE. Operadors increment i decrement (unaris) En programaci\u00f3 i com her\u00e8ncia de C i C++ existeixen els operadors increment (++) i decrement (--) que el que fan \u00e9s incrementar o decrementar en una unitat la variable a la qual s'apliquen. 1 2 3 4 int x = 10 ; // Postincrement o postdecrement x ++ ; // Aquest codi seria equivalent a x = x + 1; x -- ; // Aquest codi seria equivalent a x = x -1 ; Aquestos operadors tamb\u00e9 es poden posar abans de la variable produint el mateix efecte 1 2 3 4 int x = 10 ; // Preincrement o predecrement ++ x ; // Aquest codi seria equivalent a x = x + 1; -- x ; // Aquest codi seria equivalent a x = x -1 ; La difer\u00e8ncia essencial entre el postincrement i el preincrement \u00e9s que el contingut de la variable, el que tenim dins la caixeta, s'avalua abans (postincrement) o despr\u00e9s (preincrement) de sumar-li un al seu valor. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class operadors { public static void main ( String [] args ) { int a = 20 , b = 10 , c = 0 , d = 20 , e = 40 , f = 30 ; boolean condition = true ; c = ++ a ; System . out . println ( \"Valor de c (++a) = \" + c ); c = b ++ ; System . out . println ( \"Valor de c (b++) = \" + c ); c = -- d ; System . out . println ( \"Valor de c (--d) = \" + c ); c = e -- ; System . out . println ( \"Valor de c (e--) = \" + c ); System . out . println ( \"Valor de !condition = \" + ! condition ); } } Activitat 5 Prova el codi anterior i digues-me el que passa. Operadors relacionals Com hem explicat en l'apartat sobre Tipus de dades , existeix en Java el tipus boolean que nom\u00e9s pot tenir valors true o false. Aquest tipus de dades est\u00e0 relacionat amb els operadors relacionals, ja que tota expressi\u00f3 relacional ha de donar com a resultat b\u00e9 true o false. Tant els operadors relacionals com els tipus de dades boolean, estan directament relacionats amb l'algebra de boole . A continuaci\u00f3 hi pots veure un resum de les operacions b\u00e0siques en l'algebra de boole: Negaci\u00f3 A NOT 0 1 1 0 OR A B OR 0 0 0 1 0 1 0 1 1 1 1 1 AND A B AND 0 0 0 1 0 0 0 1 0 1 1 1 Els operadors relacionals a Java s\u00f3n: Igual que: == o igual a. Exemple d'\u00fas: a == b, compara si a i b s\u00f3n iguals o no. Distint de: != o distint de. Exemple d'\u00fas: a != b, comprova si a i b s\u00f3n distints. Major que: > o major que. Exemple d'\u00fas: 'a>b' comprova si a \u00e9s major que b. Menor que: < o menor que. Exemple d'\u00fas: 'a<b' comprova si a \u00e9s menor que b. Major o igual que: >= o major igual que. Exemple d'\u00fas: 'a>=b' comprova si a \u00e9s major o igual que b. Menor o igual que: <= o menor igual que. Exemple d'\u00fas: 'a<=b' comprova si a \u00e9s menor o igual que b. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // Programa Java per mostrar operadors relacionals public class operadors { public static void main ( String [] args ) { int a = 20 , b = 10 ; String x = \"Thank\" , y = \"Thank\" ; int ar [] = { 1 , 2 , 3 }; int br [] = { 1 , 2 , 3 }; boolean condicion = true ; // Diversos operadors relacionals System . out . println ( \"a == b :\" + ( a == b )); System . out . println ( \"a < b :\" + ( a < b )); System . out . println ( \"a <= b :\" + ( a <= b )); System . out . println ( \"a > b :\" + ( a > b )); System . out . println ( \"a >= b :\" + ( a >= b )); System . out . println ( \"a != b :\" + ( a != b )); // Els arrays no es poden comparar cma operadors relacionals perqu\u00e8 els objectes emmagatzemen refer\u00e8ncies i no el valor System . out . println ( \"x == y : \" + ( ar == br )); System . out . println ( \"condicion==true :\" + ( condicion == true )); } } Activitat 6 C\u00f2pia i executa el codi anterior en Eclipse i observa el que passa. Operadors l\u00f2gics Aquestos operador s'utilitzen per realitzar operacions l\u00f2giques AND i l\u00f2giques OR , \u00e9s a dir, la funci\u00f3 semblant a la port AND i la porta OR e l'electr\u00f2nica digital. Una cosa a dinre en compte \u00e9s que la segona condici\u00f3 no s'avalua si la primera \u00e9s falsa, \u00e9s a dir, t\u00e9 un efecte de curtcircuit. S'utilitza molt per provar varies condicions per prendre una decici\u00f3. not (!) : negaci\u00f3 l\u00f2gica. and (&&) : and l\u00f2gic. or (||) : or l\u00f2gic. or exclusivo (^) : or exclusiu. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Programa Java per mostrar operadors l\u00f2gics import java.util.Scanner ; public class operadors { public static void main ( String [] args ) { String x = \"java\" ; String y = \"jovo\" ; Scanner s = new Scanner ( System . in ); System . out . print ( \"Usuari:\" ); String uuid = s . next (); System . out . print ( \"Password:\" ); String upwd = s . next (); // Verifica usuari i contrassenya if (( uuid . equals ( x ) && upwd . equals ( y )) || ( uuid . equals ( y ) && upwd . equals ( x ))) { System . out . println ( \"Benvingut\" ); } else { System . out . println ( \"ID o password incorrectes\" ); } } } Activitat 7 Prova i executa el codi anterior. Aquest codi nom\u00e9s es pot executar en Eclipse i no en Processing ja que en aquest \u00faltim no es pot llegir per consola. Operador condicional o ternari Java inclou un operador especial de tipus ternari que de vegades s'utilitza per substituir algunes estructures if then else. Aquest \u00e9s l'operador ? i la seua forma general \u00e9s: 1 expressio1 ? expressio2 : expressio 3 ; Expressi\u00f3 1: \u00e9s l'expressi\u00f3 que avalua un valor boole\u00e0, d'aquesta forma, si l'expressi\u00f3 1 s'avalua com a true, s'executaria l'expressi\u00f3 2 mentre que si l'expressi\u00f3 1 s'avalua a false, s'executaria l'expressi\u00f3 2. Exemple 1 2 3 4 5 double temperatura ; // Variable que ens indica la temperatur ambient boolean AC_ON = false ; // Variable booleana que ens indica si l'aire condicionat est\u00e0 en marxa temperatura > 25 ? AC_ON = true : AC_ON = false ; // B\u00e0sicament el que faria aquesta espressi\u00f3 seria engegar l'aire condicionat si la temperatura // \u00e9s superior a 25 graus. Activitat 9 Copia i executa aquest codi tant en Eclipse com en Processing IDE i observa el que passa. // Programa Java per il\u00b7lustrar el m\u00e0xim de tres nombres usant operador ternari. public class operators { public static void main ( String [] args ) { int a = 20 , b = 10 , c = 30 , result ; // El resultat obt\u00e9 el m\u00e0xim de tres n\u00fameros. result = (( a > b ) ? ( a > c ) ? a : c : ( b > c ) ? b : c ); System . out . println ( \"M\u00e0ximo de tres n\u00fameros = \" + result ); } } Estructures Com hem vist al tema 2, el teorema de la programaci\u00f3 estructurada preveu una s\u00e8rie d'estrucutures b\u00e0siques amb les quals es podr\u00eden codificar tots els algorismes sense necessitat d'usar cap sent\u00e8ncia GOTO o similar. En els pr\u00f2xims punts veurem com es codifiquen totes aquestes estructures en llenguatge Java. Estructura d'un programa en Java El primer que s'ha de tenir en compte \u00e9s que tot programa escrit en Java ha de tindre almenys un main() a la classe principal per tal que s'execute. En resum, programa escrit en Java ha de tindre: Declaracions d'importaci\u00f3 de paquets o inclusi\u00f3 d'altres llibreries. Declaracions de les classes que el formen. El m\u00e8tode main M\u00e8todes definits pels usuaris dins de les classes. Comentaris. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // Programa principal import java.io.* ; // Llibreries amb funcions d'entrada i eixida. public class nomPrograma { // Nom de la classe principal Calculadora calc ; // Membres de la classe (una calculadora) public static void main ( String [] args ) { // M\u00e8tode principal main calc = new Calculadora (); // Instruccions del m\u00e8tode principal. int result = calc . suma ( 10 , 20 ) System . out . println ( \"Resultat: \" + result ); } } // Una altra classe import java.io.* ; public class Calculadora { // Nom de la classe public int suma ( int a , int b ) { // M\u00e8tode de la classe return a + b ; } } Al programa anterior podem trobar una classe 'nomPrograma' que cont\u00e9 el m\u00e8tode principal main i que al mateix temps cont\u00e9 el conjunt d'instruccions que es van a executar seq\u00fcencialment al nostre programa. Aquesta classe nomPrograma t\u00e9 un memebre calc que \u00e9s un objecte (ja veurem classes i objectes m\u00e9s endavant) de tipus calculadora i que est\u00e0 definit m\u00e9s endavant amb la classe p\u00fablica calculadora. Les sent\u00e8ncies que executa el nostre programa d'exmemple s\u00f3n les seg\u00fcents: - Instancia l'objecte calc (calc = new Calculadora()). - Declara una variable de tipus enter result - Crida al m\u00e8tode suma de l'objecte calc passant-li els par\u00e0metres 10 i 20 - Deposita el resultat que retorna el m\u00e8tode suma de la classe calc a la variable result - Mostra per pantalla el resultat de la suma. Estructura en Processing IDE Per tal de treballar amb les estructures b\u00e0siques del paradigma de programaci\u00f3 estructurada, utilitzarem Processing IDE que \u00e9s un IDE lleuger que ens permet programar en Java sense necessitat de fer estructures de classes molt complexes. Concretament Processing IDE \u00e9s un entorn integrat de desenvolupament juntament amb una llibreria gr\u00e0fica que inicialment es va construir per a arts electr\u00f2niques i disseny visual per tal de poder ensenyar els fonaments de la programaci\u00f3 a no-programadors en un context visual. \u00c9s per aix\u00f2 que aquesta eina ens resultar\u00e0 molt \u00fatil per tal d'aprendre els conceptes b\u00e0sics de la programaci\u00f3 estructurada. A continuaci\u00f3 vos mostrem un exemple d'estructura de programa en Processing IDE 1 2 3 4 5 6 7 8 9 10 11 // Refer\u00e8ncies a altres llibrerires. // Variables globals a l'aplicaci\u00f3. void setup () { // Nom\u00e9s s'executa una vegada a l'inici de l'execuci\u00f3. // Sent\u00e8ncies d'inicialitzaci\u00f3 de la nostra aplicaci\u00f3. } void draw () { // S'executa 60 vegades per segon (60Hz freq\u00fcencia del monitor) // Codi principal del programa. } // Declaraci\u00f3 d'altres funcions Estructura Seq\u00fcencial L'estructura seq\u00fcencial en Java es codifica de la seg\u00fcent manera: 1 2 3 4 5 6 7 // Exemple de bloc - estructura seq\u00fcencial { Instrucci\u00f31 ; Instrucci\u00f32 ; ... Instrucci\u00f3N ; } Veiem a continuaci\u00f3 un exemple codificat en Java amb l'IDE de Processing. Activitat 10 Dibuixa amb processing IDE un punt, una l\u00ednia, un cercle i un quadrat copiant el codi que pots veure a continuaci\u00f3. Despr\u00e9s modifica alguns dels par\u00e0metres de les funcions point, line, ellipse i square i observa el que passa. 1 2 3 4 5 6 7 8 9 10 11 12 void setup () { size ( 320 , 320 ); // Estableix les dimensions de la nostra pantalla principal background ( 255 ); // Estableix el fons de la pantalla fill ( 0 ); // Color amb el que es dibuixaran les figures. } void draw () { point ( 10 , 10 ); // Dibuixa un punt line ( 20 , 20 , 40 , 40 ); // Dibuixa una l\u00ednia ellipse ( 100 , 100 , 80 , 80 ); // Dibuixa una el\u00b7lipse square ( 200 , 200 , 50 ); // Dibuixa un quadrat } Estructures de selecci\u00f3 Com varem explicar al tema anterior, ens podem trobar les seg\u00fcents variants d'estructura de selecci\u00f3: Selecci\u00f3 simple Selecci\u00f3 doble Selecci\u00f3 multiple Operador condicional ? Selecci\u00f3 Simple El seu codi en Java seria: 1 2 3 4 5 6 7 8 9 10 if ( condicio ) instruccio ; // O tamb\u00e9 if ( condicio ) { instruccio1 ; instruccio2 ; ... instruccioN ; } En el primer cas si quan s'avalua la condici\u00f3 aquesta \u00e9s veritat, s'executaria la instrucci\u00f3 si pel contrari la condici\u00f3 \u00e9s falsa, no es fa res. Al segon cas \u00e9s igual que el primer per\u00f2 en cas d'avaluar-se possitivament la condici\u00f3 no s'executaria una sola instrucci\u00f3 si no que s'executaria (seq\u00fcencialment) el bloc d'instruccions seg\u00fcent: instrucci\u00f31, instrucci\u00f32 fins instrucci\u00f3N. Exemple en Java: 1 2 3 4 5 6 7 8 9 10 11 12 13 import java.util.* ; public class condicioSimple { public static void main ( String [] args ) { Scanner sc = new Scanner ( System . in ); System . out . println ( \"Quina hora \u00e9s?:\" ); int hora = sc . nextInt (); if ( hora >= 9 ) System . out . println ( \"A sopar\" ); System . out . println ( \"Adeu\" ); } } Activitat 11 Escriu el codi anterior amb Eclipse i observa que passa Com que en Processing IDE resulta molt complicat el llegir per consola, per la inserci\u00f3 d'informaci\u00f3 per part de l'usuari, ho farem de forma aleat\u00f2ria. A l'API de Processing, Processing Reference , entre altres tenim una funci\u00f3 random(low, high) que genera nombres aleatoris dintre del rang low-hight que se li passa per par\u00e0metre, \u00e9s a dir, si volem que aquesta funci\u00f3 ens torne un valor aleatori entre 0 i 100, haur\u00edem de cridar-la de la seg\u00fcent forma: double num = random ( 0 , 100 ); Activitat 12 Utilitzant la funci\u00f3 random() vista a l'apartat anterior, escriu un programa en Processing que donat un nombre alelatori ens indique si aquest \u00e9s parell o senar. Un possible resultat seria el seg\u00fcent: A l'activitat anterior he generat 5 vegades un n\u00famero aleatori i he comprovat si era parell o senar mostrant la informaci\u00f3 pel terminal (ha d'estar tot el codi a la funci\u00f3 setup() ). Tamb\u00e9 podr\u00edem fer que ho mostrara a la funci\u00f3 draw a la pantalla principal de l'aplicaci\u00f3 utilitzant la funci\u00f3 text() de l'IDE de Processing. El resultat podria ser el seg\u00fcent: if .. else El codi en Java seria 1 2 3 4 5 6 7 8 9 10 11 12 instruccio1 ; instruccio2 ; if ( condicio ) { instruccio3 ; instruccio4 ; } else { instruccio5 ; instruccio6 ; } instruccio7 ; instruccio8 ; Si ens fixem en el codi anterior, podem trobar dues seq\u00fc\u00e8ncies d'execucio d'instruccions depenenet si la condici\u00f3 del 'if' s'avalua 'true' o 'false'. En el primer cas, amb la condici\u00f3 a true, s'executarien: instrucci\u00f31, instrucci\u00f32, instrucci\u00f33, instrucci\u00f34, instrucci\u00f37 i instrucci\u00f38. Mentre que si la condici\u00f3 del 'if' s'avaluara a 'false', les instruccions a executar serien: instrucci\u00f31, instrucci\u00f32, instrucci\u00f35, instrucci\u00f36, instrucci\u00f37 i instrucci\u00f38. Exemple en Java: 1 2 3 4 5 6 7 8 9 10 11 12 import java.util.* ; public class condicioDoble { public static void main ( String [] args ) { Scanner sc = new Scanner ( System . in ); System . out . println ( \"Quina hora \u00e9s?:\" ); int hora = sc . nextInt (); if ( hora >= 12 ) System . out . println ( \"Encara \u00e9s de mat\u00ed\" ); else System . out . println ( \"Ja \u00e9s de vesprada\" ); } } Activitat 13 Amplia l'exemple anterior per tal que ens indique, en cas de no ser parell, que \u00e9s senar. Com que s'ha de llegir per consola, \u00e9s millor que ho fages amb Eclipse. if else if else El mateix exemple en Java que teniu a la imatge anterior seria: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 instruccio1 ; if ( condicio1 ) { instruccio2 ; instruccio3 ; } else if ( condicio2 ) { instruccio4 ; } else if ( condicio3 ) { instruccio5 ; instruccio6 ; instruccio7 ; } else { instruccio8 ; instruccio9 ; } instruccio10 ; Al codi anterior l'\u00fanic que s\u00ed sabem cert \u00e9s que s'executaran les instruccions 1 i 2 i depenent de quina condici\u00f3 s'avalua a true s'executar\u00e0 algun bloc d'instruccions que estan dins de l'estructura condicional. Exemple Seguint amb l'exemple de l'hora que hem utilitzat als apartats anteriors veiem com es podria usar una condici\u00f3 m\u00faltiple amb if else 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import java.util.* ; public class condicioMultiple { public static void main ( String [] args ) { Scanner sc = new Scanner ( System . in ); System . out . println ( \"Quina hora \u00e9s?:\" ); int hora = sc . nextInt (); if ( hora >= 7 && hora <= 9 ) System . out . println ( \"Eres matiner\" ); else if ( hora > 9 && hora <= 12 ) System . out . println ( \"Deuries haver esmorzat ja\" ); else if ( hora > 12 && hora <= 15 ) System . out . println ( \"Es hora de dinar si no has dinat\" ); else if ( hora > 15 && hora <= 18 ) System . out . println ( \"Si no has fet una migdiada oblidat\" ); else System . out . println ( \"Hora de la cervesa\" ); } } Activitat 14 Passa el codi anterior a Processing IDE. Com que no es pot llegir per consola, fes que l'hora i els minuts es generen de forma aleat\u00f2ria amb la funci\u00f3 random . Al final de cada cicle de la funci\u00f3 draw posa un delay de 1 segon per tal que ens done temps a veure el resultat. Recorda tamb\u00e9 de fer un clear() al principi de cada cicle de draw. El resultat podria ser el seg\u00fcent: Activitat 15. Divisio Escriu un programa en Processing IDE que genere aleat\u00f2riament dos nombres enters i que calcule la seua divisi\u00f3. El programa ens haur\u00e0 d'indicar si la divisi\u00f3 \u00e9s exacta qui \u00e9s el resultat i si no \u00e9s exacta quin \u00e9s el resultat i el residu. // Estructura del codi que pots utilitzar. void setup () { size ( 500 , 500 ); // Ens determina el tamany de la pantalla de la nostra aplicaci\u00f3. textAlign ( CENTER ); // L'ancora del text ser\u00e0 el cetnre mateix. } void draw () { clear (); // Cada vegada que s'executa el draw (29 fps) s'esborra la pantalla. background ( 255 ); // Pinta el fons de blanc fill ( 0 ); // per tal que el text siga negre // Afig el codi ac\u00ed // Per escriure a la pantalla usa la funci\u00f3 text(String, int, int); delay ( 1000 ); // Retr\u00e0s per tal que done temps a llegir el que escriu. } Com a apartat d'ampliaci\u00f3, podries fer que el tamany de la font fos un poc m\u00e9s gran. Activitat 16. Divisi\u00f3 per zero. Si s'ha dona el cas, haur\u00e0s pogut comprovar que si el divisor \u00e9s 0 el programa dona error. Millora el programa anterior controlant el que passa quan es vol dividir per zero, mostrant un missatge en el cas que el n\u00famero pel qual s'intenta dividir siga zero. Possible soluci\u00f3 Activitat 17. Major, menor o igual Ecriu un programa en Processing que genere aleat\u00f2riament dos n\u00fameros i que diga quin \u00e9s el major, quin \u00e9s el menor o si s\u00f3n iguals. Activitat 18. Difer\u00e8ncia d'anys Escriu un programa en Processing que donat l'any actual i un any qualsevol que es genere de forma aleat\u00f2ria amb la funci\u00f3 random i escriga quants anys han passat des d'eixe any o quants anys falten per arribar a eixe any. Activitat 19. Millora Millora el programa anterior fent que quan la difer\u00e8ncia siga exactament un any, mostre una frase concreta: \"Nom\u00e9s queda un any\" Activitat 20. M\u00faltiples Escriu un programa que genere dos n\u00fameros aleatoris entre el 0 i el 100 i escriga si el n\u00famero major \u00e9s multiple del menor. Activitat 21. Millor m\u00faltiples Millora el programa anterior fent que el programa avise quan s'escriguen valors negatius o nuls. Activitat 22. Comparador Escriu un programa que donats 3 n\u00fameros (creats aleat\u00f2riament) ens diga si s\u00f3n els tres iguals, dos s\u00f3n iguals o cap \u00e9s igual. Activitat 23. Any bixest Escriu un programa que genere un any aleatori de 0 a 2021 i ens diga si aquest \u00e9s bixest o no. Cal recordar que els anys bixests s\u00f3n m\u00faltiples de 4, per\u00f2 no s\u00f3n m\u00faltiples de 100 i s\u00ed s\u00f3n m\u00faltiples de 400. Per exemple: 2012 \u00e9s bixest, 2010 no ho \u00e9s, 2000 s\u00ed que ho es per\u00f2 1900 no ho \u00e9s. Pots basar-te en el seg\u00fcent codi. Activitat 24. C\u00e0lcul d'arees Escriu un programa que primer demane si es vol calcular l'area d'un cercle (escrivint c o C) o d'un triangle (t o T). Si es tria el triangle s'haur\u00e0 de demanar la base i l'altura mentre que si es tria el cercle s'haur\u00e0 de demanar el radi. Aquest programa \u00e9s recomanable que es faja amb Eclipse IDE. Activitat 25. Canvi d'unitats Escriu un programa que demane una dist\u00e0ncia en cent\u00edmetres i que escriga la mateixa dist\u00e0ncia en quilometres, metres i centimetres. switch case La sent\u00e8ncia de control 'switch' \u00e9s una altra forma de codificar la condici\u00f3 m\u00f9ltiple que hem vist a l'apartat anterior per\u00f2 m\u00e9s senzilla de visualitzar a primer cop d'ull 1 2 3 4 5 6 7 8 9 10 11 12 13 switch ( condicio ) { case 1 : // Instruccions break ; case 2 : // INstrucciones 2 break ; default: // Instruccions per defecte break ; } Un altre exemple m\u00e9s clar 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 //Programa que demana un numero i diu quin mes \u00e9s import java.util.* ; public class ExempleSwitch { public static void main ( String [] args ) { int mes ; Scanner sc = new Scanner ( System . in ); System . out . print ( \"Introdueix el numero del mes: \" ); mes = sc . nextInt (); switch ( mes ) { //inicio del switch case 1 : System . out . println ( \"GENER\" ); break ; case 2 : System . out . println ( \"FEBRER\" ); break ; case 3 : System . out . println ( \"MAR\u00c7\" ); break ; case 4 : System . out . println ( \"ABRIL\" ); break ; case 5 : System . out . println ( \"MAIG\" ); break ; case 6 : System . out . println ( \"JUNY\" ); break ; case 7 : System . out . println ( \"JULIOL\" ); break ; case 8 : System . out . println ( \"AGOST\" ); break ; case 9 : System . out . println ( \"SETEMBRE\" ); break ; case 10 : System . out . println ( \"OCTUBRE\" ); break ; case 11 : System . out . println ( \"NOVEMBRE\" ); break ; case 12 : System . out . println ( \"DESEEMBRE\" ); break ; default : System . out . println ( \"No v\u00e0lid\" ); } } } Activitat 26 Escriu el programa anterior per a Processing. Recorda que amb processing l'entrada per consola l'hem de substituir per generaci\u00f3 de valors aleatoris amb random . En l'exemple anterior el que s'ha fet ha sigut generar aleat\u00f2riament un n\u00famero enter entre 0 i 15 i despr\u00e9s mostrar per pantalla: primer el n\u00famero del mes i despr\u00e9s el nom. Activitat 27. Dies de la setmana Escriun un programa que donat un n\u00famero entre 1 i 7 et diga quin dia de la setmana \u00e9s. 1 Dilluns, 2 Dimarts etc.. Activitat 28. if a switch Passa les activitats de l'apartat if..else a sent\u00e8ncies switch..case 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Exemple de switch convertit a if switch ( variable ) { case valor1 : // Accions 1 break ; case valor2 : // Accions 2 break ; case valor3 : // Accions 3 break ; default : // Accions default } // El codi anterior utilitzant if if ( variable == valor1 ) // Accions 1 else if ( variagble == valor2 ) // Accions 2 else if ( variable == valor3 ) // Accions 3 else //Accions default Activitat 29. dies del mes Escriu un programa que ens demane el mes i l'any i ens mostre per pantalla el total de dies que t\u00e9 eixe mes. Si fas el programa amb Processing recorda que el n\u00famero del m\u00e9s l'haur\u00e0s de generar de forma aleat\u00f2ria. Activitat 30. Figures geom\u00e8triques Escriure un programa que demane primer de quina figura geom\u00e8trica es vol calcular el perimetre. Triangle (t), Quadrat (q), Cercle (c) o rectangle (r) i despr\u00e9s mostre el c\u00e0lcul corresponent. Estructures de repetici\u00f3 Imaginem que tenim un vector d'enters de 100 elements i volem trobar un nombre concret. Usant les estrcutures condicionals ho podr\u00edem fer. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int [] arrayNumeros ; // Declarem un array d'enters arrayNumeros = new int [ 100 ] ; // Reservem espai en mem\u00f2ria per 100 elements inicialitzaNumeros ( arrayNumeros ); // Emplenem de forma aleat\u00f2ria l'array // Comencem la recerca del n\u00famero 10 per exemple if ( array [ 0 ] == 10 ) System . out . println ( \"N\u00famero trobat a la posici\u00f3 0\" ); else if ( array [ 1 ] == 10 ) System . out . println ( \"N\u00famero trobat a la posici\u00f3 1\" ); else if ( array [ 2 ] == 10 ) System . out . println ( \"N\u00famero trobat a la posici\u00f3 2\" ); else if ( array [ 3 ] == 10 ) System . out . println ( \"N\u00famero trobat a la posici\u00f3 3\" ); else if ( array [ 4 ] == 10 ) System . out . println ( \"N\u00famero trobat a la posici\u00f3 4\" ); else if ( array [ 5 ] == 10 ) System . out . println ( \"N\u00famero trobat a la posici\u00f3 5\" ); // I aix\u00ed fins 100 ... Com podeu observar, nom\u00e9s he necessitat escriure codi per als 5 primers elements del nostre array per adondar-me que aquest codi \u00e9s totalment ineficient i t\u00e9 un manteniment molt complicat. Imagineu un array amb 1000 elements i que ho hagurem de codificar com hem fet abans. Les estructures repetitives permetrien rec\u00f2rrer l'array de principi a final sense necessitat d'escriure tant de codi. Veiem els seg\u00fcents exemples. while En aquest tipus de bucle, el bloc d'instruccions del bucle while, es poden executar zero o m\u00e9s vegades. Els passos que representen el diagrama anterior s\u00f3n: 1. S'executa la instrucci\u00f3 1 2. S'avalua la condici\u00f3 3. Si la condici\u00f3 \u00e9s true, s'executa el bloc d'instruccions del bucle i es torna a avaluar la condici\u00f3. 4. En cas que la condici\u00f3 s'avalue com a false, passar\u00edem a executar la instrucci\u00f3 2. Exemple: Com far\u00edem el codi necessari per rec\u00f2rrer el nostre array de 100 elements fins trobar el n\u00famero que busquem? 1 2 3 4 5 6 int i = 0 ; // Inicialitzem una variable que ens servir\u00e0 de contador. while ( i < 100 ) { if ( arrarNumeros [ i ] == 10 ) System . out . println ( \"N\u00famero trobat a la posici\u00f3 \" + i ); i ++ ; // Important incrementar el contador o entrar\u00edem en un bucle infinit. } do .. while Els passos que representen el diagrama anterior s\u00f3n: 1. S'executa la instrucci\u00f3 1 2. S'executen les instruccions que cont\u00e9 el bloc 3. S'avalua la condici\u00f3 4. Si la condici\u00f3 \u00e9s true, s'executa el bloc d'instruccions del bucle i es torna a avaluar la condici\u00f3. 5. En cas que la condici\u00f3 s'avalue com a false, passar\u00edem a executar la instrucci\u00f3 2. Exemple: Com far\u00edem el codi necessari per rec\u00f2rrer el nostre array de 100 elements fins trobar el n\u00famero que busquem? 1 2 3 4 5 6 7 int i = 0 ; // Inicialitzem una variable que ens servir\u00e0 de contador. do { if ( arrarNumeros [ i ] == 10 ) System . out . println ( \"N\u00famero trobat a la posici\u00f3 \" + i ); i ++ ; // Important incrementar el contador o entrar\u00edem en un bucle infinit. } while ( i < 100 ); bucle for Executem instrucci\u00f3 1 (aliena al bucle for) Inicialitzaci\u00f3 Avaluaci\u00f3 de la condici\u00f3 Si la condici\u00f3 \u00e9s true Executem les instruccions del bucle for Actualitzem \u00edndex Si la condici\u00f3 es false eixim del bucle i executem instrucci\u00f3 2 1 2 3 4 for ( int i = 0 ; i < 100 ; i ++ ) { if ( arrarNumeros [ i ] == 10 ) System . out . println ( \"N\u00famero trobat a la posici\u00f3 \" + i ); } Al codi anterior: 1. Inicialitzaci\u00f3: int i = 0; 2. Avaluaci\u00f3 de la condici\u00f3: \u00e9s i < 100 ? 3. Actualitzaci\u00f3: i ++ Activitat 31. Dibuixa amb bucles Observa el seg\u00fcent codi i raona'l 1 2 3 4 5 6 7 8 9 10 void setup () { size ( 320 , 240 ); } void draw () { for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) circle ( 10 + j * 20 , 10 + i * 20 , 20 ); } } El resultat d'aquest codi seria: Activitat 32. Dibuixa la piramid i la invertida Fes un programa semblant al de l'activitat anterior per\u00f2 a la inversa, \u00e9s a dir, cinc cercles a la primera l\u00ednia, quatre a la segona, tres a la tercera, dos a la quarta i, finalment, un a la cinquena l\u00ednia. Activitat 33. Dibuixa la diagonal Donada una pantalla de 500 pixels d'ample i 500 d'alt, fes un programa que dibuixe quadrats de 20 per 20 pixels ocupant la diagonal de la pantalla des de la posici\u00f3 (0,0) fins la (500,500). Activitat 34. Dibuixa les dues diagonals Millora el programa anterior i fes que dibuixe les dues diagonals, des del punt (0,0) fins al (500,500) i l'altra que va des del punt (500,0) fins al (0,500). Si a una diagonal li dibuixes quadrats, a l'altra dibuixa-li cercles. Activitat 35. Dues diagonals 640x480 Millora l'activitat anterior i dibuixa les dues diagonals per\u00f2 a una pantalla de 640 pixels per 480 pixels. Activitat 36. whiles i for Fes les activitat anteriors canviant els bulces while per for i a l'inrev\u00e9s.","title":"Tema 3. El llenguatge Java"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#tema-3-el-llenguatge-java","text":"","title":"Tema 3. El llenguatge Java"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#introduccio","text":"Una vegada estudiat el teorema del programa estructurat juntamnet amb els diagrames de flux i psuedocodi, passem a veure aquestos conceptes te\u00f2rics en un llenguatge de programaci\u00f3 d'alt nivell concret com \u00e9s el llenguatge de programaci\u00f3 Java. En aquest tema veurem la sintaxis b\u00e0sica de Java: paraules reservades, dades, variables, constants, identificadors i com tamb\u00e9 es codifiquen les estructures de control vistes al tema anterior en llenguatge Java.","title":"Introducci\u00f3"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#dades-variables-i-identificadors","text":"Una dada per una altra banda \u00e9s: \"la representaci\u00f3 convencional de la informaci\u00f3 en un format adequat perqu\u00e8 puga ser processada, comunicada o interpretada per mitjans manuals o autom\u00e0tics.\" Per un altre costat una variable \u00e9s: \"una expressi\u00f3 matem\u00e0tica, s\u00edmbol que representa una quantitat el valor num\u00e8ric de la qual no s'especifica.\" En qualsevol llenguatge de programaci\u00f3 existeixen una s\u00e8rie d'elements com variables, constants, funcions, llibreries. Aquestos elements requereixen d'un nom per tal de distingir-lo de la resta. Aquestos noms es diuen identificadors Un identificador \u00e9s una cadena alfan\u00famerica que representa o dona un nom a un element dins del nostre programa. Els identificadors de les variables s\u00f3n noms que s'inventa el programador i s'hauria de tindre en consideraci\u00f3 al seg\u00fcent m\u00e0xima: Quan triem el nom per identificar a una variable, ha de ser significatiu, \u00e9s a dir, que el mateix identificador ja done alguna pista de que \u00e9s el que representa. Normes per construir identificadors en Java 1. Estan formats per caracters i/o digits. 2. No poden comen\u00e7ar per digit. 3. No poden usar els seg\u00fcents caracters especials: + - * / = % & # ! ? ^ \u201c \u2018 ~ \\ | < > ( ) [ ] { } : ; . , 4. No poden ser cap paraula reservada de Java 5. Els identificadors de Java distingeixen entre maj\u00fascules i min\u00fascules (case sensitive) 6. No hi ha l\u00edmit a la llarg\u00e0ria de l'identificador, per\u00f2 \u00e9s aconsellable utilitzar una grand\u00e0ria \u00f2ptima entre 4 i 15 caracters.","title":"Dades, Variables i identificadors."},{"location":"Tema%2003.%20El%20llenguatge%20Java/#paraules-reservades","text":"Uns dels principals identificadors que ens trobarem a tot llenguatge de programaci\u00f3 s\u00f3n les paraules reservades . Per entendre-ho, el conjunt de paraules reservades d'un llenguatge de programaci\u00f3 s\u00f3n el diccionari de totes les paraules que t\u00e9 aquest llenguatge. Aquetes paraules reservades no poden utilitzar-se per cap altra cosa m\u00e9s, per exemple, si Java t\u00e9 la paraula reservada public , el programador no podr\u00e0 crear cap variable utilitzant l'identificador public.","title":"Paraules reservades"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#paraules-reservadoes-a-java","text":"abstract continue for new switch assert default goto package sychronized boolean do if private this break double implements protected throw byte else import public thows case enum instanceof return transient catch extends int short try char final interface static void class finally long strictfp volatile const float native super while","title":"Paraules reservadoes a Java"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#tipus-de-dades","text":"Tot llenguatge de programaci\u00f3 porta una s\u00e8rie de tipus de dades predefinits que es poden usar. Aquestos tipus de dades tamb\u00e9 es coneixen com a tipus primitius o tipus simples. . Java defineix 8 tipus diferents de dades: byte, short, int, long, char, float, double i boolean. Aquestos tipus es poden agrupar en quatre blocs: Nombres enters: on podem trobar el byte, short, long i int. Aquestos tipus admeten valors no fraccionables en parts m\u00e9s xicotetes que la unitat. Per exemple: 1, 3, 5, 15, 20, 132... Punt flotant: aquest grup inclou el float i el double on es representen els nombres decimals, \u00e9s a dir, aquells que s\u00ed admeten fraccions. Per exemple: 1.3, 5.802039, etc.. Caracters: char representa a tot el conjunt de caracters del nostre sistema alfab\u00e8tic inclosos els s\u00edmbols. Per exmple: a, b, c, $, ?... Boole\u00e0: boolean \u00e9s un tipus especial que nom\u00e9s pot tindre dos possibles valors: true o false. Qu\u00e8 s\u00f3n els dos valors l\u00f2gics de l'algebra de George Boole.","title":"Tipus de dades"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#variables","text":"Al final tot programa s'encarrega de processar informaci\u00f3 i aquesta informaci\u00f3 ha d'estar disponible en algun lloc del nostre codi. Per exemple si volem fer un programa que sume dos n\u00fameros enters, haurem de tindre la informaci\u00f3 o el valor d'aquestos dos n\u00fameros en algun lloc. Una variable \u00e9s com un contenidor que t\u00e9 associat un tipus (int, float, double, char) i cont\u00e9 un valor, si es tracta d'una variable de tipus enter contindr\u00e0 un valor enter, si per contra es tracta d'una variable de tipus caracter contindr\u00e0 una lletra o s\u00edmbol alfanum\u00e8ric. La variable \u00e9s l'unitat b\u00e0sica d'emmagatzemament en Java. Una variable en java es defineix amb la combinaci\u00f3 d'un identificador i el seu tipus de dades 1 2 3 4 5 6 7 8 // Declaraci\u00f3 d'una variable en Java // type identifier; // Per exemple: int a ; // Declaraci\u00f3 d'una variable entera amb nom a float b ; // Variable flotant de nom b char c ; // Variable caracter amb nom c int i = 0 ; // En aquesta declaraci\u00f3 s'inclou tamb\u00e9 la inicialitzaci\u00f3 del seu valor. long j ; Les variables com a contenidors d'informaci\u00f3, poden variar el seu valor durant l'execuci\u00f3 del programa. Imaginem una aplicaci\u00f3 en la que volem controlar la posici\u00f3 d'un element qualsevol, per exemple un cercle a una pantalla 2D. Per determinar la poisci\u00f3 de qualsevol element en un escenari 2D necessitem dues coordenades: x i y. Les variables que podriem utiltizar serien dos variables de tipus enter on al seu nom s'indique clarament el que intenten representar. 1 2 int posX ; // Variables que representa la posici\u00f3 X de l'element. int posY ; // Variable que representa la posici\u00f3 Y de l'element.","title":"Variables"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#declaracio-i-inicialitzacio","text":"Cal diferenciar entre la declaraci\u00f3 d'una variable, quan li donen nom, i la inicialitzaci\u00f3 d'aquesta mateixa, quan li donem valor. A l'exemple anterior haur\u00edem declarat les variables de tipus enter posX i posY per\u00f2 no els hauriem donat cap valor incial. Si per declarar una variable \u00e9s necessari l'\u00fas d'un identificador que ens servir\u00e0 d'etiqueta per poder accedir a dita variable, per tal d'assingar-li un valor hem de fer \u00fas d'un literal . Un literal \u00e9s un valor que poden assignar a les variables. Depenent del tipus de variable, podrem assignar uns valors o uns altres. Literals enters: 12, 2, -3, 12L (long), 0101010 (bin\u00e0ria), 0x1a (hexadecimal). Literals decimals: 12.2, 12.2F, 12.2D (double). Literals car\u00e0cter: 'a', 'b', '$'. Literals cadena: \"Bela\", \"Ciao\". Per defecte Java inicialitzaria aquestes dues variables a zero, \u00e9s a dir, dins la caixa (contenidor) de cada variable, tindriem el valor zero si no s'indica el contrari. 1 2 3 4 5 6 7 8 9 10 11 12 public class Activitat1 { public static void maing ( String [] args ) { int posX ; int poxY ; System . out . println ( \"PosX: \" + posX ); // PosX: 0 System . out . println ( \"PosY: \" + posY ); // PosY: 0 posX = 7 ; posY = 3 ; System . out . println ( \"PosX: \" + posX ); // PosX: 7 System . out . println ( \"PosY: \" + posY ); // PosY: 3 } } Activitat 1 Declara variables de tots els tipus disponibles en Java i digues-me quins s\u00f3n els valors que s'assignen per defecte a cadascuna d'elles. \u00c9s tan simple com declarar variables de tots els tipus buides (sense inicialitzar) i despr\u00e9s mostrar-les per pantalla. Aquesta activitat la pots fer tant en Eclipse com en Processing IDE. Quina difer\u00e8ncia hi ha entre el que passa en Eclipse i el que passa en Processing IDE? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Codi per a Processing IDE int iPosX ; int iPosY ; boolean bPrinted ; void setup () { bPrinted = false ; } void draw () { if ( ! bPrinted ) { println ( \"PosX: \" + iPosX ); // PosX: 0 println ( \"PosY: \" + iPosY ); // PosY: 0 iPosX = 7 ; iPosY = 3 ; println ( \"PosX: \" + iPosX ); // PosX: 7 println ( \"PosY: \" + iPosY ); // PosY: 3 bPrinted = true ; } } Codi mostrat a l'executar-se el programa en Eclipse IDE.","title":"Declaraci\u00f3 i inicialitzaci\u00f3"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#constants","text":"Les constants en java s\u00f3n semblants a les variables, \u00e9s a dir, s\u00f3n contenidors d'informaci\u00f3, tenen un identificador i un tipus b\u00e0sic associat per\u00f2 el seu valor no canvia durant l'execuci\u00f3 del programa. L'\u00fas de les constants sol ser per a definir valors immutables dins d'un programa com per exemple en un tauler d'escacs el n\u00famero de files i columnes \u00e9s 8 sempre. Les variables en java es defineixen de la seg\u00fcent forma: 1 2 // Constant en java static final int totalFiles = 8 ; // totalFiles valdr\u00e0 8 durant tot el programa. Activitat 2 Declara una constant de tipus enter amb valor 10 i l\u00ednies despr\u00e9s intenta canviar el valor i compila a veure que passa.","title":"Constants"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#comentaris","text":"Els comentaris a qualsevol llenguatge de programaci\u00f3, s'utilitzen per fer que el codi siga m\u00e9s f\u00e0cil de llegir millorant aix\u00ed el manteniment. Els comentaris s\u00f3n totalment ignorats pel compilador. En java tenim tres tipus de comentaris: Comentaris en l\u00ednia: S'utilitzen per comentar parts concretes del codi. 1 // Comentari d'una sola l\u00ednia en Java Comentaris de v\u00e0ries l\u00ednies: Si un programador vol descriure m\u00e9s detalladament un codi m\u00e9s complex i no es pot utilitzar el comentari d'una l\u00ednia perqu\u00e8 requereix m\u00e9s text 1 2 3 4 5 /* Comentari de m\u00e9s d'una l\u00ednia linia 1 linia 2 linia 3 linia final */ Comentaris de documentaci\u00f3: Aquest tipus de comentaris ajuda a l'hora de generar documentaci\u00f3 de forma automatitzada per alguns dels IDEs que s'utilitzen a l'actualitat o les enies que porten amb ells. Un exemple d'eina de generar documentaci\u00f3 de refer\u00e8ncia \u00e9s javadoc 1 2 3 4 5 6 7 8 9 10 /** * Troba la mitjana de tres n\u00fameros! * El programa FindAvg implementa una aplicacio que * simplement calcula la mitjana de tres enteros i els mostra * a la eixida per pantalla. * * @author Aleix Caminou * @version 1.0 * @since 2020-2-2 */","title":"Comentaris"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#operadors-i-expressions","text":"Les expressions s\u00f3n equacions matem\u00e0tiques que solen representar c\u00e0lculs, per exemple: 3 x + 7 z. L'expressi\u00f3 anterior la formen els seg\u00fcents elements: dos literals enters: 3 i 7; dos identificadors de variables (no sabem el tipus) x i z; i els simbols * i +. Aquestos simbols s\u00f3n els operadors, concretament * \u00e9s l'operador aritm\u00e8tic de multiplicaci\u00f3 i el s\u00edmbol + representa l'operador de suma. Aquesta expressi\u00f3 tindr\u00e0 finalment un valor, per exemple, s\u00ed x val 3 i z val 2, el resultat de l'expressi\u00f3 seria 23.","title":"Operadors i expressions"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#operador-assignacio","text":"L'operador assignaci\u00f3 en Java \u00e9s el s\u00edmbol '=' i s'utilitza de la seg\u00fcent forma 1 2 3 4 // variable = expressi\u00f3 // Seguint l'exemple anterior int x = 3 , y , z = 2 ; y = 3 * x + 7 * z ; On l'operador '=' assignaria el valor de l'expressi\u00f3 '3x+2z' a la variable y, \u00e9s a dir, executada aquesta acci\u00f3 dins de la variable y haur\u00edem depositat el valor 23. Altres exemples d'\u00fas de l'operador assignaci\u00f3: 1 2 3 4 5 6 7 8 9 10 11 int a , b , c ; a = b = c = 10 ; // Tant a com b com c tindr\u00eden valor 10 int i = 3 ; i = i * 3 ; // i valdria 9 int j = 2 ; j *= 2 ; // Aquesta manera peculiar d'usar l'operador assignaci\u00f3 \u00e9s el mateix que j = j * 2; Activitat 3 Escriu i executa el seg\u00fcent codi i digues que \u00e9s el que mostra. El codi est\u00e0 escrit per a Eclipse, per\u00f2 si vols, ho pots fer tamb\u00e9 amb Processing IDE. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // Codi per a Eclipse public class operadors { public static void main ( String [] args ) { int a = 20 , b = 10 , c , d , e = 10 , f = 4 , g = 9 ; c = b ; System . out . println ( \"Valor de c = \" + c ); a = a + 1 ; b = b - 1 ; e = e * 2 ; f = f / 2 ; System . out . println ( \"a,b,e,f = \" + a + \",\" + b + \",\" + e + \",\" + f ); a = a - 1 ; b = b + 1 ; e = e / 2 ; f = f * 2 ; a += 1 ; b -= 1 ; e *= 2 ; f /= 2 ; System . out . println ( \"a,b,e,f (utilitzan operador curst)= \" + a + \",\" + b + \",\" + e + \",\" + f ); } } El codi per a processing \u00e9s molt semblant, quines difer\u00e8ncies hi veus? // Codi per a Processing IDE void setup () { int a = 20 , b = 10 , c , d , e = 10 , f = 4 , g = 9 ; c = b ; System . out . println ( \"Valor de c = \" + c ); a = a + 1 ; b = b - 1 ; e = e * 2 ; f = f / 2 ; System . out . println ( \"a,b,e,f = \" + a + \",\" + b + \",\" + e + \",\" + f ); a = a - 1 ; b = b + 1 ; e = e / 2 ; f = f * 2 ; a += 1 ; b -= 1 ; e *= 2 ; f /= 2 ; System . out . println ( \"a,b,e,f (utilitzan operador curst)= \" + a + \",\" + b + \",\" + e + \",\" + f ); }","title":"Operador assignaci\u00f3"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#operadors-aritmetics","text":"Els operador aritm\u00e8tics en Java serveixen per realitzar operacions b\u00e0siques algebraiques com: la suma, resta, multiplicaci\u00f3 o divisi\u00f3. Suma: s\u00edmbol (+). Exemple: 4+5 Resta: s\u00edmbol (-). Exemple: 5-2 Multiplicaci\u00f3: s\u00edmbol ( ). Exemple: 3 7 Divisi\u00f3 (Quocient): s\u00edmbol (/). Exemple: 8/5. Divisi\u00f3 (Residu): s\u00edmbol (%). Exemple 10%2. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // OPERADORS ARITM\u00c8TICS public class operadors { public static void main ( String [] args ) { int a = 20 , b = 10 , c = 0 , d = 20 , e = 40 , f = 30 ; String x = \"Thank\" , y = \"You\" ; System . out . println ( \"a + b = \" + ( a + b )); System . out . println ( \"a - b = \" + ( a - b )); System . out . println ( \"x + y = \" + x + y ); System . out . println ( \"a * b = \" + ( a * b )); System . out . println ( \"a / b = \" + ( a / b )); System . out . println ( \"a % b = \" + ( a % b )); } } Activitat 4 C\u00f2pia i compila el codi anterior i observa el que mostra pel terminal. Pots executar el codi tant en Eclipse com en Processing IDE.","title":"Operadors aritm\u00e8tics"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#operadors-increment-i-decrement-unaris","text":"En programaci\u00f3 i com her\u00e8ncia de C i C++ existeixen els operadors increment (++) i decrement (--) que el que fan \u00e9s incrementar o decrementar en una unitat la variable a la qual s'apliquen. 1 2 3 4 int x = 10 ; // Postincrement o postdecrement x ++ ; // Aquest codi seria equivalent a x = x + 1; x -- ; // Aquest codi seria equivalent a x = x -1 ; Aquestos operadors tamb\u00e9 es poden posar abans de la variable produint el mateix efecte 1 2 3 4 int x = 10 ; // Preincrement o predecrement ++ x ; // Aquest codi seria equivalent a x = x + 1; -- x ; // Aquest codi seria equivalent a x = x -1 ; La difer\u00e8ncia essencial entre el postincrement i el preincrement \u00e9s que el contingut de la variable, el que tenim dins la caixeta, s'avalua abans (postincrement) o despr\u00e9s (preincrement) de sumar-li un al seu valor. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class operadors { public static void main ( String [] args ) { int a = 20 , b = 10 , c = 0 , d = 20 , e = 40 , f = 30 ; boolean condition = true ; c = ++ a ; System . out . println ( \"Valor de c (++a) = \" + c ); c = b ++ ; System . out . println ( \"Valor de c (b++) = \" + c ); c = -- d ; System . out . println ( \"Valor de c (--d) = \" + c ); c = e -- ; System . out . println ( \"Valor de c (e--) = \" + c ); System . out . println ( \"Valor de !condition = \" + ! condition ); } } Activitat 5 Prova el codi anterior i digues-me el que passa.","title":"Operadors increment i decrement (unaris)"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#operadors-relacionals","text":"Com hem explicat en l'apartat sobre Tipus de dades , existeix en Java el tipus boolean que nom\u00e9s pot tenir valors true o false. Aquest tipus de dades est\u00e0 relacionat amb els operadors relacionals, ja que tota expressi\u00f3 relacional ha de donar com a resultat b\u00e9 true o false. Tant els operadors relacionals com els tipus de dades boolean, estan directament relacionats amb l'algebra de boole . A continuaci\u00f3 hi pots veure un resum de les operacions b\u00e0siques en l'algebra de boole: Negaci\u00f3 A NOT 0 1 1 0 OR A B OR 0 0 0 1 0 1 0 1 1 1 1 1 AND A B AND 0 0 0 1 0 0 0 1 0 1 1 1 Els operadors relacionals a Java s\u00f3n: Igual que: == o igual a. Exemple d'\u00fas: a == b, compara si a i b s\u00f3n iguals o no. Distint de: != o distint de. Exemple d'\u00fas: a != b, comprova si a i b s\u00f3n distints. Major que: > o major que. Exemple d'\u00fas: 'a>b' comprova si a \u00e9s major que b. Menor que: < o menor que. Exemple d'\u00fas: 'a<b' comprova si a \u00e9s menor que b. Major o igual que: >= o major igual que. Exemple d'\u00fas: 'a>=b' comprova si a \u00e9s major o igual que b. Menor o igual que: <= o menor igual que. Exemple d'\u00fas: 'a<=b' comprova si a \u00e9s menor o igual que b. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // Programa Java per mostrar operadors relacionals public class operadors { public static void main ( String [] args ) { int a = 20 , b = 10 ; String x = \"Thank\" , y = \"Thank\" ; int ar [] = { 1 , 2 , 3 }; int br [] = { 1 , 2 , 3 }; boolean condicion = true ; // Diversos operadors relacionals System . out . println ( \"a == b :\" + ( a == b )); System . out . println ( \"a < b :\" + ( a < b )); System . out . println ( \"a <= b :\" + ( a <= b )); System . out . println ( \"a > b :\" + ( a > b )); System . out . println ( \"a >= b :\" + ( a >= b )); System . out . println ( \"a != b :\" + ( a != b )); // Els arrays no es poden comparar cma operadors relacionals perqu\u00e8 els objectes emmagatzemen refer\u00e8ncies i no el valor System . out . println ( \"x == y : \" + ( ar == br )); System . out . println ( \"condicion==true :\" + ( condicion == true )); } } Activitat 6 C\u00f2pia i executa el codi anterior en Eclipse i observa el que passa.","title":"Operadors relacionals"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#operadors-logics","text":"Aquestos operador s'utilitzen per realitzar operacions l\u00f2giques AND i l\u00f2giques OR , \u00e9s a dir, la funci\u00f3 semblant a la port AND i la porta OR e l'electr\u00f2nica digital. Una cosa a dinre en compte \u00e9s que la segona condici\u00f3 no s'avalua si la primera \u00e9s falsa, \u00e9s a dir, t\u00e9 un efecte de curtcircuit. S'utilitza molt per provar varies condicions per prendre una decici\u00f3. not (!) : negaci\u00f3 l\u00f2gica. and (&&) : and l\u00f2gic. or (||) : or l\u00f2gic. or exclusivo (^) : or exclusiu. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Programa Java per mostrar operadors l\u00f2gics import java.util.Scanner ; public class operadors { public static void main ( String [] args ) { String x = \"java\" ; String y = \"jovo\" ; Scanner s = new Scanner ( System . in ); System . out . print ( \"Usuari:\" ); String uuid = s . next (); System . out . print ( \"Password:\" ); String upwd = s . next (); // Verifica usuari i contrassenya if (( uuid . equals ( x ) && upwd . equals ( y )) || ( uuid . equals ( y ) && upwd . equals ( x ))) { System . out . println ( \"Benvingut\" ); } else { System . out . println ( \"ID o password incorrectes\" ); } } } Activitat 7 Prova i executa el codi anterior. Aquest codi nom\u00e9s es pot executar en Eclipse i no en Processing ja que en aquest \u00faltim no es pot llegir per consola.","title":"Operadors l\u00f2gics"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#operador-condicional-o-ternari","text":"Java inclou un operador especial de tipus ternari que de vegades s'utilitza per substituir algunes estructures if then else. Aquest \u00e9s l'operador ? i la seua forma general \u00e9s: 1 expressio1 ? expressio2 : expressio 3 ; Expressi\u00f3 1: \u00e9s l'expressi\u00f3 que avalua un valor boole\u00e0, d'aquesta forma, si l'expressi\u00f3 1 s'avalua com a true, s'executaria l'expressi\u00f3 2 mentre que si l'expressi\u00f3 1 s'avalua a false, s'executaria l'expressi\u00f3 2. Exemple 1 2 3 4 5 double temperatura ; // Variable que ens indica la temperatur ambient boolean AC_ON = false ; // Variable booleana que ens indica si l'aire condicionat est\u00e0 en marxa temperatura > 25 ? AC_ON = true : AC_ON = false ; // B\u00e0sicament el que faria aquesta espressi\u00f3 seria engegar l'aire condicionat si la temperatura // \u00e9s superior a 25 graus. Activitat 9 Copia i executa aquest codi tant en Eclipse com en Processing IDE i observa el que passa. // Programa Java per il\u00b7lustrar el m\u00e0xim de tres nombres usant operador ternari. public class operators { public static void main ( String [] args ) { int a = 20 , b = 10 , c = 30 , result ; // El resultat obt\u00e9 el m\u00e0xim de tres n\u00fameros. result = (( a > b ) ? ( a > c ) ? a : c : ( b > c ) ? b : c ); System . out . println ( \"M\u00e0ximo de tres n\u00fameros = \" + result ); } }","title":"Operador condicional o ternari"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#estructures","text":"Com hem vist al tema 2, el teorema de la programaci\u00f3 estructurada preveu una s\u00e8rie d'estrucutures b\u00e0siques amb les quals es podr\u00eden codificar tots els algorismes sense necessitat d'usar cap sent\u00e8ncia GOTO o similar. En els pr\u00f2xims punts veurem com es codifiquen totes aquestes estructures en llenguatge Java.","title":"Estructures"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#estructura-dun-programa-en-java","text":"El primer que s'ha de tenir en compte \u00e9s que tot programa escrit en Java ha de tindre almenys un main() a la classe principal per tal que s'execute. En resum, programa escrit en Java ha de tindre: Declaracions d'importaci\u00f3 de paquets o inclusi\u00f3 d'altres llibreries. Declaracions de les classes que el formen. El m\u00e8tode main M\u00e8todes definits pels usuaris dins de les classes. Comentaris. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // Programa principal import java.io.* ; // Llibreries amb funcions d'entrada i eixida. public class nomPrograma { // Nom de la classe principal Calculadora calc ; // Membres de la classe (una calculadora) public static void main ( String [] args ) { // M\u00e8tode principal main calc = new Calculadora (); // Instruccions del m\u00e8tode principal. int result = calc . suma ( 10 , 20 ) System . out . println ( \"Resultat: \" + result ); } } // Una altra classe import java.io.* ; public class Calculadora { // Nom de la classe public int suma ( int a , int b ) { // M\u00e8tode de la classe return a + b ; } } Al programa anterior podem trobar una classe 'nomPrograma' que cont\u00e9 el m\u00e8tode principal main i que al mateix temps cont\u00e9 el conjunt d'instruccions que es van a executar seq\u00fcencialment al nostre programa. Aquesta classe nomPrograma t\u00e9 un memebre calc que \u00e9s un objecte (ja veurem classes i objectes m\u00e9s endavant) de tipus calculadora i que est\u00e0 definit m\u00e9s endavant amb la classe p\u00fablica calculadora. Les sent\u00e8ncies que executa el nostre programa d'exmemple s\u00f3n les seg\u00fcents: - Instancia l'objecte calc (calc = new Calculadora()). - Declara una variable de tipus enter result - Crida al m\u00e8tode suma de l'objecte calc passant-li els par\u00e0metres 10 i 20 - Deposita el resultat que retorna el m\u00e8tode suma de la classe calc a la variable result - Mostra per pantalla el resultat de la suma.","title":"Estructura d'un programa en Java"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#estructura-en-processing-ide","text":"Per tal de treballar amb les estructures b\u00e0siques del paradigma de programaci\u00f3 estructurada, utilitzarem Processing IDE que \u00e9s un IDE lleuger que ens permet programar en Java sense necessitat de fer estructures de classes molt complexes. Concretament Processing IDE \u00e9s un entorn integrat de desenvolupament juntament amb una llibreria gr\u00e0fica que inicialment es va construir per a arts electr\u00f2niques i disseny visual per tal de poder ensenyar els fonaments de la programaci\u00f3 a no-programadors en un context visual. \u00c9s per aix\u00f2 que aquesta eina ens resultar\u00e0 molt \u00fatil per tal d'aprendre els conceptes b\u00e0sics de la programaci\u00f3 estructurada. A continuaci\u00f3 vos mostrem un exemple d'estructura de programa en Processing IDE 1 2 3 4 5 6 7 8 9 10 11 // Refer\u00e8ncies a altres llibrerires. // Variables globals a l'aplicaci\u00f3. void setup () { // Nom\u00e9s s'executa una vegada a l'inici de l'execuci\u00f3. // Sent\u00e8ncies d'inicialitzaci\u00f3 de la nostra aplicaci\u00f3. } void draw () { // S'executa 60 vegades per segon (60Hz freq\u00fcencia del monitor) // Codi principal del programa. } // Declaraci\u00f3 d'altres funcions","title":"Estructura en Processing IDE"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#estructura-sequencial","text":"L'estructura seq\u00fcencial en Java es codifica de la seg\u00fcent manera: 1 2 3 4 5 6 7 // Exemple de bloc - estructura seq\u00fcencial { Instrucci\u00f31 ; Instrucci\u00f32 ; ... Instrucci\u00f3N ; } Veiem a continuaci\u00f3 un exemple codificat en Java amb l'IDE de Processing. Activitat 10 Dibuixa amb processing IDE un punt, una l\u00ednia, un cercle i un quadrat copiant el codi que pots veure a continuaci\u00f3. Despr\u00e9s modifica alguns dels par\u00e0metres de les funcions point, line, ellipse i square i observa el que passa. 1 2 3 4 5 6 7 8 9 10 11 12 void setup () { size ( 320 , 320 ); // Estableix les dimensions de la nostra pantalla principal background ( 255 ); // Estableix el fons de la pantalla fill ( 0 ); // Color amb el que es dibuixaran les figures. } void draw () { point ( 10 , 10 ); // Dibuixa un punt line ( 20 , 20 , 40 , 40 ); // Dibuixa una l\u00ednia ellipse ( 100 , 100 , 80 , 80 ); // Dibuixa una el\u00b7lipse square ( 200 , 200 , 50 ); // Dibuixa un quadrat }","title":"Estructura Seq\u00fcencial"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#estructures-de-seleccio","text":"Com varem explicar al tema anterior, ens podem trobar les seg\u00fcents variants d'estructura de selecci\u00f3: Selecci\u00f3 simple Selecci\u00f3 doble Selecci\u00f3 multiple Operador condicional ?","title":"Estructures de selecci\u00f3"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#seleccio-simple","text":"El seu codi en Java seria: 1 2 3 4 5 6 7 8 9 10 if ( condicio ) instruccio ; // O tamb\u00e9 if ( condicio ) { instruccio1 ; instruccio2 ; ... instruccioN ; } En el primer cas si quan s'avalua la condici\u00f3 aquesta \u00e9s veritat, s'executaria la instrucci\u00f3 si pel contrari la condici\u00f3 \u00e9s falsa, no es fa res. Al segon cas \u00e9s igual que el primer per\u00f2 en cas d'avaluar-se possitivament la condici\u00f3 no s'executaria una sola instrucci\u00f3 si no que s'executaria (seq\u00fcencialment) el bloc d'instruccions seg\u00fcent: instrucci\u00f31, instrucci\u00f32 fins instrucci\u00f3N. Exemple en Java: 1 2 3 4 5 6 7 8 9 10 11 12 13 import java.util.* ; public class condicioSimple { public static void main ( String [] args ) { Scanner sc = new Scanner ( System . in ); System . out . println ( \"Quina hora \u00e9s?:\" ); int hora = sc . nextInt (); if ( hora >= 9 ) System . out . println ( \"A sopar\" ); System . out . println ( \"Adeu\" ); } } Activitat 11 Escriu el codi anterior amb Eclipse i observa que passa Com que en Processing IDE resulta molt complicat el llegir per consola, per la inserci\u00f3 d'informaci\u00f3 per part de l'usuari, ho farem de forma aleat\u00f2ria. A l'API de Processing, Processing Reference , entre altres tenim una funci\u00f3 random(low, high) que genera nombres aleatoris dintre del rang low-hight que se li passa per par\u00e0metre, \u00e9s a dir, si volem que aquesta funci\u00f3 ens torne un valor aleatori entre 0 i 100, haur\u00edem de cridar-la de la seg\u00fcent forma: double num = random ( 0 , 100 ); Activitat 12 Utilitzant la funci\u00f3 random() vista a l'apartat anterior, escriu un programa en Processing que donat un nombre alelatori ens indique si aquest \u00e9s parell o senar. Un possible resultat seria el seg\u00fcent: A l'activitat anterior he generat 5 vegades un n\u00famero aleatori i he comprovat si era parell o senar mostrant la informaci\u00f3 pel terminal (ha d'estar tot el codi a la funci\u00f3 setup() ). Tamb\u00e9 podr\u00edem fer que ho mostrara a la funci\u00f3 draw a la pantalla principal de l'aplicaci\u00f3 utilitzant la funci\u00f3 text() de l'IDE de Processing. El resultat podria ser el seg\u00fcent:","title":"Selecci\u00f3 Simple"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#if-else","text":"El codi en Java seria 1 2 3 4 5 6 7 8 9 10 11 12 instruccio1 ; instruccio2 ; if ( condicio ) { instruccio3 ; instruccio4 ; } else { instruccio5 ; instruccio6 ; } instruccio7 ; instruccio8 ; Si ens fixem en el codi anterior, podem trobar dues seq\u00fc\u00e8ncies d'execucio d'instruccions depenenet si la condici\u00f3 del 'if' s'avalua 'true' o 'false'. En el primer cas, amb la condici\u00f3 a true, s'executarien: instrucci\u00f31, instrucci\u00f32, instrucci\u00f33, instrucci\u00f34, instrucci\u00f37 i instrucci\u00f38. Mentre que si la condici\u00f3 del 'if' s'avaluara a 'false', les instruccions a executar serien: instrucci\u00f31, instrucci\u00f32, instrucci\u00f35, instrucci\u00f36, instrucci\u00f37 i instrucci\u00f38. Exemple en Java: 1 2 3 4 5 6 7 8 9 10 11 12 import java.util.* ; public class condicioDoble { public static void main ( String [] args ) { Scanner sc = new Scanner ( System . in ); System . out . println ( \"Quina hora \u00e9s?:\" ); int hora = sc . nextInt (); if ( hora >= 12 ) System . out . println ( \"Encara \u00e9s de mat\u00ed\" ); else System . out . println ( \"Ja \u00e9s de vesprada\" ); } } Activitat 13 Amplia l'exemple anterior per tal que ens indique, en cas de no ser parell, que \u00e9s senar. Com que s'ha de llegir per consola, \u00e9s millor que ho fages amb Eclipse.","title":"if .. else"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#if-else-if-else","text":"El mateix exemple en Java que teniu a la imatge anterior seria: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 instruccio1 ; if ( condicio1 ) { instruccio2 ; instruccio3 ; } else if ( condicio2 ) { instruccio4 ; } else if ( condicio3 ) { instruccio5 ; instruccio6 ; instruccio7 ; } else { instruccio8 ; instruccio9 ; } instruccio10 ; Al codi anterior l'\u00fanic que s\u00ed sabem cert \u00e9s que s'executaran les instruccions 1 i 2 i depenent de quina condici\u00f3 s'avalua a true s'executar\u00e0 algun bloc d'instruccions que estan dins de l'estructura condicional. Exemple Seguint amb l'exemple de l'hora que hem utilitzat als apartats anteriors veiem com es podria usar una condici\u00f3 m\u00faltiple amb if else 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import java.util.* ; public class condicioMultiple { public static void main ( String [] args ) { Scanner sc = new Scanner ( System . in ); System . out . println ( \"Quina hora \u00e9s?:\" ); int hora = sc . nextInt (); if ( hora >= 7 && hora <= 9 ) System . out . println ( \"Eres matiner\" ); else if ( hora > 9 && hora <= 12 ) System . out . println ( \"Deuries haver esmorzat ja\" ); else if ( hora > 12 && hora <= 15 ) System . out . println ( \"Es hora de dinar si no has dinat\" ); else if ( hora > 15 && hora <= 18 ) System . out . println ( \"Si no has fet una migdiada oblidat\" ); else System . out . println ( \"Hora de la cervesa\" ); } } Activitat 14 Passa el codi anterior a Processing IDE. Com que no es pot llegir per consola, fes que l'hora i els minuts es generen de forma aleat\u00f2ria amb la funci\u00f3 random . Al final de cada cicle de la funci\u00f3 draw posa un delay de 1 segon per tal que ens done temps a veure el resultat. Recorda tamb\u00e9 de fer un clear() al principi de cada cicle de draw. El resultat podria ser el seg\u00fcent: Activitat 15. Divisio Escriu un programa en Processing IDE que genere aleat\u00f2riament dos nombres enters i que calcule la seua divisi\u00f3. El programa ens haur\u00e0 d'indicar si la divisi\u00f3 \u00e9s exacta qui \u00e9s el resultat i si no \u00e9s exacta quin \u00e9s el resultat i el residu. // Estructura del codi que pots utilitzar. void setup () { size ( 500 , 500 ); // Ens determina el tamany de la pantalla de la nostra aplicaci\u00f3. textAlign ( CENTER ); // L'ancora del text ser\u00e0 el cetnre mateix. } void draw () { clear (); // Cada vegada que s'executa el draw (29 fps) s'esborra la pantalla. background ( 255 ); // Pinta el fons de blanc fill ( 0 ); // per tal que el text siga negre // Afig el codi ac\u00ed // Per escriure a la pantalla usa la funci\u00f3 text(String, int, int); delay ( 1000 ); // Retr\u00e0s per tal que done temps a llegir el que escriu. } Com a apartat d'ampliaci\u00f3, podries fer que el tamany de la font fos un poc m\u00e9s gran. Activitat 16. Divisi\u00f3 per zero. Si s'ha dona el cas, haur\u00e0s pogut comprovar que si el divisor \u00e9s 0 el programa dona error. Millora el programa anterior controlant el que passa quan es vol dividir per zero, mostrant un missatge en el cas que el n\u00famero pel qual s'intenta dividir siga zero. Possible soluci\u00f3 Activitat 17. Major, menor o igual Ecriu un programa en Processing que genere aleat\u00f2riament dos n\u00fameros i que diga quin \u00e9s el major, quin \u00e9s el menor o si s\u00f3n iguals. Activitat 18. Difer\u00e8ncia d'anys Escriu un programa en Processing que donat l'any actual i un any qualsevol que es genere de forma aleat\u00f2ria amb la funci\u00f3 random i escriga quants anys han passat des d'eixe any o quants anys falten per arribar a eixe any. Activitat 19. Millora Millora el programa anterior fent que quan la difer\u00e8ncia siga exactament un any, mostre una frase concreta: \"Nom\u00e9s queda un any\" Activitat 20. M\u00faltiples Escriu un programa que genere dos n\u00fameros aleatoris entre el 0 i el 100 i escriga si el n\u00famero major \u00e9s multiple del menor. Activitat 21. Millor m\u00faltiples Millora el programa anterior fent que el programa avise quan s'escriguen valors negatius o nuls. Activitat 22. Comparador Escriu un programa que donats 3 n\u00fameros (creats aleat\u00f2riament) ens diga si s\u00f3n els tres iguals, dos s\u00f3n iguals o cap \u00e9s igual. Activitat 23. Any bixest Escriu un programa que genere un any aleatori de 0 a 2021 i ens diga si aquest \u00e9s bixest o no. Cal recordar que els anys bixests s\u00f3n m\u00faltiples de 4, per\u00f2 no s\u00f3n m\u00faltiples de 100 i s\u00ed s\u00f3n m\u00faltiples de 400. Per exemple: 2012 \u00e9s bixest, 2010 no ho \u00e9s, 2000 s\u00ed que ho es per\u00f2 1900 no ho \u00e9s. Pots basar-te en el seg\u00fcent codi. Activitat 24. C\u00e0lcul d'arees Escriu un programa que primer demane si es vol calcular l'area d'un cercle (escrivint c o C) o d'un triangle (t o T). Si es tria el triangle s'haur\u00e0 de demanar la base i l'altura mentre que si es tria el cercle s'haur\u00e0 de demanar el radi. Aquest programa \u00e9s recomanable que es faja amb Eclipse IDE. Activitat 25. Canvi d'unitats Escriu un programa que demane una dist\u00e0ncia en cent\u00edmetres i que escriga la mateixa dist\u00e0ncia en quilometres, metres i centimetres.","title":"if else if else"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#switch-case","text":"La sent\u00e8ncia de control 'switch' \u00e9s una altra forma de codificar la condici\u00f3 m\u00f9ltiple que hem vist a l'apartat anterior per\u00f2 m\u00e9s senzilla de visualitzar a primer cop d'ull 1 2 3 4 5 6 7 8 9 10 11 12 13 switch ( condicio ) { case 1 : // Instruccions break ; case 2 : // INstrucciones 2 break ; default: // Instruccions per defecte break ; } Un altre exemple m\u00e9s clar 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 //Programa que demana un numero i diu quin mes \u00e9s import java.util.* ; public class ExempleSwitch { public static void main ( String [] args ) { int mes ; Scanner sc = new Scanner ( System . in ); System . out . print ( \"Introdueix el numero del mes: \" ); mes = sc . nextInt (); switch ( mes ) { //inicio del switch case 1 : System . out . println ( \"GENER\" ); break ; case 2 : System . out . println ( \"FEBRER\" ); break ; case 3 : System . out . println ( \"MAR\u00c7\" ); break ; case 4 : System . out . println ( \"ABRIL\" ); break ; case 5 : System . out . println ( \"MAIG\" ); break ; case 6 : System . out . println ( \"JUNY\" ); break ; case 7 : System . out . println ( \"JULIOL\" ); break ; case 8 : System . out . println ( \"AGOST\" ); break ; case 9 : System . out . println ( \"SETEMBRE\" ); break ; case 10 : System . out . println ( \"OCTUBRE\" ); break ; case 11 : System . out . println ( \"NOVEMBRE\" ); break ; case 12 : System . out . println ( \"DESEEMBRE\" ); break ; default : System . out . println ( \"No v\u00e0lid\" ); } } } Activitat 26 Escriu el programa anterior per a Processing. Recorda que amb processing l'entrada per consola l'hem de substituir per generaci\u00f3 de valors aleatoris amb random . En l'exemple anterior el que s'ha fet ha sigut generar aleat\u00f2riament un n\u00famero enter entre 0 i 15 i despr\u00e9s mostrar per pantalla: primer el n\u00famero del mes i despr\u00e9s el nom. Activitat 27. Dies de la setmana Escriun un programa que donat un n\u00famero entre 1 i 7 et diga quin dia de la setmana \u00e9s. 1 Dilluns, 2 Dimarts etc.. Activitat 28. if a switch Passa les activitats de l'apartat if..else a sent\u00e8ncies switch..case 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Exemple de switch convertit a if switch ( variable ) { case valor1 : // Accions 1 break ; case valor2 : // Accions 2 break ; case valor3 : // Accions 3 break ; default : // Accions default } // El codi anterior utilitzant if if ( variable == valor1 ) // Accions 1 else if ( variagble == valor2 ) // Accions 2 else if ( variable == valor3 ) // Accions 3 else //Accions default Activitat 29. dies del mes Escriu un programa que ens demane el mes i l'any i ens mostre per pantalla el total de dies que t\u00e9 eixe mes. Si fas el programa amb Processing recorda que el n\u00famero del m\u00e9s l'haur\u00e0s de generar de forma aleat\u00f2ria. Activitat 30. Figures geom\u00e8triques Escriure un programa que demane primer de quina figura geom\u00e8trica es vol calcular el perimetre. Triangle (t), Quadrat (q), Cercle (c) o rectangle (r) i despr\u00e9s mostre el c\u00e0lcul corresponent.","title":"switch case"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#estructures-de-repeticio","text":"Imaginem que tenim un vector d'enters de 100 elements i volem trobar un nombre concret. Usant les estrcutures condicionals ho podr\u00edem fer. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int [] arrayNumeros ; // Declarem un array d'enters arrayNumeros = new int [ 100 ] ; // Reservem espai en mem\u00f2ria per 100 elements inicialitzaNumeros ( arrayNumeros ); // Emplenem de forma aleat\u00f2ria l'array // Comencem la recerca del n\u00famero 10 per exemple if ( array [ 0 ] == 10 ) System . out . println ( \"N\u00famero trobat a la posici\u00f3 0\" ); else if ( array [ 1 ] == 10 ) System . out . println ( \"N\u00famero trobat a la posici\u00f3 1\" ); else if ( array [ 2 ] == 10 ) System . out . println ( \"N\u00famero trobat a la posici\u00f3 2\" ); else if ( array [ 3 ] == 10 ) System . out . println ( \"N\u00famero trobat a la posici\u00f3 3\" ); else if ( array [ 4 ] == 10 ) System . out . println ( \"N\u00famero trobat a la posici\u00f3 4\" ); else if ( array [ 5 ] == 10 ) System . out . println ( \"N\u00famero trobat a la posici\u00f3 5\" ); // I aix\u00ed fins 100 ... Com podeu observar, nom\u00e9s he necessitat escriure codi per als 5 primers elements del nostre array per adondar-me que aquest codi \u00e9s totalment ineficient i t\u00e9 un manteniment molt complicat. Imagineu un array amb 1000 elements i que ho hagurem de codificar com hem fet abans. Les estructures repetitives permetrien rec\u00f2rrer l'array de principi a final sense necessitat d'escriure tant de codi. Veiem els seg\u00fcents exemples.","title":"Estructures de repetici\u00f3"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#while","text":"En aquest tipus de bucle, el bloc d'instruccions del bucle while, es poden executar zero o m\u00e9s vegades. Els passos que representen el diagrama anterior s\u00f3n: 1. S'executa la instrucci\u00f3 1 2. S'avalua la condici\u00f3 3. Si la condici\u00f3 \u00e9s true, s'executa el bloc d'instruccions del bucle i es torna a avaluar la condici\u00f3. 4. En cas que la condici\u00f3 s'avalue com a false, passar\u00edem a executar la instrucci\u00f3 2. Exemple: Com far\u00edem el codi necessari per rec\u00f2rrer el nostre array de 100 elements fins trobar el n\u00famero que busquem? 1 2 3 4 5 6 int i = 0 ; // Inicialitzem una variable que ens servir\u00e0 de contador. while ( i < 100 ) { if ( arrarNumeros [ i ] == 10 ) System . out . println ( \"N\u00famero trobat a la posici\u00f3 \" + i ); i ++ ; // Important incrementar el contador o entrar\u00edem en un bucle infinit. }","title":"while"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#do-while","text":"Els passos que representen el diagrama anterior s\u00f3n: 1. S'executa la instrucci\u00f3 1 2. S'executen les instruccions que cont\u00e9 el bloc 3. S'avalua la condici\u00f3 4. Si la condici\u00f3 \u00e9s true, s'executa el bloc d'instruccions del bucle i es torna a avaluar la condici\u00f3. 5. En cas que la condici\u00f3 s'avalue com a false, passar\u00edem a executar la instrucci\u00f3 2. Exemple: Com far\u00edem el codi necessari per rec\u00f2rrer el nostre array de 100 elements fins trobar el n\u00famero que busquem? 1 2 3 4 5 6 7 int i = 0 ; // Inicialitzem una variable que ens servir\u00e0 de contador. do { if ( arrarNumeros [ i ] == 10 ) System . out . println ( \"N\u00famero trobat a la posici\u00f3 \" + i ); i ++ ; // Important incrementar el contador o entrar\u00edem en un bucle infinit. } while ( i < 100 );","title":"do .. while"},{"location":"Tema%2003.%20El%20llenguatge%20Java/#bucle-for","text":"Executem instrucci\u00f3 1 (aliena al bucle for) Inicialitzaci\u00f3 Avaluaci\u00f3 de la condici\u00f3 Si la condici\u00f3 \u00e9s true Executem les instruccions del bucle for Actualitzem \u00edndex Si la condici\u00f3 es false eixim del bucle i executem instrucci\u00f3 2 1 2 3 4 for ( int i = 0 ; i < 100 ; i ++ ) { if ( arrarNumeros [ i ] == 10 ) System . out . println ( \"N\u00famero trobat a la posici\u00f3 \" + i ); } Al codi anterior: 1. Inicialitzaci\u00f3: int i = 0; 2. Avaluaci\u00f3 de la condici\u00f3: \u00e9s i < 100 ? 3. Actualitzaci\u00f3: i ++ Activitat 31. Dibuixa amb bucles Observa el seg\u00fcent codi i raona'l 1 2 3 4 5 6 7 8 9 10 void setup () { size ( 320 , 240 ); } void draw () { for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) circle ( 10 + j * 20 , 10 + i * 20 , 20 ); } } El resultat d'aquest codi seria: Activitat 32. Dibuixa la piramid i la invertida Fes un programa semblant al de l'activitat anterior per\u00f2 a la inversa, \u00e9s a dir, cinc cercles a la primera l\u00ednia, quatre a la segona, tres a la tercera, dos a la quarta i, finalment, un a la cinquena l\u00ednia. Activitat 33. Dibuixa la diagonal Donada una pantalla de 500 pixels d'ample i 500 d'alt, fes un programa que dibuixe quadrats de 20 per 20 pixels ocupant la diagonal de la pantalla des de la posici\u00f3 (0,0) fins la (500,500). Activitat 34. Dibuixa les dues diagonals Millora el programa anterior i fes que dibuixe les dues diagonals, des del punt (0,0) fins al (500,500) i l'altra que va des del punt (500,0) fins al (0,500). Si a una diagonal li dibuixes quadrats, a l'altra dibuixa-li cercles. Activitat 35. Dues diagonals 640x480 Millora l'activitat anterior i dibuixa les dues diagonals per\u00f2 a una pantalla de 640 pixels per 480 pixels. Activitat 36. whiles i for Fes les activitat anteriors canviant els bulces while per for i a l'inrev\u00e9s.","title":"bucle for"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/","text":"Tema 4. Programaci\u00f3 Modular Introducci\u00f3 La programaci\u00f3 modular \u00e9s un paradigma de programaci\u00f3 que consisteix a dividir un programa en m\u00f2duls o subprogrames per tal de fer-lo m\u00e9s llegible i manejable Es presenta hist\u00f2ricament com una evoluci\u00f3 de la programaci\u00f3 estructurada per solucionar problemes de programaci\u00f3 m\u00e9s grans i complexos del que aquesta pot resoldre. A l'aplicar la programaci\u00f3 modular, un problema complex ha de ser dividit en diversos subproblemes m\u00e9s simples, i aquests al seu torn en altres subproblemes m\u00e9s simples encara. Aix\u00f2 s'ha de fer fins a obtenir subproblemes prou simples com per poder ser resolts f\u00e0cilment amb algun llenguatge de programaci\u00f3. Aquesta t\u00e8cnica es diu refinament successiu, divideix i vencer\u00e0s o an\u00e0lisi descendent (Top-Down). Un 'm\u00f2dul' \u00e9s cadascuna de les parts d'un programa que resol un dels subproblemes en qu\u00e8 es divideix el problema complex original. Cadascun d'aquests m\u00f2duls t\u00e9 una tasca ben definida i alguns necessiten d'altres per poder operar. En cas que un m\u00f2dul necessiti d'un altre, pot comunicar-se amb aquest mitjan\u00e7ant una interf\u00edcie de comunicaci\u00f3 que tamb\u00e9 ha d'estar ben definida. Si b\u00e9 un m\u00f2dul es pot entendre com una part d'un programa en qualsevol de les seves formes i variats contextos, en la pr\u00e0ctica se'ls sol prendre com a sin\u00f2nims de procediments i funcions. Per\u00f2 no necess\u00e0ria ni estrictament un m\u00f2dul \u00e9s una funci\u00f3 o un procediment, ja que el mateix pot contenir molts d'ells. No s'ha de confondre el terme \"m\u00f2dul\" (en el sentit de programaci\u00f3 modular) amb termes com \"funci\u00f3\" o \"procediment\", propis de l'llenguatge que ho suporte. Abstracci\u00f3 L'abstracci\u00f3 \u00e9s la capacitat de, observada una realitat, quedar-se amb all\u00f2 important o essencial i obviar el detall. Aquest concepte ser\u00e0 un concepte b\u00e0sic en l'evoluci\u00f3 de la programaci\u00f3 estructurada i modular cap a la programaci\u00f3 orientada a objectes. Per exemple, per saber conduir un cotxe no necessite saber al detall el funcionament del seu motor sino on est\u00e0 l'accelerador, el fre i el volant. No hem de pensar mai en un programa com un tot sino com un conjunt de m\u00f2duls relacionats entre si on cada m\u00f2dul desenvolupa una tasca molt concreta independentment de la resta i que tots junts formen el programa o aplicaci\u00f3. Caracter\u00edstiques Es considera moudlaritat com la definici\u00f3 d'un programa com a conjunt de subprogrames (m\u00f2duls). Cada m\u00f2dul t\u00e9 una funci\u00f3 particular, \u00e9s semi-independent i tamb\u00e9 pot trobar-se en fitxers de codi distints. Avantatges El codi resultant \u00e9s m\u00e9s net i f\u00e0cil d'entendre. Permet la divisi\u00f3 del treball. Es pot provar de forma independent, millorant aix\u00ed la recerca i correcci\u00f3 d'errades. Facilita la definici\u00f3 de variables al crear diversos \u00e0mbits. Depenent del nivell de detall amb el que es tracten els m\u00f2duls, podem distindir tres tipus: - Llibreries - Classes - Funcions o m\u00e8todes Una funci\u00f3 \u00e9s un tro\u00e7 de codi que realitza una funci\u00f3 concreta i de vegades torna algun valor com a resultat. Funcions en Java Una funci\u00f3 en Java t\u00e9 la seg\u00fcent estructura: 1 2 3 4 5 6 7 8 [ acces ] [ modificador ] tipus nomFuncio ( [ tipus nomArgument , [ tipo nomArgument ] ... ] ) { /* * Bloque de instrucciones */ return valor ; } Tots aquells elements que estan entre claudators s\u00f3n opcionals On: - Acc\u00e9s: public, protected, private o package - Modificador: static o final - Tipo: int, boolean, float o qualsevol tipus predefinit per l'usuari. - nomFuncio: cadena alfanum\u00e8rica significativa que indique el que fa la funci\u00f3. - nomArgument: par\u00e0metres que se li passen a la funci\u00f3. Aquestos par\u00e0metres funcionaran com variables locals a la funci\u00f3. Exemples 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Funci\u00f3 simple void diguesHola () { System . out . println ( \"Hola Mon\" ); } // Funci\u00f3 amb par\u00e0metres void sayMyName ( String strNom ) { System . out . println ( \"Hola Mon: \" + strNom ); } // Funci\u00f3 que torna algun valor String canviaNom ( String strNom ) { return strNom . reverse (); } Sobre els arguments Hi ha alguns detalls al respeecte dels arguments d'una funci\u00f3: - Una funci\u00f3 pot tindre una quantitat qualsevol de par\u00e0metres, \u00e9s a dir, poden tindre des de zero fins a un, dos, deu o cent par\u00e0metres. Normalment no sol passar de cinc m\u00e0xim. - Si la funci\u00f3 t\u00e9 m\u00e9s d'un par\u00e0metre cadascun d'ells ha d'anar separat per una coma. - Els arguments d'una funci\u00f3 tamb\u00e9 tenen un tipus i nom que els identifica. - El tipus dels arguments pot ser qualsevol i no ha de tindre relaci\u00f3 amb el tipus del m\u00e8tode. - Al rebre un argument res ens obliga a fer \u00fas d'aquest dins del m\u00e8tode. - Els par\u00e0metres poden passar-se per refer\u00e8ncia (es mantenen les modificacions que es facen dins del m\u00e8tode) o per valor (no afectarien les modificacions a l'element original). Sobre el return Has de tenir en compte dues coses importants amb la sent\u00e8ncia return: - Qualsevol instrucci\u00f3 que es trobe despr\u00e9s de l'execuci\u00f3 de return, NO ser\u00e0 executada. - \u00c9s com\u00fa trobar funcions amb m\u00faltiples sent\u00e8ncies return al seu codi, com per exemple en sentencies condicionals, per\u00f2 una vegada el codi execute una sent\u00e8ncia return all\u00f2 que vinga despr\u00e9s no s'executar\u00e0. - El tipus de valor que es torna en una funci\u00f3 ha de conicidir amb el tipus declarat a la funci\u00f3, \u00e9s a dir, si es declara int, el valor que ha de tornar ha de ser un nombre enter. - En el cas de les funcions que no tornen res (void), tamb\u00e9 conegues com a procediments, poden usar la sent\u00e8ncia return per\u00f2 sense cap valor i nom\u00e9s s'usaria per acabar amb l'execuci\u00f3 de la funci\u00f3. Crida a un funci\u00f3 Per tal de cridar una funci\u00f3 en Java s'ha de fer de la seg\u00fcent forma: 1 nombre ( [ valor , [ valor ] ... ] ); Una funci\u00f3 en Java es crida utilitzant el nom del m\u00e8tode i entre par\u00e9ntesis s'han de passar els par\u00e0metres que s'indica a la declaraci\u00f3 de la funci\u00f3. Aquestos par\u00e0metres que es passen han de coincidir en n\u00famero, si la declaraci\u00f3 del funci\u00f3 t\u00e9 3 par\u00e0metres s'hauran de passar tres par\u00e0metres, i tamb\u00e9 han de coincidir en el t\u00edtol. Per\u00f2 millor vegem un exemple: Funcions: declaraci\u00f3 i crida 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Declaraci\u00f3 de la funci\u00f3 holaMon void holaMon ( String strNom ) { System . out . println ( \"Hola: \" + strNom ); } // Declaraci\u00f3 del funci\u00f3 suma int suma ( int a , int b ) { int res = a + b ; return res ; } // Crida correcta a la funci\u00f3 holaMon holaMon ( \"Batiste\" ); // Crida incorrecta a la funci\u00f3 holaMon holaMon (); holaMon ( \"Batiste\" , \"Ceba\" ); // Crida correcta a suma int resultat = suma ( 10 , 5 ); suma ( 10 , 5 ); // Crides incorrectes. int resultat = suma (); suma (); int res = suma ( 10 , 3 , 10 ); Activitat 1 C\u00f2pia el codi anterior, executa'l i raona el que est\u00e0 passant. Modifica el codi per tal que funcione correctament i mostre un resultat per pantalla. Detalls per invocar funcions No importa si es tracta d\u2019un m\u00e8tode en Java o d\u2019una funci\u00f3 o d\u2019un m\u00e8tode, nom\u00e9s els debats ocupen d\u2019enviar els par\u00e0metres de la forma correcta per invocar-los. El nombre ha de coincidir exactament al moment d\u2019invocar, \u00e9s l\u2019\u00fanica forma d\u2019identificar-lo.L\u2019ordenaci\u00f3 dels par\u00e0metres i el tipus ha de coincidir. Cal tindre cura en el moment d'enviar els par\u00e0metres, hem de fer-ho en el mateix ordre en que varen ser declarats i han de ser del mateix tipus. Cada par\u00e0metre enviat tamb\u00e9 va separat per comes. Si una funci\u00f3 no rep par\u00e0metres, simplement no posem res a l'interior de la par\u00e8ntesi, per\u00f2 sempre debem posar la par\u00e8ntesi. Invocar una funci\u00f3 sigue sentint una sent\u00e8ncia comuna i corrent en Java, aix\u00ed que ha de finalitzar amb ';' com sempre. El valor retornat per un m\u00e8tode o funci\u00f3 pot ser assignat a una variable del mateix tipus, per\u00f2 no podem fer aix\u00f2 amb un procediment, no es pot retornar valor alg\u00fa. Una funci\u00f3 pot llamar a una altra dins de s\u00ed mateixa o fins i tot pot ser enviada com a par\u00e0metre a una altra (mira el seg\u00fcent exemple). Par\u00e0metres d'una funci\u00f3 \u00c9s possible passar un o m\u00e9s valors a una funci\u00f3 quan es crida. Recordeu que un valor passat a una funci\u00f3 es diu argument . Dins la funci\u00f3, la variable que rep l'argument es diu par\u00e0metre . Els par\u00e0metres es declaren dins dels par\u00e8ntesis que segueixen a el nom de m\u00e8tode. La sintaxi de declaraci\u00f3 de par\u00e0metre \u00e9s la mateixa que la utilitzada per a les variables. Un par\u00e0metre est\u00e0 dins de l'abast de la seua funci\u00f3, i a banda de la seva tasca especial de rebre un argument, actua com qualsevol altra variable local. Ac\u00ed hi ha un exemple simple de l'\u00fas de par\u00e0metres. Dins de la classe ComprobarNumero, el m\u00e8tode Espar () retorna true si el valor que es passa \u00e9s parell. Retorna false en cas contrari. Per tant, Espar () t\u00e9 un tipus de retorn boole\u00e0. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Un exemple simple de l'\u00fas de param\u00e8tres class ComprovarNumero { // Retorna true si x es parell boolean esParell ( int x ){ if (( x % 2 ) == 0 ) return true ; else return false ; } } class ParametroDemo { public static void main ( String [] args ) { ComprobarNumero e = new ComprobarNumero (); if ( e . esPar ( 10 )) System . out . println ( \"10 es par.\" ); if ( e . esPar ( 9 )) System . out . println ( \"9 es par.\" ); if ( e . esPar ( 8 )) System . out . println ( \"8 es par.\" ); } } Activitat 2 Passa el codi anterior a Processing i executa'l. Un m\u00e8tode pot tenir m\u00e9s d'un par\u00e0metre. Simplement declare cada par\u00e0metre, separant un el seg\u00fcent amb una coma. Per exemple, la classe Divisor defineix un m\u00e8tode anomenat esDivisor () que determina si el primer par\u00e0metre \u00e9s divisor de el segon. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Un exemple sempre de l'\u00fas de param\u00e8tres class Divisor { boolean esDivisor ( int a , int b ){ if (( b % a ) == 0 ) return true ; else return false ; } } class DivisorDemo { public static void main ( String [] args ) { Divisor x = new Divisor (); if ( x . esDivisor ( 2 , 20 )) System . out . println ( \"2 es Divisor de 20\" ); if ( x . esDivisor ( 3 , 20 )) System . out . println ( \"3 es Divisor de 20\" ); } } Depenent del tipus de dada que enviem a la funci\u00f3 com a argument, podem diferenciar dos comportaments: Pas per valor: Es crea una c\u00f2pia local de la variable dins de la funci\u00f3. Pas per refer\u00e8ncia: Es maneja directament la variable, els canvis realitzats dins de la funci\u00f3 li afectaran tamb\u00e9 fora. Activitat 3 Passa el seg\u00fcent codi a processing, executa'l i raona el que est\u00e0 passant. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void setup () { size ( 320 , 240 ); int i = 10 ; int [] array = new int [ 10 ] ; for ( int a = 0 ; a < i ; a ++ ) array [ a ] = 0 ; System . out . println ( \"Abans de la cirda a la funci\u00f3:\" ); System . out . println ( \"i=\" + i ); System . out . println ( \"array[5]=\" + array [ 5 ] ); funcio ( i , array ); System . out . println ( \"Despr\u00e9s de la cirda a la funci\u00f3:\" ); System . out . println ( \"i=\" + i ); System . out . println ( \"array[5]=\" + array [ 5 ] ); } void draw () { delay ( 10000 ); } void funcio ( int i , int [] array ) { i = 5 ; array [ i ] = 5 ; } Activitat 4 Escriu el seg\u00fcent codi en Processing i executa'l 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // Variables globals int x , y ; void setup () { size ( 320 , 240 ); x = 150 ; y = 120 ; } void draw () { background ( 255 ); stroke ( 0 ); // Dibuixem la cara cercle strokeWeight ( 2 ); fill ( 255 , 255 , 0 ); circle ( x , y , 100 ); // Dibuixem ulls strokeWeight ( 2 ); fill ( 255 ); circle ( 130 , 110 , 20 ); circle ( 165 , 110 , 20 ); strokeWeight ( 5 ); point ( 133 , 110 ); point ( 168 , 110 ); // Dibuixem la boca noFill (); strokeWeight ( 2 ); arc ( 150 , 135 , 40 , 30 , 0 , PI ); Aquest codi mostra el seg\u00fcent dibuix Activitat 5. Divideix-lo en funcions. Separa el codi en funcions, has d'afegir les funcions dibuixaUlls i dibuixaBoca seguint els prototips que et mostre a continuaci\u00f3. 1 2 3 // Prototips de funcions void dibuixaUlls (); void dibuixaBoca (); Activitat 6. Par\u00e0metres coordenades. Modifica el codi anterior per tal que tant el codi que dibuixa els ulls com el codi que dibuixa la boca, estiguen en dues funcions: dibuixaUlls i dibuixaBoca. A aquestes funcions se'ls passar\u00e0 com a par\u00e0metres les coordenads x i y i a partir d'aquestes ha de dibuixar els ulls i la boca on corresponga. 1 2 3 // Prototips de les funcions void dibuixaUlls ( int x , int y ); void dibuixaBoca ( int x , int y ); Activitat 7 Amplia el codi anterior per tal que mostre el seg\u00fcent dibuix. Observa com ha de quedar el codi de la funci\u00f3 draw 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // Variables Globals int cercleX , cercleY , triangleX , triangleY , quadratX , quadratY ; void setup () { size ( 640 , 300 ); // Coordenades del cercle cercleX = 150 ; cercleY = 150 ; // Coordenades del primer punt del triangle triangleX = 250 ; triangleY = 200 ; // Coordenades del quadrat quadratX = 445 ; quadratY = 100 ; } void draw () { background ( 255 ); // Codi per dibuixar el cercle // Escriu el codi necessari per dibuixar el cercle a cercleX i cercleY dibuixaUlls ( cercleX , cercleY ); dibuixaBoca ( cercleX , cercleY ); // Codi per dibuixar el triangle // Escriu el codi necessari per dibuixar el cercle a triangleX i triangleY dibuixaUlls ( triangleX , triangleY ); dibuixaBoca ( triangleX , triangleY ); // Codi per dibuixar el quadrat // Escriu el codi necessari per dibuixar el cercle a quadratX i quadratY dibuixaUlls ( quadratX , quadratY ); dibuixaBoca ( quadratX , quadratY ); } Activitat 8. Dibuixar pe\u00e7a domino. Emplena el codi de la funci\u00f3 dibuixaDomino(int,int) per tal que mostre la imatge seg\u00fcent. 1 2 3 4 5 6 7 8 9 10 void setup () { size ( 640 , 480 ); } void draw () { dibuixaDomino ( 5 , 4 ); } void dibuixaDomino ( int a , int b ) { // Codi per dibuixar la pe\u00e7a de domin\u00f3 amb la puntuaci\u00f3 que es passa per par\u00e0metre. } Activitat 9 Qu\u00e8 passa si en lloc de 5 i 4 pasarem 6 i 6 per par\u00e0metre? Dibuixa el que esperes que dibuixe? Fes les modficacions necess\u00e0ries al codi per tal que funcione com s'espera. Ampliaci\u00f3: fes que el teu algorisme mostre totes les peces del domin\u00f3 ordenades en files i columnes. Pas d'objectes a funcions Quan passem un tipus primitiu a una funci\u00f3, es passa per valor. Per\u00f2 quan vam passar un objecte a una funci\u00f3, la situaci\u00f3 canvia dr\u00e0sticament, perqu\u00e8 els objectes es passen pel que efectivament \u00e9s anomenat, per refer\u00e8ncia . Java fa aquesta cosa interessant que \u00e9s una classe d'h\u00edbrid entre passar per valor i passar per refer\u00e8ncia. B\u00e0sicament, la funci\u00f3 no pot canviar un par\u00e0metre, per\u00f2 la funci\u00f3 pot demanar-li a l'par\u00e0metre que es canvi\u00ef a si mateix cridant a algun m\u00e8tode dins d'ell. A l'crear una variable d'un tipus de classe (un objecte), nom\u00e9s vam crear una refer\u00e8ncia a un objecte. Per tant, quan passem aquesta refer\u00e8ncia a un m\u00e8tode, el par\u00e0metre que el rep es referir\u00e0 a el mateix objecte que el referit per l'argument. Aix\u00f2 vol dir efectivament que els objectes actuen com si es passessin als m\u00e8todes mitjan\u00e7ant l'\u00fas de trucada per refer\u00e8ncia. Els canvis en l'objecte dins el m\u00e8tode es reflecteixen en l'objecte utilitzat com a argument. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // Programa Java per demostrar el pas d'objectes a funcions class Demo { int a , b ; Demo ( int i , int j ) { a = i ; b = j ; } // Torna true si els valors s\u00f3n els mateixos boolean equalTo ( Demo obj ) { return ( obj . a == a && obj . b == b ); } } public class Test { public static void main ( String args [] ) { Demo ob1 = new Demo ( 100 , 22 ); Demo ob2 = new Demo ( 100 , 22 ); Demo ob3 = new Demo ( - 1 , - 1 ); System . out . println ( \"ob1 == ob2: \" + ob1 . equalTo ( ob2 )); System . out . println ( \"ob1 == ob3: \" + ob1 . equalTo ( ob3 )); } } Eixida 1 2 obj1 == obj2 : true obj1 == obj3 : false Explicaci\u00f3 en imatges: 1. Es creen tres objectes: 1 2 3 Demo ob1 = new Demo ( 100 , 22 ); Demo ob2 = new Demo ( 100 , 22 ); Demo ob3 = new Demo ( - 1 , - 1 ); Des del costat de la funci\u00f3, es declara una refer\u00e8ncia de tipus Demo amb un objecte obj i s'assigna inicialment null. Com cridem al m\u00e8tode equalTo, la refer\u00e8ncia 'obj' s'assignar\u00e0 a l'objecte que es passa com a par\u00e0metre, \u00e9s a dir, 'obj' es referir\u00e0 a 'obj2' quan la seg\u00fcent sent\u00e8ncia s'execute. 1 System . out . println ( \"ob1 == ob2: \" + ob1 . equalTo ( ob2 )); Ara com podem observar, es crida al m\u00e8tode equalTo sobre 'obj1' i 'obj' fa refer\u00e8ncia a 'obj2'. Donat que els valors 'a' i 'b' s\u00f3n els mateixos per ambdues refer\u00e8ncies, aleshores si (condici\u00f3) \u00e9s veritat, aleshores tornar\u00e0 true. 1 if ( obj . a == a && obj . b == b ) De nou 'obj' es reassignar\u00e0 a 'ob3' quan s'executa la seg\u00fcent sent\u00e8ncia. 1 System . out . println ( \"ob1 == ob3: \" + ob1 . equalTo ( ob3 )); Ara, com podem observar, el m\u00e8tode equalTo es crida en 'ob1', i 'obj' fa refer\u00e8ncia a 'ob3'. Com que els valors 'a' i 'b' no s\u00f3n els mateixos per a les dues refer\u00e8ncies, aleshores torna false. Recursivitat En general, la recursivitat \u00e9s el proc\u00e9s de definir alguna cosa en termes de si mateix i \u00e9s una cosa semblant a una definici\u00f3 circular. El component clau d'un m\u00e8tode recursiu \u00e9s una declaraci\u00f3 que executa una crida a si mateix. La recursivitat \u00e9s un poder\u00f3s mecanisme de control. L'exemple cl\u00e0ssic de recursivitat \u00e9s el c\u00e0lcul de l'factorial d'un nombre. El factorial d'un nombre N \u00e9s el producte de tots els nombres enters que es trobin entre 1 i N. Per exemple, el factorial de 3 \u00e9s 1 \u00d7 2 \u00d7 3, \u00e9s a dir, \u00e9s de 6. El seg\u00fcent programa mostra una forma recursiva de calcular el factorial d'un nombre. Per a prop\u00f2sits de comparaci\u00f3, tamb\u00e9 s'inclou un equivalent no recursiu (iteratiu). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // Un simple programa de recursividad class Factorial { // Esto es un m\u00e9todo recursivo int facR ( int n ){ int resultado ; if ( n == 1 ) return 1 ; resultado = facR ( n - 1 ) * n ; return resultado ; } // Esto es un equivalente iterativo int facI ( int n ){ int t , resultado ; resultado = 1 ; for ( t = 1 ; t <= n ; t ++ ) resultado *= t ; return resultado ; } } class Recursividad { public static void main ( String [] args ) { Factorial f = new Factorial (); System . out . println ( \"Factorial utlitzant un m\u00e8tode recursiu:\" ); System . out . println ( \"El factorial de 3 \u00e9s: \" + f . facR ( 3 )); System . out . println ( \"El factorial de 6 \u00e9s: \" + f . facR ( 6 )); System . out . println (); System . out . println ( \"Factorial utilitzant un m\u00e8tode iteratiu:\" ); System . out . println ( \"El factorial de 3 \u00e9s: \" + f . facI ( 3 )); System . out . println ( \"El factorial de 6 \u00e9s: \" + f . facI ( 6 )); System . out . println (); } } Eixida 1 2 3 4 5 6 7 Factorial utilitzant un m\u00e8tode recursiu : El factorial de 3 \u00e9s : 6 El factorial de 6 \u00e9s : 720 Factorial utilitzant un m\u00e8tode iteratiu : El factorial de 3 \u00e9s : 6 El factorial de 6 \u00e9s : 720 Stack Overflow Les versions recursives de moltes rutines poden executar-se una mica m\u00e9s lentament que els seus equivalents iteratius causa de la sobrec\u00e0rrega addicional de les trucades a m\u00e8todes addicionals. Massa crides recursives a un m\u00e8tode podrien causar un desbordament de la pila. Com l'emmagatzematge per als par\u00e0metres i les variables locals est\u00e0 a la pila i cada trucada nova crea una nova c\u00f2pia d'aquestes variables, \u00e9s possible que la pila s 'ha esgotat. Si aix\u00f2 passa, el sistema de temps d'execuci\u00f3 (run-time) de Java causar\u00e0 una excepci\u00f3. No obstant aix\u00f2, probablement no haur\u00e0s de preocupar-te per aix\u00f2 a menys que una rutina recursiva es torni boja. El principal avantatge de la recursivitat \u00e9s que alguns tipus d'algoritmes es poden implementar de forma m\u00e9s clara i m\u00e9s recursiva del que poden ser iterativament. Per exemple, l'algorisme de classificaci\u00f3 Quicksort \u00e9s bastant dif\u00edcil d'implementar de manera iterativa. A m\u00e9s, alguns problemes, especialment els relacionats amb la IA, semblen prestar-se a solucions recursives. 1 2 3 4 5 6 7 8 int fact ( int n ) { // Condici\u00f3 de base equivocada (provoca Stack Overflow) if ( n == 100 ) return 1 ; else return n * fact ( n - 1 ); } En l'exemple anterior: Si es diu a fact (10), cridar\u00e0 a fac (9), fact (8), fact (7), etc., per\u00f2 el nombre mai arribar\u00e0 a 100. Per tant, no s'assoleix la condici\u00f3 base. Si la mem\u00f2ria s'esgota amb aquests m\u00e8todes en la pila, provocar\u00e0 un error de desbordament de pila. La API de Java L'API Java \u00e9s una interf\u00edcie de programaci\u00f3 d'aplicacions (API, per les seves sigles de l'angl\u00e8s: Application Programming Interface) prove\u00efda pels creadors de el llenguatge de programaci\u00f3 Java, que d\u00f3na als programadors els mitjans per desenvolupar aplicacions Java. Com el llenguatge Java \u00e9s un llenguatge orientat a objectes, l'API de Java proveeix d'un conjunt de classes utilit\u00e0ries per a efectuar tota mena de tasques necess\u00e0ries dins d'un programa. L'API Java est\u00e0 organitzada en paquets l\u00f2gics, on cada paquet cont\u00e9 un conjunt de classes relacionades sem\u00e0nticament.","title":"Tema 4. Programaci\u00f3 Modular"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#tema-4-programacio-modular","text":"","title":"Tema 4. Programaci\u00f3 Modular"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#introduccio","text":"La programaci\u00f3 modular \u00e9s un paradigma de programaci\u00f3 que consisteix a dividir un programa en m\u00f2duls o subprogrames per tal de fer-lo m\u00e9s llegible i manejable Es presenta hist\u00f2ricament com una evoluci\u00f3 de la programaci\u00f3 estructurada per solucionar problemes de programaci\u00f3 m\u00e9s grans i complexos del que aquesta pot resoldre. A l'aplicar la programaci\u00f3 modular, un problema complex ha de ser dividit en diversos subproblemes m\u00e9s simples, i aquests al seu torn en altres subproblemes m\u00e9s simples encara. Aix\u00f2 s'ha de fer fins a obtenir subproblemes prou simples com per poder ser resolts f\u00e0cilment amb algun llenguatge de programaci\u00f3. Aquesta t\u00e8cnica es diu refinament successiu, divideix i vencer\u00e0s o an\u00e0lisi descendent (Top-Down). Un 'm\u00f2dul' \u00e9s cadascuna de les parts d'un programa que resol un dels subproblemes en qu\u00e8 es divideix el problema complex original. Cadascun d'aquests m\u00f2duls t\u00e9 una tasca ben definida i alguns necessiten d'altres per poder operar. En cas que un m\u00f2dul necessiti d'un altre, pot comunicar-se amb aquest mitjan\u00e7ant una interf\u00edcie de comunicaci\u00f3 que tamb\u00e9 ha d'estar ben definida. Si b\u00e9 un m\u00f2dul es pot entendre com una part d'un programa en qualsevol de les seves formes i variats contextos, en la pr\u00e0ctica se'ls sol prendre com a sin\u00f2nims de procediments i funcions. Per\u00f2 no necess\u00e0ria ni estrictament un m\u00f2dul \u00e9s una funci\u00f3 o un procediment, ja que el mateix pot contenir molts d'ells. No s'ha de confondre el terme \"m\u00f2dul\" (en el sentit de programaci\u00f3 modular) amb termes com \"funci\u00f3\" o \"procediment\", propis de l'llenguatge que ho suporte.","title":"Introducci\u00f3"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#abstraccio","text":"L'abstracci\u00f3 \u00e9s la capacitat de, observada una realitat, quedar-se amb all\u00f2 important o essencial i obviar el detall. Aquest concepte ser\u00e0 un concepte b\u00e0sic en l'evoluci\u00f3 de la programaci\u00f3 estructurada i modular cap a la programaci\u00f3 orientada a objectes. Per exemple, per saber conduir un cotxe no necessite saber al detall el funcionament del seu motor sino on est\u00e0 l'accelerador, el fre i el volant. No hem de pensar mai en un programa com un tot sino com un conjunt de m\u00f2duls relacionats entre si on cada m\u00f2dul desenvolupa una tasca molt concreta independentment de la resta i que tots junts formen el programa o aplicaci\u00f3.","title":"Abstracci\u00f3"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#caracteristiques","text":"Es considera moudlaritat com la definici\u00f3 d'un programa com a conjunt de subprogrames (m\u00f2duls). Cada m\u00f2dul t\u00e9 una funci\u00f3 particular, \u00e9s semi-independent i tamb\u00e9 pot trobar-se en fitxers de codi distints. Avantatges El codi resultant \u00e9s m\u00e9s net i f\u00e0cil d'entendre. Permet la divisi\u00f3 del treball. Es pot provar de forma independent, millorant aix\u00ed la recerca i correcci\u00f3 d'errades. Facilita la definici\u00f3 de variables al crear diversos \u00e0mbits. Depenent del nivell de detall amb el que es tracten els m\u00f2duls, podem distindir tres tipus: - Llibreries - Classes - Funcions o m\u00e8todes Una funci\u00f3 \u00e9s un tro\u00e7 de codi que realitza una funci\u00f3 concreta i de vegades torna algun valor com a resultat.","title":"Caracter\u00edstiques"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#funcions-en-java","text":"Una funci\u00f3 en Java t\u00e9 la seg\u00fcent estructura: 1 2 3 4 5 6 7 8 [ acces ] [ modificador ] tipus nomFuncio ( [ tipus nomArgument , [ tipo nomArgument ] ... ] ) { /* * Bloque de instrucciones */ return valor ; } Tots aquells elements que estan entre claudators s\u00f3n opcionals On: - Acc\u00e9s: public, protected, private o package - Modificador: static o final - Tipo: int, boolean, float o qualsevol tipus predefinit per l'usuari. - nomFuncio: cadena alfanum\u00e8rica significativa que indique el que fa la funci\u00f3. - nomArgument: par\u00e0metres que se li passen a la funci\u00f3. Aquestos par\u00e0metres funcionaran com variables locals a la funci\u00f3.","title":"Funcions en Java"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#exemples","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Funci\u00f3 simple void diguesHola () { System . out . println ( \"Hola Mon\" ); } // Funci\u00f3 amb par\u00e0metres void sayMyName ( String strNom ) { System . out . println ( \"Hola Mon: \" + strNom ); } // Funci\u00f3 que torna algun valor String canviaNom ( String strNom ) { return strNom . reverse (); }","title":"Exemples"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#sobre-els-arguments","text":"Hi ha alguns detalls al respeecte dels arguments d'una funci\u00f3: - Una funci\u00f3 pot tindre una quantitat qualsevol de par\u00e0metres, \u00e9s a dir, poden tindre des de zero fins a un, dos, deu o cent par\u00e0metres. Normalment no sol passar de cinc m\u00e0xim. - Si la funci\u00f3 t\u00e9 m\u00e9s d'un par\u00e0metre cadascun d'ells ha d'anar separat per una coma. - Els arguments d'una funci\u00f3 tamb\u00e9 tenen un tipus i nom que els identifica. - El tipus dels arguments pot ser qualsevol i no ha de tindre relaci\u00f3 amb el tipus del m\u00e8tode. - Al rebre un argument res ens obliga a fer \u00fas d'aquest dins del m\u00e8tode. - Els par\u00e0metres poden passar-se per refer\u00e8ncia (es mantenen les modificacions que es facen dins del m\u00e8tode) o per valor (no afectarien les modificacions a l'element original).","title":"Sobre els arguments"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#sobre-el-return","text":"Has de tenir en compte dues coses importants amb la sent\u00e8ncia return: - Qualsevol instrucci\u00f3 que es trobe despr\u00e9s de l'execuci\u00f3 de return, NO ser\u00e0 executada. - \u00c9s com\u00fa trobar funcions amb m\u00faltiples sent\u00e8ncies return al seu codi, com per exemple en sentencies condicionals, per\u00f2 una vegada el codi execute una sent\u00e8ncia return all\u00f2 que vinga despr\u00e9s no s'executar\u00e0. - El tipus de valor que es torna en una funci\u00f3 ha de conicidir amb el tipus declarat a la funci\u00f3, \u00e9s a dir, si es declara int, el valor que ha de tornar ha de ser un nombre enter. - En el cas de les funcions que no tornen res (void), tamb\u00e9 conegues com a procediments, poden usar la sent\u00e8ncia return per\u00f2 sense cap valor i nom\u00e9s s'usaria per acabar amb l'execuci\u00f3 de la funci\u00f3.","title":"Sobre el return"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#crida-a-un-funcio","text":"Per tal de cridar una funci\u00f3 en Java s'ha de fer de la seg\u00fcent forma: 1 nombre ( [ valor , [ valor ] ... ] ); Una funci\u00f3 en Java es crida utilitzant el nom del m\u00e8tode i entre par\u00e9ntesis s'han de passar els par\u00e0metres que s'indica a la declaraci\u00f3 de la funci\u00f3. Aquestos par\u00e0metres que es passen han de coincidir en n\u00famero, si la declaraci\u00f3 del funci\u00f3 t\u00e9 3 par\u00e0metres s'hauran de passar tres par\u00e0metres, i tamb\u00e9 han de coincidir en el t\u00edtol. Per\u00f2 millor vegem un exemple:","title":"Crida a un funci\u00f3"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#funcions-declaracio-i-crida","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Declaraci\u00f3 de la funci\u00f3 holaMon void holaMon ( String strNom ) { System . out . println ( \"Hola: \" + strNom ); } // Declaraci\u00f3 del funci\u00f3 suma int suma ( int a , int b ) { int res = a + b ; return res ; } // Crida correcta a la funci\u00f3 holaMon holaMon ( \"Batiste\" ); // Crida incorrecta a la funci\u00f3 holaMon holaMon (); holaMon ( \"Batiste\" , \"Ceba\" ); // Crida correcta a suma int resultat = suma ( 10 , 5 ); suma ( 10 , 5 ); // Crides incorrectes. int resultat = suma (); suma (); int res = suma ( 10 , 3 , 10 ); Activitat 1 C\u00f2pia el codi anterior, executa'l i raona el que est\u00e0 passant. Modifica el codi per tal que funcione correctament i mostre un resultat per pantalla.","title":"Funcions: declaraci\u00f3 i crida"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#detalls-per-invocar-funcions","text":"No importa si es tracta d\u2019un m\u00e8tode en Java o d\u2019una funci\u00f3 o d\u2019un m\u00e8tode, nom\u00e9s els debats ocupen d\u2019enviar els par\u00e0metres de la forma correcta per invocar-los. El nombre ha de coincidir exactament al moment d\u2019invocar, \u00e9s l\u2019\u00fanica forma d\u2019identificar-lo.L\u2019ordenaci\u00f3 dels par\u00e0metres i el tipus ha de coincidir. Cal tindre cura en el moment d'enviar els par\u00e0metres, hem de fer-ho en el mateix ordre en que varen ser declarats i han de ser del mateix tipus. Cada par\u00e0metre enviat tamb\u00e9 va separat per comes. Si una funci\u00f3 no rep par\u00e0metres, simplement no posem res a l'interior de la par\u00e8ntesi, per\u00f2 sempre debem posar la par\u00e8ntesi. Invocar una funci\u00f3 sigue sentint una sent\u00e8ncia comuna i corrent en Java, aix\u00ed que ha de finalitzar amb ';' com sempre. El valor retornat per un m\u00e8tode o funci\u00f3 pot ser assignat a una variable del mateix tipus, per\u00f2 no podem fer aix\u00f2 amb un procediment, no es pot retornar valor alg\u00fa. Una funci\u00f3 pot llamar a una altra dins de s\u00ed mateixa o fins i tot pot ser enviada com a par\u00e0metre a una altra (mira el seg\u00fcent exemple).","title":"Detalls per invocar funcions"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#parametres-duna-funcio","text":"\u00c9s possible passar un o m\u00e9s valors a una funci\u00f3 quan es crida. Recordeu que un valor passat a una funci\u00f3 es diu argument . Dins la funci\u00f3, la variable que rep l'argument es diu par\u00e0metre . Els par\u00e0metres es declaren dins dels par\u00e8ntesis que segueixen a el nom de m\u00e8tode. La sintaxi de declaraci\u00f3 de par\u00e0metre \u00e9s la mateixa que la utilitzada per a les variables. Un par\u00e0metre est\u00e0 dins de l'abast de la seua funci\u00f3, i a banda de la seva tasca especial de rebre un argument, actua com qualsevol altra variable local. Ac\u00ed hi ha un exemple simple de l'\u00fas de par\u00e0metres. Dins de la classe ComprobarNumero, el m\u00e8tode Espar () retorna true si el valor que es passa \u00e9s parell. Retorna false en cas contrari. Per tant, Espar () t\u00e9 un tipus de retorn boole\u00e0. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Un exemple simple de l'\u00fas de param\u00e8tres class ComprovarNumero { // Retorna true si x es parell boolean esParell ( int x ){ if (( x % 2 ) == 0 ) return true ; else return false ; } } class ParametroDemo { public static void main ( String [] args ) { ComprobarNumero e = new ComprobarNumero (); if ( e . esPar ( 10 )) System . out . println ( \"10 es par.\" ); if ( e . esPar ( 9 )) System . out . println ( \"9 es par.\" ); if ( e . esPar ( 8 )) System . out . println ( \"8 es par.\" ); } } Activitat 2 Passa el codi anterior a Processing i executa'l. Un m\u00e8tode pot tenir m\u00e9s d'un par\u00e0metre. Simplement declare cada par\u00e0metre, separant un el seg\u00fcent amb una coma. Per exemple, la classe Divisor defineix un m\u00e8tode anomenat esDivisor () que determina si el primer par\u00e0metre \u00e9s divisor de el segon. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Un exemple sempre de l'\u00fas de param\u00e8tres class Divisor { boolean esDivisor ( int a , int b ){ if (( b % a ) == 0 ) return true ; else return false ; } } class DivisorDemo { public static void main ( String [] args ) { Divisor x = new Divisor (); if ( x . esDivisor ( 2 , 20 )) System . out . println ( \"2 es Divisor de 20\" ); if ( x . esDivisor ( 3 , 20 )) System . out . println ( \"3 es Divisor de 20\" ); } } Depenent del tipus de dada que enviem a la funci\u00f3 com a argument, podem diferenciar dos comportaments: Pas per valor: Es crea una c\u00f2pia local de la variable dins de la funci\u00f3. Pas per refer\u00e8ncia: Es maneja directament la variable, els canvis realitzats dins de la funci\u00f3 li afectaran tamb\u00e9 fora. Activitat 3 Passa el seg\u00fcent codi a processing, executa'l i raona el que est\u00e0 passant. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void setup () { size ( 320 , 240 ); int i = 10 ; int [] array = new int [ 10 ] ; for ( int a = 0 ; a < i ; a ++ ) array [ a ] = 0 ; System . out . println ( \"Abans de la cirda a la funci\u00f3:\" ); System . out . println ( \"i=\" + i ); System . out . println ( \"array[5]=\" + array [ 5 ] ); funcio ( i , array ); System . out . println ( \"Despr\u00e9s de la cirda a la funci\u00f3:\" ); System . out . println ( \"i=\" + i ); System . out . println ( \"array[5]=\" + array [ 5 ] ); } void draw () { delay ( 10000 ); } void funcio ( int i , int [] array ) { i = 5 ; array [ i ] = 5 ; } Activitat 4 Escriu el seg\u00fcent codi en Processing i executa'l 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // Variables globals int x , y ; void setup () { size ( 320 , 240 ); x = 150 ; y = 120 ; } void draw () { background ( 255 ); stroke ( 0 ); // Dibuixem la cara cercle strokeWeight ( 2 ); fill ( 255 , 255 , 0 ); circle ( x , y , 100 ); // Dibuixem ulls strokeWeight ( 2 ); fill ( 255 ); circle ( 130 , 110 , 20 ); circle ( 165 , 110 , 20 ); strokeWeight ( 5 ); point ( 133 , 110 ); point ( 168 , 110 ); // Dibuixem la boca noFill (); strokeWeight ( 2 ); arc ( 150 , 135 , 40 , 30 , 0 , PI ); Aquest codi mostra el seg\u00fcent dibuix Activitat 5. Divideix-lo en funcions. Separa el codi en funcions, has d'afegir les funcions dibuixaUlls i dibuixaBoca seguint els prototips que et mostre a continuaci\u00f3. 1 2 3 // Prototips de funcions void dibuixaUlls (); void dibuixaBoca (); Activitat 6. Par\u00e0metres coordenades. Modifica el codi anterior per tal que tant el codi que dibuixa els ulls com el codi que dibuixa la boca, estiguen en dues funcions: dibuixaUlls i dibuixaBoca. A aquestes funcions se'ls passar\u00e0 com a par\u00e0metres les coordenads x i y i a partir d'aquestes ha de dibuixar els ulls i la boca on corresponga. 1 2 3 // Prototips de les funcions void dibuixaUlls ( int x , int y ); void dibuixaBoca ( int x , int y ); Activitat 7 Amplia el codi anterior per tal que mostre el seg\u00fcent dibuix. Observa com ha de quedar el codi de la funci\u00f3 draw 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // Variables Globals int cercleX , cercleY , triangleX , triangleY , quadratX , quadratY ; void setup () { size ( 640 , 300 ); // Coordenades del cercle cercleX = 150 ; cercleY = 150 ; // Coordenades del primer punt del triangle triangleX = 250 ; triangleY = 200 ; // Coordenades del quadrat quadratX = 445 ; quadratY = 100 ; } void draw () { background ( 255 ); // Codi per dibuixar el cercle // Escriu el codi necessari per dibuixar el cercle a cercleX i cercleY dibuixaUlls ( cercleX , cercleY ); dibuixaBoca ( cercleX , cercleY ); // Codi per dibuixar el triangle // Escriu el codi necessari per dibuixar el cercle a triangleX i triangleY dibuixaUlls ( triangleX , triangleY ); dibuixaBoca ( triangleX , triangleY ); // Codi per dibuixar el quadrat // Escriu el codi necessari per dibuixar el cercle a quadratX i quadratY dibuixaUlls ( quadratX , quadratY ); dibuixaBoca ( quadratX , quadratY ); } Activitat 8. Dibuixar pe\u00e7a domino. Emplena el codi de la funci\u00f3 dibuixaDomino(int,int) per tal que mostre la imatge seg\u00fcent. 1 2 3 4 5 6 7 8 9 10 void setup () { size ( 640 , 480 ); } void draw () { dibuixaDomino ( 5 , 4 ); } void dibuixaDomino ( int a , int b ) { // Codi per dibuixar la pe\u00e7a de domin\u00f3 amb la puntuaci\u00f3 que es passa per par\u00e0metre. } Activitat 9 Qu\u00e8 passa si en lloc de 5 i 4 pasarem 6 i 6 per par\u00e0metre? Dibuixa el que esperes que dibuixe? Fes les modficacions necess\u00e0ries al codi per tal que funcione com s'espera. Ampliaci\u00f3: fes que el teu algorisme mostre totes les peces del domin\u00f3 ordenades en files i columnes.","title":"Par\u00e0metres d'una funci\u00f3"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#pas-dobjectes-a-funcions","text":"Quan passem un tipus primitiu a una funci\u00f3, es passa per valor. Per\u00f2 quan vam passar un objecte a una funci\u00f3, la situaci\u00f3 canvia dr\u00e0sticament, perqu\u00e8 els objectes es passen pel que efectivament \u00e9s anomenat, per refer\u00e8ncia . Java fa aquesta cosa interessant que \u00e9s una classe d'h\u00edbrid entre passar per valor i passar per refer\u00e8ncia. B\u00e0sicament, la funci\u00f3 no pot canviar un par\u00e0metre, per\u00f2 la funci\u00f3 pot demanar-li a l'par\u00e0metre que es canvi\u00ef a si mateix cridant a algun m\u00e8tode dins d'ell. A l'crear una variable d'un tipus de classe (un objecte), nom\u00e9s vam crear una refer\u00e8ncia a un objecte. Per tant, quan passem aquesta refer\u00e8ncia a un m\u00e8tode, el par\u00e0metre que el rep es referir\u00e0 a el mateix objecte que el referit per l'argument. Aix\u00f2 vol dir efectivament que els objectes actuen com si es passessin als m\u00e8todes mitjan\u00e7ant l'\u00fas de trucada per refer\u00e8ncia. Els canvis en l'objecte dins el m\u00e8tode es reflecteixen en l'objecte utilitzat com a argument. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // Programa Java per demostrar el pas d'objectes a funcions class Demo { int a , b ; Demo ( int i , int j ) { a = i ; b = j ; } // Torna true si els valors s\u00f3n els mateixos boolean equalTo ( Demo obj ) { return ( obj . a == a && obj . b == b ); } } public class Test { public static void main ( String args [] ) { Demo ob1 = new Demo ( 100 , 22 ); Demo ob2 = new Demo ( 100 , 22 ); Demo ob3 = new Demo ( - 1 , - 1 ); System . out . println ( \"ob1 == ob2: \" + ob1 . equalTo ( ob2 )); System . out . println ( \"ob1 == ob3: \" + ob1 . equalTo ( ob3 )); } } Eixida 1 2 obj1 == obj2 : true obj1 == obj3 : false Explicaci\u00f3 en imatges: 1. Es creen tres objectes: 1 2 3 Demo ob1 = new Demo ( 100 , 22 ); Demo ob2 = new Demo ( 100 , 22 ); Demo ob3 = new Demo ( - 1 , - 1 ); Des del costat de la funci\u00f3, es declara una refer\u00e8ncia de tipus Demo amb un objecte obj i s'assigna inicialment null. Com cridem al m\u00e8tode equalTo, la refer\u00e8ncia 'obj' s'assignar\u00e0 a l'objecte que es passa com a par\u00e0metre, \u00e9s a dir, 'obj' es referir\u00e0 a 'obj2' quan la seg\u00fcent sent\u00e8ncia s'execute. 1 System . out . println ( \"ob1 == ob2: \" + ob1 . equalTo ( ob2 )); Ara com podem observar, es crida al m\u00e8tode equalTo sobre 'obj1' i 'obj' fa refer\u00e8ncia a 'obj2'. Donat que els valors 'a' i 'b' s\u00f3n els mateixos per ambdues refer\u00e8ncies, aleshores si (condici\u00f3) \u00e9s veritat, aleshores tornar\u00e0 true. 1 if ( obj . a == a && obj . b == b ) De nou 'obj' es reassignar\u00e0 a 'ob3' quan s'executa la seg\u00fcent sent\u00e8ncia. 1 System . out . println ( \"ob1 == ob3: \" + ob1 . equalTo ( ob3 )); Ara, com podem observar, el m\u00e8tode equalTo es crida en 'ob1', i 'obj' fa refer\u00e8ncia a 'ob3'. Com que els valors 'a' i 'b' no s\u00f3n els mateixos per a les dues refer\u00e8ncies, aleshores torna false.","title":"Pas d'objectes a funcions"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#recursivitat","text":"En general, la recursivitat \u00e9s el proc\u00e9s de definir alguna cosa en termes de si mateix i \u00e9s una cosa semblant a una definici\u00f3 circular. El component clau d'un m\u00e8tode recursiu \u00e9s una declaraci\u00f3 que executa una crida a si mateix. La recursivitat \u00e9s un poder\u00f3s mecanisme de control. L'exemple cl\u00e0ssic de recursivitat \u00e9s el c\u00e0lcul de l'factorial d'un nombre. El factorial d'un nombre N \u00e9s el producte de tots els nombres enters que es trobin entre 1 i N. Per exemple, el factorial de 3 \u00e9s 1 \u00d7 2 \u00d7 3, \u00e9s a dir, \u00e9s de 6. El seg\u00fcent programa mostra una forma recursiva de calcular el factorial d'un nombre. Per a prop\u00f2sits de comparaci\u00f3, tamb\u00e9 s'inclou un equivalent no recursiu (iteratiu). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // Un simple programa de recursividad class Factorial { // Esto es un m\u00e9todo recursivo int facR ( int n ){ int resultado ; if ( n == 1 ) return 1 ; resultado = facR ( n - 1 ) * n ; return resultado ; } // Esto es un equivalente iterativo int facI ( int n ){ int t , resultado ; resultado = 1 ; for ( t = 1 ; t <= n ; t ++ ) resultado *= t ; return resultado ; } } class Recursividad { public static void main ( String [] args ) { Factorial f = new Factorial (); System . out . println ( \"Factorial utlitzant un m\u00e8tode recursiu:\" ); System . out . println ( \"El factorial de 3 \u00e9s: \" + f . facR ( 3 )); System . out . println ( \"El factorial de 6 \u00e9s: \" + f . facR ( 6 )); System . out . println (); System . out . println ( \"Factorial utilitzant un m\u00e8tode iteratiu:\" ); System . out . println ( \"El factorial de 3 \u00e9s: \" + f . facI ( 3 )); System . out . println ( \"El factorial de 6 \u00e9s: \" + f . facI ( 6 )); System . out . println (); } } Eixida 1 2 3 4 5 6 7 Factorial utilitzant un m\u00e8tode recursiu : El factorial de 3 \u00e9s : 6 El factorial de 6 \u00e9s : 720 Factorial utilitzant un m\u00e8tode iteratiu : El factorial de 3 \u00e9s : 6 El factorial de 6 \u00e9s : 720","title":"Recursivitat"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#stack-overflow","text":"Les versions recursives de moltes rutines poden executar-se una mica m\u00e9s lentament que els seus equivalents iteratius causa de la sobrec\u00e0rrega addicional de les trucades a m\u00e8todes addicionals. Massa crides recursives a un m\u00e8tode podrien causar un desbordament de la pila. Com l'emmagatzematge per als par\u00e0metres i les variables locals est\u00e0 a la pila i cada trucada nova crea una nova c\u00f2pia d'aquestes variables, \u00e9s possible que la pila s 'ha esgotat. Si aix\u00f2 passa, el sistema de temps d'execuci\u00f3 (run-time) de Java causar\u00e0 una excepci\u00f3. No obstant aix\u00f2, probablement no haur\u00e0s de preocupar-te per aix\u00f2 a menys que una rutina recursiva es torni boja. El principal avantatge de la recursivitat \u00e9s que alguns tipus d'algoritmes es poden implementar de forma m\u00e9s clara i m\u00e9s recursiva del que poden ser iterativament. Per exemple, l'algorisme de classificaci\u00f3 Quicksort \u00e9s bastant dif\u00edcil d'implementar de manera iterativa. A m\u00e9s, alguns problemes, especialment els relacionats amb la IA, semblen prestar-se a solucions recursives. 1 2 3 4 5 6 7 8 int fact ( int n ) { // Condici\u00f3 de base equivocada (provoca Stack Overflow) if ( n == 100 ) return 1 ; else return n * fact ( n - 1 ); } En l'exemple anterior: Si es diu a fact (10), cridar\u00e0 a fac (9), fact (8), fact (7), etc., per\u00f2 el nombre mai arribar\u00e0 a 100. Per tant, no s'assoleix la condici\u00f3 base. Si la mem\u00f2ria s'esgota amb aquests m\u00e8todes en la pila, provocar\u00e0 un error de desbordament de pila.","title":"Stack Overflow"},{"location":"Tema%2004.%20Programaci%C3%B3%20Modular/#la-api-de-java","text":"L'API Java \u00e9s una interf\u00edcie de programaci\u00f3 d'aplicacions (API, per les seves sigles de l'angl\u00e8s: Application Programming Interface) prove\u00efda pels creadors de el llenguatge de programaci\u00f3 Java, que d\u00f3na als programadors els mitjans per desenvolupar aplicacions Java. Com el llenguatge Java \u00e9s un llenguatge orientat a objectes, l'API de Java proveeix d'un conjunt de classes utilit\u00e0ries per a efectuar tota mena de tasques necess\u00e0ries dins d'un programa. L'API Java est\u00e0 organitzada en paquets l\u00f2gics, on cada paquet cont\u00e9 un conjunt de classes relacionades sem\u00e0nticament.","title":"La API de Java"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/","text":"Tema 5. Tipus Compostos de Dades Introducci\u00f3 Fins ara hav\u00edem treballat amb tipus de dades simples: int, char, double, float, bool... per\u00f2 que passa si necessitarem guardar informaci\u00f3 relativa a una persona? Nom, cognoms, DNI, adre\u00e7a postal, data de naixement etc.. Amb els tipus de dades simples ens seria impossible representar aquesta informaci\u00f3. Es per aix\u00f2 que s\u2019utilitzen els tipus de dades compostos que ens permetran agrupar de diverses maneres aquesta informaci\u00f3. En aquest tema veurem: arrays, cadenes de car\u00e0cters, estructures i enumeracions. Per tal de fer les activitats d\u2019aquest tema es necessitar\u00e0 de la implementaci\u00f3 d\u2019una classe a la que anomenarem TAD que tindr\u00e0 les seg\u00fcents caracter\u00edstiques: - Classe p\u00fablica - Membres de la classe: arrayN\u00fameros i arrayCaracters - M\u00e8todes de la classe: recercaBinaria, recercaSequencial, ordenarInserci\u00f3, ordenarBombolla, ordenarShell, ordernarQuickSort De moment amb a\u00e7\u00f2 ser\u00e0 suficient, en apartats posteriors anirem afegint m\u00e9s membres i m\u00e8todes quan ho necessitem. Activitat 1 Crea la classe \u2018TAD\u2019 amb l\u2019IDE que sols utilitzar basada en les seg\u00fcents especificacions: - Ha de ser una classe p\u00fablica - Ha de tindre m\u00ednim una constant que ens indicar\u00e0 el total d\u2019elements que tindran els arrays, tant el d\u2019enters com el de car\u00e0cters. - Com membres de la classe ha de tindre almenys un array de car\u00e0cters i un d\u2019enters. Han de ser privats o p\u00fablics? - Tamb\u00e9 ha de tenir un m\u00e8tode main static on s\u2019iniciar\u00e0 el programa. Arrays Un array \u00e9s un tipus de dades compost que permet emmagatzemar un nombre x d\u2019elements del mateix tipus. Amb una \u00fanica declaraci\u00f3 podem tenir acc\u00e9s a un conjunt de valors agrupats. Aquestes agrupacions o arrays poden b\u00e9 ser de tipus simples o tamb\u00e9 de tipus compostos. Per tal d\u2019accedir a cadascun dels elements del array s\u2019utilitza un \u00edndex o posici\u00f3. La primera posici\u00f3 de tot array \u00e9s la 0 mentre que la segona seria la que t\u00e9 \u00edndex 1. A\u00e7\u00f2 pot marejar un poc al principi. Array d\u2019enters: {8,2,14,55,3,7} Array de car\u00e0cters: {\u2018n\u2019,\u2019a\u2019,\u2019t\u2019,\u2019o\u2019} \u00c9s molt important distingir entre valor i posici\u00f3. Mentre que el valor \u00e9s el contingut de l\u2019array en una posici\u00f3 determinada la posici\u00f3 \u00e9s l\u2019\u00edndex que ens permet recorres l\u2019array i tot el seu contingut. A l\u2019exemple anterior tenim un array de 8 enters, la part superior de color blau ens indica les posicions que van de la 0 a la 7, 8 posicions ens total. Mentre que a la fila inferior trobarem el valor que cont\u00e9 cadascuna de les posicions. Per exemple en la posici\u00f3 5 (la sisena) de l\u2019array tindr\u00edem emmagatzemat un valor de 8. Un altre concepte a tenir en compte \u00e9s la dimensi\u00f3 o grand\u00e0ria de l\u2019array que ens determina el total d\u2019elements que es poden guardar en aquest. En el nostre cas la mida seria de 8. Declaraci\u00f3 i creaci\u00f3 d'un array en Java Un array en Java \u00e9s una estructura de dades que ens permet emmagatzemar un conjunt de dades del mateix tipus. El grand\u00e0ria de l\u2019array es determina en la seua declaraci\u00f3 i no es permet la seua modificaci\u00f3 posterior 1 2 tipusBase nomArray [] ; nomArray = new tipusBase [ grand\u00e0ria ] ; Alguns exemples: 1 2 3 4 int mes [] ; mes = new int [ 30 ] ; char grups [] ; grups = new char [ 5 ] ; Aquesta forme de declarar i inicialitzar arrays es pot fer en una sola l\u00ednia de la seg\u00fcent forma: 1 int agendaMensual = new int [ 30 ] ; Inicialitzaci\u00f3 d'un array Per tal d\u2019accedir a les dades que cont\u00e9 un array necessitem l\u2019identificador d\u2019aquest aix\u00ed com tamb\u00e9 la posici\u00f3 concreta a la qual volem accedir. Per exemple, imaginem un array d\u2019enters que es diu n\u00fameros. 1 2 int n\u00fameros . = new int [ 5 ] ; // Declarem un array n\u00fameros . [] = { 2 , 4 , 6 , 8 , 10 }; // Inicialitzaci\u00f3 de valors D\u2019aquesta forma haur\u00edem creat un array de 5 enters que contindria els nombres parells fins al 10. Activitat 2 En aquest punt aprofitarem per crear un constructor a la nostra classe TAD. Un constructor de classe \u00e9s la funci\u00f3 que s\u2019executa en el moment que s\u2019instancia un objecte i \u00e9s en aquest punt on s\u2019haurien d'inicialitzar aquells elements de la classe que ho necessiten. En el nostre cas els arrays. Inicialitza l\u2019arrayNumeros amb 10 n\u00fameros aleatoris usant la funci\u00f3 rand. Fes el mateix per\u00f2 amb car\u00e0cters amb el nostre arrayCaracters. Recorda que els arrays s\u00f3n membres de la classe. Acc\u00e9s als elements d'un array Una vegada ja tenim la declaraci\u00f3 de l\u2019array i la seua inicialitzaci\u00f3, si volem b\u00e9 accedir al seu contingut o modificar-ho, necessitar\u00edem l\u2019identificador de l\u2019array i l\u2019\u00edndex al qual volem accedir. \u00c9s molt important tenir en compte que el primer element d\u2019un array en Java est\u00e0 a la posici\u00f3 (\u00edndex) 0 i no a la posici\u00f3 1 com ens indicaria la l\u00f2gica. 1 2 int primerNumero = n\u00fameros . [ 0 ] ; // primerNumero valdria 2 n\u00fameros . [ 0 ] = 12 ; // Canviem el primer numero de l\u2019array Arrays de caracters Un array que cont\u00e9 car\u00e0cters en lloc de n\u00fameros funciona d\u2019una forma molt semblant al que s\u2019ha explicat en els apartats anteriors. Es pot veure de forma senzilla a l\u2019exemple que vos mostrem a continuaci\u00f3. 1 2 3 char vocals = new char [ 5 ] ; // Declaraci\u00f3 de l\u2019array vocals [] = { \u2018 a \u2019 , \u2019 e \u2019 , \u2019 i \u2019 , \u2019 o \u2019 , \u2019 u \u2019 } // Inicialitzaci\u00f3 vocals [ 0 ] = \u2018 z \u2019 ; // Acc\u00e9s als elements de l\u2019array Arrays com a par\u00e0metres Com qualsevol altre tipus de dades, un array tamb\u00e9 es pot passar com a par\u00e0metre a un m\u00e8tode. Els arrays sempre es passen per refer\u00e8ncia, \u00e9s a dir, quan passem un array per par\u00e0metre a un m\u00e8tode, el que en realitat estem passant \u00e9s un adre\u00e7a de mem\u00f2ria que \u00e9s la que ens indicaria on est\u00e0 l\u2019inici del contingut d\u2019aquest. Passar per refer\u00e8ncia qualsevol par\u00e0metre significa que qualsevol modificaci\u00f3 que es faja dins del m\u00e8tode afectar\u00e0 tamb\u00e9 a l\u2019array fora d\u2019aquest. No passa el mateix si passem un element concret de l\u2019array, en aquest cas a l\u2019igual que amb els altres par\u00e0metres, aquestos es passen per valor, per tant les modificacions o canvis que es produeixquen dins del m\u00e8tode no afectaran fora d\u2019aquest. Activitat 3. Fes dos m\u00e8todes per la nostra classe que mostre, de forma amigable, l\u2019array de n\u00fameros i l\u2019array de car\u00e0cters. Els m\u00e8todes es podrien dir mostraEnters i mostraCaracters i seran privats. 1 2 3 4 5 6 7 private void mostraEnters () { // Codi per mostrar el vector d'enters } private void mostraCaracters () { // Codi per mostrar el vector de caracters } Activitat 4. En la seg\u00fcent activitat afegirem una funci\u00f3 a la nostra classe en la que ens mostre un men\u00fa de les accions que podem realitzar. Per tal de realitzar aquest men\u00fa afegirem un array d\u2019strings com a nou membre de la classe que inicialitzarem amb les seg\u00fcents opcions: Mostrar array enters Mostrar array caracters Reinicialitzar vectors Recerca seq\u00fcencial Recerca bin\u00e0ria Ordenar amb bombolla Ordenar amb Quicksort Ordenar amb Shell Bucle for en Java Per tal de rec\u00f3rrer arrays podem usar bucles for o while per\u00f2 aquests solen tindre l\u2019inconvenient de que \u00e9s el programador el que ha de controlar quan s\u2019arriba al final de l\u2019array per tal que l\u2019aplicaci\u00f3 no done una errada inesperada i aix\u00f2 de vegades no \u00e9s senzill. La millor forma de rec\u00f3rrer un array sense haver de controlar quan s\u2019arriba al final \u00e9s la sent\u00e8ncia for usada d\u2019una manera alternativa. Si per exemple tenim un array d\u2019enters que s\u2019anomena \u00abvector\u00bb i volem llistar tots els seus elements, podr\u00edem fer el seg\u00fcent: 1 2 3 for ( int i : vector ){ // Accions a realitzar } Activitat 5. Fes una funci\u00f3 que mostre per pantalla el men\u00fa per\u00f2 esta vegada utilitzant el for com hem explicat a l\u2019exemple anterior. Algorismes de recerca Existeixen dos algorismes de recerca que veurem en aquest apartat: la recerca seq\u00fcencial i la recerca binaria. A l\u2019element que estem buscant li direm clau. Seq\u00fcencial Tamb\u00e9 anomenada recerca lineal, es recorren tots els elements de l\u2019array des del principi fins que es troba la clau (element que estem buscant) o fins que s\u2019arriba a l\u2019\u00faltim element de l\u2019array. 1 2 3 4 5 6 int sequencial ( int [] array , int clau ) { for ( int i = 0 ; i < array . length ; i ++ ) if ( array [ i ] == clau ) return i ; return - 1 ; } Bin\u00e0ria En aquest algoritme existeix la precondici\u00f3 que l\u2019array o vector sobre el qual vaja a fer-se la recerca, ha d\u2019estar ordenat. Aquest m\u00e8tode \u00e9s m\u00e9s \u00f2ptim. El funcionament d\u2019aquest algorisme \u00e9s el seg\u00fcent: en una primera iteraci\u00f3 es compara la clau (element que estem buscant) amb el valor al centre, que s\u2019anomena pivot, de l\u2019array. Poden passar tres coses: - Que hajam trobat el que busquem, per tant s\u2019acaba la recerca - Que el pivot siga major que la clau. En aquest cas continuar\u00edem buscant a la meitat esquerra del vector desestimant la meitat dreta (pivot incl\u00f2s) - Que el pivot siga menor que la clau. Amb la qual cosa haur\u00edem de buscar a la part esquerra del vector. Activitat 6. Afegeix el m\u00e8tode de recerca seq\u00fcencial i el de recerca binaria a la classe TAD. Tamb\u00e9 has d\u2019implementar el codi necessari per tal que quan l\u2019usuari seleccione una de les dues opcions de la nostra aplicaci\u00f3, demane el n\u00famero a buscar i mostre el resultat per pantalla. En cas que es seleccione la recerca bin\u00e0ria, haur\u00edem de comprovar si el vector est\u00e0 ordenat 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int recercaBinaria ( int array [] , int clau ) { int posCentre , posInici , posFinal , valorCentral ; posInici = 0 ; posFinal = array . length \u2013 1 ; while ( posInici <= posFinal ) { posCentre = ( posInici + posFinal ) / 2 ; valorCentral = array [ posCentre ] ; if ( clau == valorCentral ) { return posCentre ; } else if ( clau < valorCentral ) { posFinal = posCentro \u2013 1 ; } else { posInici = posCentro + 1 ; } } } Activitat 7. Comparem l\u2019efici\u00e8ncia dels dos algorismes de recerca vistos. Fes una funci\u00f3 a la nostra classe TAD en la que es compten el total de vegades que s\u2019accedeix l\u2019array de n\u00fameros per arribar a trobar la clau. Haur\u00e0s de posar una opci\u00f3 m\u00e9s al men\u00fa, per exemple: \u00abComparar efici\u00e8ncia dels algoritmes\u00bb. Aquesta nova opci\u00f3 haur\u00e0 d\u2019executar varies vegades els dos algorismes de recerca amb vectors de n\u00fameros diferents. Algorismes d'ordenaci\u00f3 Els algorismes d\u2019ordenaci\u00f3 permeten ordenar un array en funci\u00f3 d\u2019un criteri establert al propi algorisme. Hi han diferents tipus d\u2019algorismes d\u2019ordenaci\u00f3: selecci\u00f3, inserci\u00f3, bombolla, Shell i Quicksort. Selecci\u00f3 El procediment d\u2019ordenaci\u00f3 per selecci\u00f3 \u00e9s el seg\u00fcent: 1. Busquem l\u2019element m\u00e9s menut de l\u2019array i el col\u00b7loquem a la posici\u00f3 0 intercanviant els dos elements 2. A partir de la posici\u00f3 1 busquem l\u2019element m\u00e9s menut seg\u00fcent i fem el mateix que al pas anterior per\u00f2 aquesta vegada a la posici\u00f3 1 de l\u2019array 3. Repetim el pas 2 fins arribar a l\u2019\u00faltima posici\u00f3 de l\u2019array. Activitat 8. Implementa l\u2019algorisme d\u2019ordenaci\u00f3 per selecci\u00f3 a la classe TAD i vicula-la a l\u2019opci\u00f3 del men\u00fa corresponent. Inserci\u00f3 Aquest algorisme consisteix en generar un nou array a partir del que ja es t\u00e9, tal que cada nou element inserit es posa a la seua posici\u00f3 correcta. Imaginem que tenim el seg\u00fcent array d\u2019enters per ordenar: {12, 5, 3, 13, 2, 9, 7} Generem un nou array amb el primer element de l\u2019array a ordenar { 12 } El seg\u00fcent valor de l\u2019array original \u00e9s 5. \u00c9s major o menor que el que ja est\u00e0 inserit? Com que la resposta \u00e9s menor, aquest s\u2019haur\u00e0 d\u2019inserir abans quedant de la seg\u00fcent forma: { 5 , 12} El nou array es genera ja ordenat. El seg\u00fcent valor de l\u2019array desordenat \u00e9s 3. On l\u2019haurem de col\u00b7locar? Just abans del 5 quedant aix\u00ed: { 3 , 5, 12} Repetim la mateixa operaci\u00f3 per cada element de l\u2019array original: {3, 5, 12, 13 } { 2 , 3, 5, 12, 13} {2, 3, 5, 9 , 12, 13} {2, 3, 5, 7 , 9, 12, 13} 1 2 3 4 5 6 7 8 9 10 11 12 void insercio ( int [] array ) { int i , j , aux ; for ( i = 1 ; i < array . legnth ; i ++ ) { j = i ; aux = array [ i ] ; while ( j > 0 && aux < array [ j - 1 ] ) { array [ j ] = array [ j - 1 ] ; j -- ; } array [ j ] = aux ; } } Activitat 9. Implementa l\u2019algorisme d\u2019ordenaci\u00f3 per inserci\u00f3 a la classe TAD i vincula-la a l\u2019opci\u00f3 del men\u00fa corresponent. Bombolla L\u2019algorisme d\u2019ordenaci\u00f3 per bombolla \u00e9s el m\u00e9s conegut i tamb\u00e9 el menys eficient, ja que a cada passada per ordenar un element compara cadascun d\u2019ells amb el seu adjacent de forma que si les seues posicions s\u00f3n incorrectes, s\u2019intercanvien. Al finalitzar cada passada l\u2019element m\u00e9s gran es va posant al final de la llista Donat el seg\u00fcent array: {12, 5, 3, 13, 2, 9, 7} Pas 1. Comparem les posicions 0 i 1, \u00e9s a dir, 12 i 5 i com que estan desordenats (el primer \u00e9s major que el segon), s\u2019intercanvien. { 5 , 12 , 3, 13, 2, 9, 7} Pas 2. A continuaci\u00f3 comparem les posicions 1 i 2 de l\u2019array, que s\u00f3n 12 i 3. Com que tamb\u00e9 estan desordenades, les intercanviem {5, 3 , 12 , 13, 2, 9, 7} Pas 3. Ara anem a comparar les posicions 2 i 3 que contenen els valors 12 i 13 respectivament. Com que estan ben ordenades no es realitza cap acci\u00f3: Pas 4. Posicions 3 i 4 que s\u00f3n 13 i 2. Les intercanviem. {5, 3, 12 , 2, 13 , 9, 7} Pas 5. Posicions 4 i 5 que tamb\u00e9 estan desordenades per tant executem l\u2019intercanviem {5, 3, 12, 2, 9 , 13 , 7} Pas 6. Comparem posicions 5 i 6 que tenen els valors 13 i 7 i s\u2019han d\u2019intercanviar {5, 3, 13, 2, 9, 7 , 13 } Una vegada finalitzada la primera passada hem aconseguit que l\u2019element major de l\u2019array estiga posicionat a l\u2019\u00faltima posici\u00f3. A la seg\u00fcent passada recorrerem l\u2019array fins la posici\u00f3 anterior a on es troba ara el n\u00famero 13, \u00e9s a dir la posici\u00f3 5 i aquest procediment es repeteix fins arribar a la posici\u00f3 0 Finalment el codi quedaria aix\u00ed: 1 2 3 4 5 6 7 8 9 10 11 void bombolla ( int [] arrayNumeros ) { for ( int i = 0 ; i < arrayNumeros . length - 1 ; i ++ ) { for ( int j = i + 1 ; j < arrayNumeros . length ; j ++ ) { if ( arrayNumeros [ i ] > arrayNumeros [ j ] ) { int canvi = arrayNumeros [ i ] ; arrayNumeros [ i ] = arrayNumeros [ j ] ; arrayNumeros [ j ] = canvi ; } } } } Activitat 10. Implementa l\u2019algorisme d\u2019ordenaci\u00f3 per bombolla a la classe TAD i vincula-la a l\u2019opci\u00f3 del men\u00fa corresponent. Shell L\u2019algorisme Shell \u00e9s una millora de l\u2019algorisme d\u2019inserci\u00f3 directa. Compara elements separats per un espai de v\u00e0ries posicions el que permet que un element faja passos m\u00e9s grans fins trobar la seua posici\u00f3 esperada. Els passos m\u00faltiples sobre els elements de l\u2019array es fan amb espais de posicions cada vegada m\u00e9s menuts. L\u2019\u00faltim pas de l\u2019algorisme Shell \u00e9s una simple ordenaci\u00f3 per inserci\u00f3 per\u00f2 arribats a aquest punt es pot garantir que l\u2019array esta ja quasi ordenat, el que fa que l\u2019ordenaci\u00f3 per inserci\u00f3 siga molt eficient. Vegem com actuaria aquest algorisme aplicat sobre l\u2019array que estem utilitzant com exemple: {12, 5, 3, 13, 2, 9, 7}. Aquest array t\u00e9 un total de 7 elements (n=7). Creem n/2 grups, separats n/2 n\u00fameros entre ells. n/2=7/2=3, \u00e9s a dir, el nostre interval per crear grups val 3 Marquem en negreta els valors de la primera subllista. {12, 5, 3, 13, 2, 9, 7} Donats els elements 12, 13 i 7 els hem d\u2019ordenar correctament {7, 5, 3, 12, 2, 9, 13} Continuem formant grups de 3 a partir del segon valor de l\u2019array {7, 5, 3, 12, 2, 9, 13} Ordenem els n\u00fameros en cas de no estar-ho, quedant l\u2019array aix\u00ed: {7, 2, 3, 12, 5, 9, 13} Passem a l\u2019element 3 de l\u2019array i apliquem el mateix procediment. {7, 2, 3, 12, 5, 9, 13} Els valors ja estan ordenats en aquest cas, per tant no hem de fer res. {7, 2, 3, 12, 5, 9, 13} No podem m\u00e9s grups ja que hem arribat al final del vector. Ara el que hem de fer \u00e9s tornar a dividir el nostre interval entre 2. El nou interval \u00e9s 3/2 = 1. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void shellSort ( int [] array ) { int interval , i , j , k , temp ; interval = array . length / 2 ; while ( interval > 0 ) { for ( i = interval ; i < n ; i ++ ) { j = i - interval ; while ( j >= 0 ) { k = j + interval ; if ( array [ j ] <= array [ k ] j = - 1 ; else { temp = array [ j ] ; array [ j ] = array [ k ] ; array [ k ] = temp ; j -= interval ; } } } interval = interval / 2 ; } } Activitat 11. Implementa l\u2019algorisme d\u2019ordenaci\u00f3 shell a la classe TAD i vincula-la a l\u2019opci\u00f3 del men\u00fa corresponent. Quicksort Aquest \u00e9s un dels algorismes d\u2019ordenaci\u00f3 m\u00e9s r\u00e0pids i eficients. Utilitza la t\u00e8cnica \u00abdivideix i vencer\u00e0s\u00bb de tal forma que divideix l\u2019array a ordenar en parts que ordenar\u00e0 al mateix temps. B\u00e0sicament es tria l\u2019element de l\u2019array com a pivot tal que es forme dos subArrays, en un d\u2019ells s\u2019emmagatzemen els elements menors que l\u2019element que hem triat com a pivot i a l\u2019altre array es guarden els element majors que el pivot. Una vegada fet, s\u2019aplica el mateix procediment als subarrays obtinguts. Seguint amb el mateix array dels exemples anteriors, aplicarem l\u2019algorisme d\u2019ordenaci\u00f3 quicksort. {12, 5, 3, 13, 2, 9, 7} Triem un valor que fara el paper de pivot, per exmple el primer element de l\u2019array, el 12 i a partir d\u2019aquest creem dos arrays, un amb els n\u00fameros menors que el pivot i l\u2019altre amb els n\u00fameros majors que el pivot: pivot: {12}; menors: {5, 3, 2, 9, 7}; majors {13} El subarray de majors ja est\u00e0 ordenada ja que nom\u00e9s t\u00e9 un n\u00famero. Ara ordenem el subarray de menors: {5, 3, 2, 9, 7} per la qual cosa escollim com a pivot el primer element de l\u2019array, \u00e9s a dir, el 5. pivot: {5}; menors {3, 2}; majors: {9, 7}. Seguim dividint en subarrays, Una vegada els subarrays estan ordenats sempre sempre s\u2019ensamblaran col\u00b7locant subarrays de menors, seguides de pivot i subarrays de majors {2, 3, 5, 7, 9, 12, 13} Activitat 12. Implementa l\u2019algorisme d\u2019ordenaci\u00f3 quicksort a la classe TAD i vincula-la a l\u2019opci\u00f3 del men\u00fa corresponent. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void Quicksort ( int [] array , int primer , int ultim ) { int i , j , central , pivot , tmp ; central = ( primer + ultim ) / 2 ; pivot = array [ central ] ; i = primer ; j = ultim ; do { while ( array [ i ] < pivot ) i ++ ; while ( array [ j ] > pivot ) j -- ; if ( i <= j ) { tmp = array [ i ] ; array [ i ] = array [ j ] ; array [ j ] = tmp ; i ++ ; j \u2013 - ; } } while ( i <= j ); if ( primer < j ) Quicksort ( array , primer , j ); if ( i < ultim ) Quicksort ( array , i , ultim ); } Activitat 13. Fes que en cada algorisme d\u2019ordenaci\u00f3 es mostre una tra\u00e7a on a cada passada de l\u2019algoritme, \u00e9s a dir, cada vegada que mou un element a l\u2019array, mostre aquest per pantalla. Activitat 14. Entrega mitjan\u00e7ant la plataforma aules la classe TAD que inclou de les activitats 1 a la 13 amb totes les funcions tant de recerca com d\u2019ordenaci\u00f3 sobre arrays unidimensionals. Arrays multidimensionals Fins ara hem estan utilitzant arrays d\u2019una sola dimensi\u00f3, coneguts tamb\u00e9 com vectors, taules o llistes. Aquests arrays es recorren amb ajuda d\u2019un sol \u00edndex (tenen una sola dimensi\u00f3). En aquest apartat estudiarem arrays de m\u00e9s d\u2019una dimensi\u00f3 per als que necessitarem m\u00e9s d\u2019un \u00edndex a l\u2019hora de ser recorreguts. Els arrays multidimensionals m\u00e9s comuns s\u00f3n els de dues dimensions o bidimensionals, tamb\u00e9 coneguts com matrius. \u00c9s com\u00fa representar aquest tipus de dades com una taula composta per una s\u00e8rie de files i columnes: 0,0 0,1 0,2 0,3 ... 0,N 1,0 1,1 1,2 1,3 ... 1,N 2,0 2,1 2,2 2,3 ... 2,N ... ... ... ... ... ... N,0 N,1 N,2 N,3 ... N,N Al contrari del que passava amb els arrays d\u2019una sola dimensi\u00f3 on nom\u00e9s necessitavem un \u00edndex per accedir al valor, en els arrays de dues dimensions com el de l\u2019exemple anterior, necessitarem dos \u00edndex per accedir al valor de l\u2019array. Les matrius, com es coneixen els arrays bidimensionals es forme per files i columnes. Declaraci\u00f3 i creaci\u00f3 Per tal de declarar una matriu en java, \u00e9s a dir, un array de dues dimensions, ho farem de la seg\u00fcent forma:\u00c7 1 tipusBase matriu [][] ; Si es fixeu, mentre quan declaravem un array d\u2019una sola dimensi\u00f3 utilitzavem nom\u00e9s un parell de claud\u00e0tors: 1 tipusBase array [] ; Ara que volem crear una matriu (array de dues dimensions) utilitzarem dos parells de claud\u00e0tors. \u00c9s f\u00e0cil deduir que si vulguerem declarar un array de tres dimensions, hauriem d\u2019utilitzar tres parells de claud\u00e0tors. Amb aquesta instrucci\u00f3 el que estem fent es declarar la matriu per\u00f2 no li hem dit quina grand\u00e0ria tindr\u00e0. Eixa \u00e9s la difer\u00e8ncia entre declaraci\u00f3 i creaci\u00f3. Per tal de crear, \u00e9s a dir, reservar espai per a la nostra matriu, hem de fer el seg\u00fcent: 1 matriu = new tipusBase [ n ][ m ] ; On n i m s\u00f3n valors enters que ens indiquen la grand\u00e0ria de cada dimensi\u00f3. Per exemple, per declarar i crear una matriu d\u2019enters de 5 files i 10 columnes fariem el seg\u00fcent: 1 2 3 4 int matriuEnters [][] ; matriuEnters = new int [ 5 ][ 10 ] ; // Tamb\u00e9 ho podriem fer en una sola instrucci\u00f3 int matriuEnters [][] = new int [ 5 ][ 10 ] ; Inicialitzaci\u00f3 i acc\u00e9s El proc\u00e9s d\u2019inicialitzaci\u00f3 d\u2019un vector, dona igual les dimensions que tinga, consisteix en donar-li valor a les cel\u00b7les que inicialment estan buides. Aquesta inicialitzaci\u00f3 es pot fer de tres formes diferents: De forma individual. En el moment de la declaraci\u00f3. Mitjan\u00e7ant l\u2019\u00fas d\u2019una sent\u00e8ncia de control repetitiva. Inicialitzaci\u00f3 i acc\u00e9s a cada element de l'array Per accedir a una dada en un array multimensional hem de coneixer els \u00edndex de posici\u00f3 d\u2019aquest. En un array de dues dimensions, per accedir a una dada s\u2019ha d\u2019indicar la fila i la columna d\u2019on es troba aquesta informaci\u00f3. Per exemple, imaginem que tenim la seg\u00fcent taula (array de dos dimensions) 12 13 5 9 22 14 21 11 8 56 23 7 6 10 32 36 24 99 78 55 57 79 18 14 Per tal d\u2019inicialitzar-la element a element hauriem d\u2019executar les seg\u00fcents sent\u00e8ncies: 1 2 3 4 5 for ( int i = 0 ; i < FILES ; i ) { for ( int j = 0 ; j < COLUMNES ; j ++ ) { array [ i ][ j ] = 0 ; } } Per tal d\u2019entendre el concepte de matriu o array bidimensional, realitzarem un exercici on treballarem amb les t\u00edpiques matrius matem\u00e0tiques, realitzant les operacions pr\u00f2pies d\u2019aquestes. Activitat 15. Es tracta de desenvolupar una aplicaci\u00f3 que realitze operacions utilitzant matrius de 3x3. El men\u00fa ha de mostrar el seg\u00fcent: 1. Emplena la primera matriu 2. Emplena la segona matriu 3. Visualitza les matrius 4. Suma les matrius 5. Multiplica per un escalar 6. Producte de matrius 7. Transposta 8. Eixir Per a cadascuna de les operacions anteriors s\u2019ha d\u2019implementar un m\u00e8tode Mireu el seg\u00fcent exemple: Activitat 16. Imagina que has de mantindre les notes dels alumnes de tres assignatures. A cada assignatura tens 15 alumnes, tal que s\u2019ha de mantenir la informaci\u00f3 mitjan\u00e7ant una variable que gr\u00e0ficament presenta la seg\u00fcent estructura | | | | | | | | --- | --- | --- | --- | --- | --- | | Assignatura 1 | 5 | 6 | 7,3 | 2,3 | 4,5 | ... | 8,3 | | Assignatura 2 | 7,8 | 8,7 | 7,7 | 3,3 | 4,8 | ... | 6,5 | | Assignatura 3 | 7 | 9 | 10 | 8,2 | 2,8 | ... | 9,2 | Crea una aplicaci\u00f3 en la que pugues: 1. Inserir notes de l\u2019assignatura sel\u00b7leccionada. 2. Inserir totes les notes 3. Calcular la nota mitjana de l\u2019assignatura sel\u00b7leccionada. 4. Ordenar les assignatures de forma ascendent. 5. Estad\u00edstica 6. Eixir de l\u2019aplicaci\u00f3. L\u2019opci\u00f3 estad\u00edstica mostra la quantitat de notes entre 0 i 3, entre 3,1 i 5, entre 5,1 i 7, entre 7.1 i 9 i entre 9,1 i 10. Arrays irregulars Una matriu irregular o escalonada no \u00e9s m\u00e9s que un array de taules, on cadascuna de les taules que formen l\u2019array no necess\u00e0riament han de tenir la mateixa grand\u00e0ria. La declaraci\u00f3 d\u2019un array irregular en java seria de la seg\u00fcent manera: 1 2 3 4 5 6 7 8 9 10 // Declaraci\u00f3 d\u2019una matriu (files) int [][] mat ; // Primer creem la quantitat de files deixant les columnes buit mat = new int [ 3 ][] ; // Despr\u00e9s creem cada fila indicant la quantitat d\u2019elements mat [ 0 ]= new int [ 5 ] ; mat [ 1 ]= new int [ 3 ] ; mat [ 2 ]= new int [ 2 ] ; Cadenes de caracters En Java hem vist que quan volem emmagatzemar un valor enter, definim una variable de tipus int, si pel contrari, el que volem \u00e9s emmagatzemar un valor amb decimals, definim una variable de tipus double o float. Ara b\u00e9, si el que volem \u00e9s emmagatzemar una cadena de caracters, per exemple el nom d\u2019una pesona, hem de definir un objecte de tipus String 1 2 // Crear un objecte string String strNom = \u00ab Manolo el del bombo \u00bb ; Aquest codi el que fa \u00e9s crear un objectes string strNom que cont\u00e9 el nom: \u00abManolo el del bombo\u00bb. Tamb\u00e9 podriem crear un string de la seg\u00fcent manera: 1 String strNome = new String ( \u00ab Manolo el del bombo \u00bb ); Al tractar-se d\u2019una classe, la forma natural de treballar amb ella ser\u00e0 mitjan\u00e7ant l\u2019\u00fas dels m\u00e8todes que disposa la classe. Aquests m\u00e8todes s\u00f3n: int length(): retorna la llarg\u00e0ria de la cadena en un enter. char charAt (int i): ens diu quin caracter est\u00e0 a la posici\u00f3 \u2018i\u2019 String substring(int i): ens retorna la subcadena que hi ha a partir de la posici\u00f3 \u2018i\u2019 fins el final de la cadena String substring(int i, int j): ens retorna la subcadena que es troba des de l\u2019\u00edndex i fins el j String concat(String str): concadena la cadena \u2018str\u2019 que es passa com a par\u00e0metre al final de la cadena. Per exemple: 1 2 3 tring s1 = \u00ab Java \u00bb ; String s2 = \u00ab Pego \u00bb ; String s3 = s1 . concat ( s2 ); // El resultat seria \u00abJavaPego\u00bb - int indexOf(String s): Ens retorna l\u2019index dins de la cadena de la primera aparici\u00f3 de la subcadena s. Per exemple: 1 2 String s1 = \u00ab Java a Pego \u00bb ; int pos = s1 . indexOf ( \u00ab Pego \u00bb ); // Retorna 7 - int indexOf(String s, int i): retorna l\u2019\u00edndex dins de la cadena de la primera aparici\u00f3 de la subcadena s a partir de l\u2019\u00edndex i - int lastIndexOf(int ch): torna l\u2019\u00edndex de l\u2019\u00faltima vegada que apareix el caracter \u2018ch\u2019 dins de la cadena. - boolean equals(Sring str): Compara l\u2019string amb l\u2019objecte que es passa per par\u00e0metre. - boolean equalsIgnoreCase (String otroString): Compara dues cadenes sense tenir en compte maj\u00fascules i min\u00fascules. - int compareTo (String otroString): compara dues cadenes lexicogr\u00e0ficament. En altres paraules, diu quina \u00e9s major que l\u2019altra. - int compareToIgnoreCase (String otroString): com el m\u00e8tode anterior per\u00f2 sense tenir en compte maj\u00fascules ni min\u00fascules. - String toLowerCase(): converteix la cadena a min\u00fascules. - String toUpperCase(): converteix la cadena a maj\u00fascules. - String trim(): suprimeix els espais en blanc que puguen haver als extremps de la cadena - String replace (char oldChar, char newChar): substitueix totes les ocurr\u00e8ncies de oldChar que hi ha a la cadena per newChar Enumeracions Una enumeraci\u00f3 \u00e9s un tipus especial de \u2018classe\u2019 que representa un grup de constants. Cada element d\u2019aquesta estructura est\u00e0 associada a un valor de un tipus de dades concret (normalment enter) on el primer element de l\u2019enumeraci\u00f3 sol agafar el valor 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Exemple 1. Dies de la setmana enum Dies { Dilluns , Dimarts , Dimecres , Dijous , Divendres , Dissabte , Diumenge } // Exemple 2. Talles de roba enum Talles { XXL , XL , L , M , S , XS }","title":"Tema 5. Tipus Compostos de Dades"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#tema-5-tipus-compostos-de-dades","text":"","title":"Tema 5. Tipus Compostos de Dades"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#introduccio","text":"Fins ara hav\u00edem treballat amb tipus de dades simples: int, char, double, float, bool... per\u00f2 que passa si necessitarem guardar informaci\u00f3 relativa a una persona? Nom, cognoms, DNI, adre\u00e7a postal, data de naixement etc.. Amb els tipus de dades simples ens seria impossible representar aquesta informaci\u00f3. Es per aix\u00f2 que s\u2019utilitzen els tipus de dades compostos que ens permetran agrupar de diverses maneres aquesta informaci\u00f3. En aquest tema veurem: arrays, cadenes de car\u00e0cters, estructures i enumeracions. Per tal de fer les activitats d\u2019aquest tema es necessitar\u00e0 de la implementaci\u00f3 d\u2019una classe a la que anomenarem TAD que tindr\u00e0 les seg\u00fcents caracter\u00edstiques: - Classe p\u00fablica - Membres de la classe: arrayN\u00fameros i arrayCaracters - M\u00e8todes de la classe: recercaBinaria, recercaSequencial, ordenarInserci\u00f3, ordenarBombolla, ordenarShell, ordernarQuickSort De moment amb a\u00e7\u00f2 ser\u00e0 suficient, en apartats posteriors anirem afegint m\u00e9s membres i m\u00e8todes quan ho necessitem. Activitat 1 Crea la classe \u2018TAD\u2019 amb l\u2019IDE que sols utilitzar basada en les seg\u00fcents especificacions: - Ha de ser una classe p\u00fablica - Ha de tindre m\u00ednim una constant que ens indicar\u00e0 el total d\u2019elements que tindran els arrays, tant el d\u2019enters com el de car\u00e0cters. - Com membres de la classe ha de tindre almenys un array de car\u00e0cters i un d\u2019enters. Han de ser privats o p\u00fablics? - Tamb\u00e9 ha de tenir un m\u00e8tode main static on s\u2019iniciar\u00e0 el programa.","title":"Introducci\u00f3"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#arrays","text":"Un array \u00e9s un tipus de dades compost que permet emmagatzemar un nombre x d\u2019elements del mateix tipus. Amb una \u00fanica declaraci\u00f3 podem tenir acc\u00e9s a un conjunt de valors agrupats. Aquestes agrupacions o arrays poden b\u00e9 ser de tipus simples o tamb\u00e9 de tipus compostos. Per tal d\u2019accedir a cadascun dels elements del array s\u2019utilitza un \u00edndex o posici\u00f3. La primera posici\u00f3 de tot array \u00e9s la 0 mentre que la segona seria la que t\u00e9 \u00edndex 1. A\u00e7\u00f2 pot marejar un poc al principi. Array d\u2019enters: {8,2,14,55,3,7} Array de car\u00e0cters: {\u2018n\u2019,\u2019a\u2019,\u2019t\u2019,\u2019o\u2019} \u00c9s molt important distingir entre valor i posici\u00f3. Mentre que el valor \u00e9s el contingut de l\u2019array en una posici\u00f3 determinada la posici\u00f3 \u00e9s l\u2019\u00edndex que ens permet recorres l\u2019array i tot el seu contingut. A l\u2019exemple anterior tenim un array de 8 enters, la part superior de color blau ens indica les posicions que van de la 0 a la 7, 8 posicions ens total. Mentre que a la fila inferior trobarem el valor que cont\u00e9 cadascuna de les posicions. Per exemple en la posici\u00f3 5 (la sisena) de l\u2019array tindr\u00edem emmagatzemat un valor de 8. Un altre concepte a tenir en compte \u00e9s la dimensi\u00f3 o grand\u00e0ria de l\u2019array que ens determina el total d\u2019elements que es poden guardar en aquest. En el nostre cas la mida seria de 8.","title":"Arrays"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#declaracio-i-creacio-dun-array-en-java","text":"Un array en Java \u00e9s una estructura de dades que ens permet emmagatzemar un conjunt de dades del mateix tipus. El grand\u00e0ria de l\u2019array es determina en la seua declaraci\u00f3 i no es permet la seua modificaci\u00f3 posterior 1 2 tipusBase nomArray [] ; nomArray = new tipusBase [ grand\u00e0ria ] ; Alguns exemples: 1 2 3 4 int mes [] ; mes = new int [ 30 ] ; char grups [] ; grups = new char [ 5 ] ; Aquesta forme de declarar i inicialitzar arrays es pot fer en una sola l\u00ednia de la seg\u00fcent forma: 1 int agendaMensual = new int [ 30 ] ;","title":"Declaraci\u00f3 i creaci\u00f3 d'un array en Java"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#inicialitzacio-dun-array","text":"Per tal d\u2019accedir a les dades que cont\u00e9 un array necessitem l\u2019identificador d\u2019aquest aix\u00ed com tamb\u00e9 la posici\u00f3 concreta a la qual volem accedir. Per exemple, imaginem un array d\u2019enters que es diu n\u00fameros. 1 2 int n\u00fameros . = new int [ 5 ] ; // Declarem un array n\u00fameros . [] = { 2 , 4 , 6 , 8 , 10 }; // Inicialitzaci\u00f3 de valors D\u2019aquesta forma haur\u00edem creat un array de 5 enters que contindria els nombres parells fins al 10. Activitat 2 En aquest punt aprofitarem per crear un constructor a la nostra classe TAD. Un constructor de classe \u00e9s la funci\u00f3 que s\u2019executa en el moment que s\u2019instancia un objecte i \u00e9s en aquest punt on s\u2019haurien d'inicialitzar aquells elements de la classe que ho necessiten. En el nostre cas els arrays. Inicialitza l\u2019arrayNumeros amb 10 n\u00fameros aleatoris usant la funci\u00f3 rand. Fes el mateix per\u00f2 amb car\u00e0cters amb el nostre arrayCaracters. Recorda que els arrays s\u00f3n membres de la classe.","title":"Inicialitzaci\u00f3 d'un array"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#acces-als-elements-dun-array","text":"Una vegada ja tenim la declaraci\u00f3 de l\u2019array i la seua inicialitzaci\u00f3, si volem b\u00e9 accedir al seu contingut o modificar-ho, necessitar\u00edem l\u2019identificador de l\u2019array i l\u2019\u00edndex al qual volem accedir. \u00c9s molt important tenir en compte que el primer element d\u2019un array en Java est\u00e0 a la posici\u00f3 (\u00edndex) 0 i no a la posici\u00f3 1 com ens indicaria la l\u00f2gica. 1 2 int primerNumero = n\u00fameros . [ 0 ] ; // primerNumero valdria 2 n\u00fameros . [ 0 ] = 12 ; // Canviem el primer numero de l\u2019array","title":"Acc\u00e9s als elements d'un array"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#arrays-de-caracters","text":"Un array que cont\u00e9 car\u00e0cters en lloc de n\u00fameros funciona d\u2019una forma molt semblant al que s\u2019ha explicat en els apartats anteriors. Es pot veure de forma senzilla a l\u2019exemple que vos mostrem a continuaci\u00f3. 1 2 3 char vocals = new char [ 5 ] ; // Declaraci\u00f3 de l\u2019array vocals [] = { \u2018 a \u2019 , \u2019 e \u2019 , \u2019 i \u2019 , \u2019 o \u2019 , \u2019 u \u2019 } // Inicialitzaci\u00f3 vocals [ 0 ] = \u2018 z \u2019 ; // Acc\u00e9s als elements de l\u2019array","title":"Arrays de caracters"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#arrays-com-a-parametres","text":"Com qualsevol altre tipus de dades, un array tamb\u00e9 es pot passar com a par\u00e0metre a un m\u00e8tode. Els arrays sempre es passen per refer\u00e8ncia, \u00e9s a dir, quan passem un array per par\u00e0metre a un m\u00e8tode, el que en realitat estem passant \u00e9s un adre\u00e7a de mem\u00f2ria que \u00e9s la que ens indicaria on est\u00e0 l\u2019inici del contingut d\u2019aquest. Passar per refer\u00e8ncia qualsevol par\u00e0metre significa que qualsevol modificaci\u00f3 que es faja dins del m\u00e8tode afectar\u00e0 tamb\u00e9 a l\u2019array fora d\u2019aquest. No passa el mateix si passem un element concret de l\u2019array, en aquest cas a l\u2019igual que amb els altres par\u00e0metres, aquestos es passen per valor, per tant les modificacions o canvis que es produeixquen dins del m\u00e8tode no afectaran fora d\u2019aquest. Activitat 3. Fes dos m\u00e8todes per la nostra classe que mostre, de forma amigable, l\u2019array de n\u00fameros i l\u2019array de car\u00e0cters. Els m\u00e8todes es podrien dir mostraEnters i mostraCaracters i seran privats. 1 2 3 4 5 6 7 private void mostraEnters () { // Codi per mostrar el vector d'enters } private void mostraCaracters () { // Codi per mostrar el vector de caracters } Activitat 4. En la seg\u00fcent activitat afegirem una funci\u00f3 a la nostra classe en la que ens mostre un men\u00fa de les accions que podem realitzar. Per tal de realitzar aquest men\u00fa afegirem un array d\u2019strings com a nou membre de la classe que inicialitzarem amb les seg\u00fcents opcions: Mostrar array enters Mostrar array caracters Reinicialitzar vectors Recerca seq\u00fcencial Recerca bin\u00e0ria Ordenar amb bombolla Ordenar amb Quicksort Ordenar amb Shell","title":"Arrays com a par\u00e0metres"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#bucle-for-en-java","text":"Per tal de rec\u00f3rrer arrays podem usar bucles for o while per\u00f2 aquests solen tindre l\u2019inconvenient de que \u00e9s el programador el que ha de controlar quan s\u2019arriba al final de l\u2019array per tal que l\u2019aplicaci\u00f3 no done una errada inesperada i aix\u00f2 de vegades no \u00e9s senzill. La millor forma de rec\u00f3rrer un array sense haver de controlar quan s\u2019arriba al final \u00e9s la sent\u00e8ncia for usada d\u2019una manera alternativa. Si per exemple tenim un array d\u2019enters que s\u2019anomena \u00abvector\u00bb i volem llistar tots els seus elements, podr\u00edem fer el seg\u00fcent: 1 2 3 for ( int i : vector ){ // Accions a realitzar } Activitat 5. Fes una funci\u00f3 que mostre per pantalla el men\u00fa per\u00f2 esta vegada utilitzant el for com hem explicat a l\u2019exemple anterior.","title":"Bucle for en Java"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#algorismes-de-recerca","text":"Existeixen dos algorismes de recerca que veurem en aquest apartat: la recerca seq\u00fcencial i la recerca binaria. A l\u2019element que estem buscant li direm clau.","title":"Algorismes de recerca"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#sequencial","text":"Tamb\u00e9 anomenada recerca lineal, es recorren tots els elements de l\u2019array des del principi fins que es troba la clau (element que estem buscant) o fins que s\u2019arriba a l\u2019\u00faltim element de l\u2019array. 1 2 3 4 5 6 int sequencial ( int [] array , int clau ) { for ( int i = 0 ; i < array . length ; i ++ ) if ( array [ i ] == clau ) return i ; return - 1 ; }","title":"Seq\u00fcencial"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#binaria","text":"En aquest algoritme existeix la precondici\u00f3 que l\u2019array o vector sobre el qual vaja a fer-se la recerca, ha d\u2019estar ordenat. Aquest m\u00e8tode \u00e9s m\u00e9s \u00f2ptim. El funcionament d\u2019aquest algorisme \u00e9s el seg\u00fcent: en una primera iteraci\u00f3 es compara la clau (element que estem buscant) amb el valor al centre, que s\u2019anomena pivot, de l\u2019array. Poden passar tres coses: - Que hajam trobat el que busquem, per tant s\u2019acaba la recerca - Que el pivot siga major que la clau. En aquest cas continuar\u00edem buscant a la meitat esquerra del vector desestimant la meitat dreta (pivot incl\u00f2s) - Que el pivot siga menor que la clau. Amb la qual cosa haur\u00edem de buscar a la part esquerra del vector. Activitat 6. Afegeix el m\u00e8tode de recerca seq\u00fcencial i el de recerca binaria a la classe TAD. Tamb\u00e9 has d\u2019implementar el codi necessari per tal que quan l\u2019usuari seleccione una de les dues opcions de la nostra aplicaci\u00f3, demane el n\u00famero a buscar i mostre el resultat per pantalla. En cas que es seleccione la recerca bin\u00e0ria, haur\u00edem de comprovar si el vector est\u00e0 ordenat 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int recercaBinaria ( int array [] , int clau ) { int posCentre , posInici , posFinal , valorCentral ; posInici = 0 ; posFinal = array . length \u2013 1 ; while ( posInici <= posFinal ) { posCentre = ( posInici + posFinal ) / 2 ; valorCentral = array [ posCentre ] ; if ( clau == valorCentral ) { return posCentre ; } else if ( clau < valorCentral ) { posFinal = posCentro \u2013 1 ; } else { posInici = posCentro + 1 ; } } } Activitat 7. Comparem l\u2019efici\u00e8ncia dels dos algorismes de recerca vistos. Fes una funci\u00f3 a la nostra classe TAD en la que es compten el total de vegades que s\u2019accedeix l\u2019array de n\u00fameros per arribar a trobar la clau. Haur\u00e0s de posar una opci\u00f3 m\u00e9s al men\u00fa, per exemple: \u00abComparar efici\u00e8ncia dels algoritmes\u00bb. Aquesta nova opci\u00f3 haur\u00e0 d\u2019executar varies vegades els dos algorismes de recerca amb vectors de n\u00fameros diferents.","title":"Bin\u00e0ria"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#algorismes-dordenacio","text":"Els algorismes d\u2019ordenaci\u00f3 permeten ordenar un array en funci\u00f3 d\u2019un criteri establert al propi algorisme. Hi han diferents tipus d\u2019algorismes d\u2019ordenaci\u00f3: selecci\u00f3, inserci\u00f3, bombolla, Shell i Quicksort.","title":"Algorismes d'ordenaci\u00f3"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#seleccio","text":"El procediment d\u2019ordenaci\u00f3 per selecci\u00f3 \u00e9s el seg\u00fcent: 1. Busquem l\u2019element m\u00e9s menut de l\u2019array i el col\u00b7loquem a la posici\u00f3 0 intercanviant els dos elements 2. A partir de la posici\u00f3 1 busquem l\u2019element m\u00e9s menut seg\u00fcent i fem el mateix que al pas anterior per\u00f2 aquesta vegada a la posici\u00f3 1 de l\u2019array 3. Repetim el pas 2 fins arribar a l\u2019\u00faltima posici\u00f3 de l\u2019array. Activitat 8. Implementa l\u2019algorisme d\u2019ordenaci\u00f3 per selecci\u00f3 a la classe TAD i vicula-la a l\u2019opci\u00f3 del men\u00fa corresponent.","title":"Selecci\u00f3"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#insercio","text":"Aquest algorisme consisteix en generar un nou array a partir del que ja es t\u00e9, tal que cada nou element inserit es posa a la seua posici\u00f3 correcta. Imaginem que tenim el seg\u00fcent array d\u2019enters per ordenar: {12, 5, 3, 13, 2, 9, 7} Generem un nou array amb el primer element de l\u2019array a ordenar { 12 } El seg\u00fcent valor de l\u2019array original \u00e9s 5. \u00c9s major o menor que el que ja est\u00e0 inserit? Com que la resposta \u00e9s menor, aquest s\u2019haur\u00e0 d\u2019inserir abans quedant de la seg\u00fcent forma: { 5 , 12} El nou array es genera ja ordenat. El seg\u00fcent valor de l\u2019array desordenat \u00e9s 3. On l\u2019haurem de col\u00b7locar? Just abans del 5 quedant aix\u00ed: { 3 , 5, 12} Repetim la mateixa operaci\u00f3 per cada element de l\u2019array original: {3, 5, 12, 13 } { 2 , 3, 5, 12, 13} {2, 3, 5, 9 , 12, 13} {2, 3, 5, 7 , 9, 12, 13} 1 2 3 4 5 6 7 8 9 10 11 12 void insercio ( int [] array ) { int i , j , aux ; for ( i = 1 ; i < array . legnth ; i ++ ) { j = i ; aux = array [ i ] ; while ( j > 0 && aux < array [ j - 1 ] ) { array [ j ] = array [ j - 1 ] ; j -- ; } array [ j ] = aux ; } } Activitat 9. Implementa l\u2019algorisme d\u2019ordenaci\u00f3 per inserci\u00f3 a la classe TAD i vincula-la a l\u2019opci\u00f3 del men\u00fa corresponent.","title":"Inserci\u00f3"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#bombolla","text":"L\u2019algorisme d\u2019ordenaci\u00f3 per bombolla \u00e9s el m\u00e9s conegut i tamb\u00e9 el menys eficient, ja que a cada passada per ordenar un element compara cadascun d\u2019ells amb el seu adjacent de forma que si les seues posicions s\u00f3n incorrectes, s\u2019intercanvien. Al finalitzar cada passada l\u2019element m\u00e9s gran es va posant al final de la llista Donat el seg\u00fcent array: {12, 5, 3, 13, 2, 9, 7} Pas 1. Comparem les posicions 0 i 1, \u00e9s a dir, 12 i 5 i com que estan desordenats (el primer \u00e9s major que el segon), s\u2019intercanvien. { 5 , 12 , 3, 13, 2, 9, 7} Pas 2. A continuaci\u00f3 comparem les posicions 1 i 2 de l\u2019array, que s\u00f3n 12 i 3. Com que tamb\u00e9 estan desordenades, les intercanviem {5, 3 , 12 , 13, 2, 9, 7} Pas 3. Ara anem a comparar les posicions 2 i 3 que contenen els valors 12 i 13 respectivament. Com que estan ben ordenades no es realitza cap acci\u00f3: Pas 4. Posicions 3 i 4 que s\u00f3n 13 i 2. Les intercanviem. {5, 3, 12 , 2, 13 , 9, 7} Pas 5. Posicions 4 i 5 que tamb\u00e9 estan desordenades per tant executem l\u2019intercanviem {5, 3, 12, 2, 9 , 13 , 7} Pas 6. Comparem posicions 5 i 6 que tenen els valors 13 i 7 i s\u2019han d\u2019intercanviar {5, 3, 13, 2, 9, 7 , 13 } Una vegada finalitzada la primera passada hem aconseguit que l\u2019element major de l\u2019array estiga posicionat a l\u2019\u00faltima posici\u00f3. A la seg\u00fcent passada recorrerem l\u2019array fins la posici\u00f3 anterior a on es troba ara el n\u00famero 13, \u00e9s a dir la posici\u00f3 5 i aquest procediment es repeteix fins arribar a la posici\u00f3 0 Finalment el codi quedaria aix\u00ed: 1 2 3 4 5 6 7 8 9 10 11 void bombolla ( int [] arrayNumeros ) { for ( int i = 0 ; i < arrayNumeros . length - 1 ; i ++ ) { for ( int j = i + 1 ; j < arrayNumeros . length ; j ++ ) { if ( arrayNumeros [ i ] > arrayNumeros [ j ] ) { int canvi = arrayNumeros [ i ] ; arrayNumeros [ i ] = arrayNumeros [ j ] ; arrayNumeros [ j ] = canvi ; } } } } Activitat 10. Implementa l\u2019algorisme d\u2019ordenaci\u00f3 per bombolla a la classe TAD i vincula-la a l\u2019opci\u00f3 del men\u00fa corresponent.","title":"Bombolla"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#shell","text":"L\u2019algorisme Shell \u00e9s una millora de l\u2019algorisme d\u2019inserci\u00f3 directa. Compara elements separats per un espai de v\u00e0ries posicions el que permet que un element faja passos m\u00e9s grans fins trobar la seua posici\u00f3 esperada. Els passos m\u00faltiples sobre els elements de l\u2019array es fan amb espais de posicions cada vegada m\u00e9s menuts. L\u2019\u00faltim pas de l\u2019algorisme Shell \u00e9s una simple ordenaci\u00f3 per inserci\u00f3 per\u00f2 arribats a aquest punt es pot garantir que l\u2019array esta ja quasi ordenat, el que fa que l\u2019ordenaci\u00f3 per inserci\u00f3 siga molt eficient. Vegem com actuaria aquest algorisme aplicat sobre l\u2019array que estem utilitzant com exemple: {12, 5, 3, 13, 2, 9, 7}. Aquest array t\u00e9 un total de 7 elements (n=7). Creem n/2 grups, separats n/2 n\u00fameros entre ells. n/2=7/2=3, \u00e9s a dir, el nostre interval per crear grups val 3 Marquem en negreta els valors de la primera subllista. {12, 5, 3, 13, 2, 9, 7} Donats els elements 12, 13 i 7 els hem d\u2019ordenar correctament {7, 5, 3, 12, 2, 9, 13} Continuem formant grups de 3 a partir del segon valor de l\u2019array {7, 5, 3, 12, 2, 9, 13} Ordenem els n\u00fameros en cas de no estar-ho, quedant l\u2019array aix\u00ed: {7, 2, 3, 12, 5, 9, 13} Passem a l\u2019element 3 de l\u2019array i apliquem el mateix procediment. {7, 2, 3, 12, 5, 9, 13} Els valors ja estan ordenats en aquest cas, per tant no hem de fer res. {7, 2, 3, 12, 5, 9, 13} No podem m\u00e9s grups ja que hem arribat al final del vector. Ara el que hem de fer \u00e9s tornar a dividir el nostre interval entre 2. El nou interval \u00e9s 3/2 = 1. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void shellSort ( int [] array ) { int interval , i , j , k , temp ; interval = array . length / 2 ; while ( interval > 0 ) { for ( i = interval ; i < n ; i ++ ) { j = i - interval ; while ( j >= 0 ) { k = j + interval ; if ( array [ j ] <= array [ k ] j = - 1 ; else { temp = array [ j ] ; array [ j ] = array [ k ] ; array [ k ] = temp ; j -= interval ; } } } interval = interval / 2 ; } } Activitat 11. Implementa l\u2019algorisme d\u2019ordenaci\u00f3 shell a la classe TAD i vincula-la a l\u2019opci\u00f3 del men\u00fa corresponent.","title":"Shell"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#quicksort","text":"Aquest \u00e9s un dels algorismes d\u2019ordenaci\u00f3 m\u00e9s r\u00e0pids i eficients. Utilitza la t\u00e8cnica \u00abdivideix i vencer\u00e0s\u00bb de tal forma que divideix l\u2019array a ordenar en parts que ordenar\u00e0 al mateix temps. B\u00e0sicament es tria l\u2019element de l\u2019array com a pivot tal que es forme dos subArrays, en un d\u2019ells s\u2019emmagatzemen els elements menors que l\u2019element que hem triat com a pivot i a l\u2019altre array es guarden els element majors que el pivot. Una vegada fet, s\u2019aplica el mateix procediment als subarrays obtinguts. Seguint amb el mateix array dels exemples anteriors, aplicarem l\u2019algorisme d\u2019ordenaci\u00f3 quicksort. {12, 5, 3, 13, 2, 9, 7} Triem un valor que fara el paper de pivot, per exmple el primer element de l\u2019array, el 12 i a partir d\u2019aquest creem dos arrays, un amb els n\u00fameros menors que el pivot i l\u2019altre amb els n\u00fameros majors que el pivot: pivot: {12}; menors: {5, 3, 2, 9, 7}; majors {13} El subarray de majors ja est\u00e0 ordenada ja que nom\u00e9s t\u00e9 un n\u00famero. Ara ordenem el subarray de menors: {5, 3, 2, 9, 7} per la qual cosa escollim com a pivot el primer element de l\u2019array, \u00e9s a dir, el 5. pivot: {5}; menors {3, 2}; majors: {9, 7}. Seguim dividint en subarrays, Una vegada els subarrays estan ordenats sempre sempre s\u2019ensamblaran col\u00b7locant subarrays de menors, seguides de pivot i subarrays de majors {2, 3, 5, 7, 9, 12, 13} Activitat 12. Implementa l\u2019algorisme d\u2019ordenaci\u00f3 quicksort a la classe TAD i vincula-la a l\u2019opci\u00f3 del men\u00fa corresponent. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void Quicksort ( int [] array , int primer , int ultim ) { int i , j , central , pivot , tmp ; central = ( primer + ultim ) / 2 ; pivot = array [ central ] ; i = primer ; j = ultim ; do { while ( array [ i ] < pivot ) i ++ ; while ( array [ j ] > pivot ) j -- ; if ( i <= j ) { tmp = array [ i ] ; array [ i ] = array [ j ] ; array [ j ] = tmp ; i ++ ; j \u2013 - ; } } while ( i <= j ); if ( primer < j ) Quicksort ( array , primer , j ); if ( i < ultim ) Quicksort ( array , i , ultim ); } Activitat 13. Fes que en cada algorisme d\u2019ordenaci\u00f3 es mostre una tra\u00e7a on a cada passada de l\u2019algoritme, \u00e9s a dir, cada vegada que mou un element a l\u2019array, mostre aquest per pantalla. Activitat 14. Entrega mitjan\u00e7ant la plataforma aules la classe TAD que inclou de les activitats 1 a la 13 amb totes les funcions tant de recerca com d\u2019ordenaci\u00f3 sobre arrays unidimensionals.","title":"Quicksort"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#arrays-multidimensionals","text":"Fins ara hem estan utilitzant arrays d\u2019una sola dimensi\u00f3, coneguts tamb\u00e9 com vectors, taules o llistes. Aquests arrays es recorren amb ajuda d\u2019un sol \u00edndex (tenen una sola dimensi\u00f3). En aquest apartat estudiarem arrays de m\u00e9s d\u2019una dimensi\u00f3 per als que necessitarem m\u00e9s d\u2019un \u00edndex a l\u2019hora de ser recorreguts. Els arrays multidimensionals m\u00e9s comuns s\u00f3n els de dues dimensions o bidimensionals, tamb\u00e9 coneguts com matrius. \u00c9s com\u00fa representar aquest tipus de dades com una taula composta per una s\u00e8rie de files i columnes: 0,0 0,1 0,2 0,3 ... 0,N 1,0 1,1 1,2 1,3 ... 1,N 2,0 2,1 2,2 2,3 ... 2,N ... ... ... ... ... ... N,0 N,1 N,2 N,3 ... N,N Al contrari del que passava amb els arrays d\u2019una sola dimensi\u00f3 on nom\u00e9s necessitavem un \u00edndex per accedir al valor, en els arrays de dues dimensions com el de l\u2019exemple anterior, necessitarem dos \u00edndex per accedir al valor de l\u2019array. Les matrius, com es coneixen els arrays bidimensionals es forme per files i columnes.","title":"Arrays multidimensionals"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#declaracio-i-creacio","text":"Per tal de declarar una matriu en java, \u00e9s a dir, un array de dues dimensions, ho farem de la seg\u00fcent forma:\u00c7 1 tipusBase matriu [][] ; Si es fixeu, mentre quan declaravem un array d\u2019una sola dimensi\u00f3 utilitzavem nom\u00e9s un parell de claud\u00e0tors: 1 tipusBase array [] ; Ara que volem crear una matriu (array de dues dimensions) utilitzarem dos parells de claud\u00e0tors. \u00c9s f\u00e0cil deduir que si vulguerem declarar un array de tres dimensions, hauriem d\u2019utilitzar tres parells de claud\u00e0tors. Amb aquesta instrucci\u00f3 el que estem fent es declarar la matriu per\u00f2 no li hem dit quina grand\u00e0ria tindr\u00e0. Eixa \u00e9s la difer\u00e8ncia entre declaraci\u00f3 i creaci\u00f3. Per tal de crear, \u00e9s a dir, reservar espai per a la nostra matriu, hem de fer el seg\u00fcent: 1 matriu = new tipusBase [ n ][ m ] ; On n i m s\u00f3n valors enters que ens indiquen la grand\u00e0ria de cada dimensi\u00f3. Per exemple, per declarar i crear una matriu d\u2019enters de 5 files i 10 columnes fariem el seg\u00fcent: 1 2 3 4 int matriuEnters [][] ; matriuEnters = new int [ 5 ][ 10 ] ; // Tamb\u00e9 ho podriem fer en una sola instrucci\u00f3 int matriuEnters [][] = new int [ 5 ][ 10 ] ;","title":"Declaraci\u00f3 i creaci\u00f3"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#inicialitzacio-i-acces","text":"El proc\u00e9s d\u2019inicialitzaci\u00f3 d\u2019un vector, dona igual les dimensions que tinga, consisteix en donar-li valor a les cel\u00b7les que inicialment estan buides. Aquesta inicialitzaci\u00f3 es pot fer de tres formes diferents: De forma individual. En el moment de la declaraci\u00f3. Mitjan\u00e7ant l\u2019\u00fas d\u2019una sent\u00e8ncia de control repetitiva. Inicialitzaci\u00f3 i acc\u00e9s a cada element de l'array Per accedir a una dada en un array multimensional hem de coneixer els \u00edndex de posici\u00f3 d\u2019aquest. En un array de dues dimensions, per accedir a una dada s\u2019ha d\u2019indicar la fila i la columna d\u2019on es troba aquesta informaci\u00f3. Per exemple, imaginem que tenim la seg\u00fcent taula (array de dos dimensions) 12 13 5 9 22 14 21 11 8 56 23 7 6 10 32 36 24 99 78 55 57 79 18 14 Per tal d\u2019inicialitzar-la element a element hauriem d\u2019executar les seg\u00fcents sent\u00e8ncies: 1 2 3 4 5 for ( int i = 0 ; i < FILES ; i ) { for ( int j = 0 ; j < COLUMNES ; j ++ ) { array [ i ][ j ] = 0 ; } } Per tal d\u2019entendre el concepte de matriu o array bidimensional, realitzarem un exercici on treballarem amb les t\u00edpiques matrius matem\u00e0tiques, realitzant les operacions pr\u00f2pies d\u2019aquestes. Activitat 15. Es tracta de desenvolupar una aplicaci\u00f3 que realitze operacions utilitzant matrius de 3x3. El men\u00fa ha de mostrar el seg\u00fcent: 1. Emplena la primera matriu 2. Emplena la segona matriu 3. Visualitza les matrius 4. Suma les matrius 5. Multiplica per un escalar 6. Producte de matrius 7. Transposta 8. Eixir Per a cadascuna de les operacions anteriors s\u2019ha d\u2019implementar un m\u00e8tode Mireu el seg\u00fcent exemple: Activitat 16. Imagina que has de mantindre les notes dels alumnes de tres assignatures. A cada assignatura tens 15 alumnes, tal que s\u2019ha de mantenir la informaci\u00f3 mitjan\u00e7ant una variable que gr\u00e0ficament presenta la seg\u00fcent estructura | | | | | | | | --- | --- | --- | --- | --- | --- | | Assignatura 1 | 5 | 6 | 7,3 | 2,3 | 4,5 | ... | 8,3 | | Assignatura 2 | 7,8 | 8,7 | 7,7 | 3,3 | 4,8 | ... | 6,5 | | Assignatura 3 | 7 | 9 | 10 | 8,2 | 2,8 | ... | 9,2 | Crea una aplicaci\u00f3 en la que pugues: 1. Inserir notes de l\u2019assignatura sel\u00b7leccionada. 2. Inserir totes les notes 3. Calcular la nota mitjana de l\u2019assignatura sel\u00b7leccionada. 4. Ordenar les assignatures de forma ascendent. 5. Estad\u00edstica 6. Eixir de l\u2019aplicaci\u00f3. L\u2019opci\u00f3 estad\u00edstica mostra la quantitat de notes entre 0 i 3, entre 3,1 i 5, entre 5,1 i 7, entre 7.1 i 9 i entre 9,1 i 10.","title":"Inicialitzaci\u00f3 i acc\u00e9s"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#arrays-irregulars","text":"Una matriu irregular o escalonada no \u00e9s m\u00e9s que un array de taules, on cadascuna de les taules que formen l\u2019array no necess\u00e0riament han de tenir la mateixa grand\u00e0ria. La declaraci\u00f3 d\u2019un array irregular en java seria de la seg\u00fcent manera: 1 2 3 4 5 6 7 8 9 10 // Declaraci\u00f3 d\u2019una matriu (files) int [][] mat ; // Primer creem la quantitat de files deixant les columnes buit mat = new int [ 3 ][] ; // Despr\u00e9s creem cada fila indicant la quantitat d\u2019elements mat [ 0 ]= new int [ 5 ] ; mat [ 1 ]= new int [ 3 ] ; mat [ 2 ]= new int [ 2 ] ;","title":"Arrays irregulars"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#cadenes-de-caracters","text":"En Java hem vist que quan volem emmagatzemar un valor enter, definim una variable de tipus int, si pel contrari, el que volem \u00e9s emmagatzemar un valor amb decimals, definim una variable de tipus double o float. Ara b\u00e9, si el que volem \u00e9s emmagatzemar una cadena de caracters, per exemple el nom d\u2019una pesona, hem de definir un objecte de tipus String 1 2 // Crear un objecte string String strNom = \u00ab Manolo el del bombo \u00bb ; Aquest codi el que fa \u00e9s crear un objectes string strNom que cont\u00e9 el nom: \u00abManolo el del bombo\u00bb. Tamb\u00e9 podriem crear un string de la seg\u00fcent manera: 1 String strNome = new String ( \u00ab Manolo el del bombo \u00bb ); Al tractar-se d\u2019una classe, la forma natural de treballar amb ella ser\u00e0 mitjan\u00e7ant l\u2019\u00fas dels m\u00e8todes que disposa la classe. Aquests m\u00e8todes s\u00f3n: int length(): retorna la llarg\u00e0ria de la cadena en un enter. char charAt (int i): ens diu quin caracter est\u00e0 a la posici\u00f3 \u2018i\u2019 String substring(int i): ens retorna la subcadena que hi ha a partir de la posici\u00f3 \u2018i\u2019 fins el final de la cadena String substring(int i, int j): ens retorna la subcadena que es troba des de l\u2019\u00edndex i fins el j String concat(String str): concadena la cadena \u2018str\u2019 que es passa com a par\u00e0metre al final de la cadena. Per exemple: 1 2 3 tring s1 = \u00ab Java \u00bb ; String s2 = \u00ab Pego \u00bb ; String s3 = s1 . concat ( s2 ); // El resultat seria \u00abJavaPego\u00bb - int indexOf(String s): Ens retorna l\u2019index dins de la cadena de la primera aparici\u00f3 de la subcadena s. Per exemple: 1 2 String s1 = \u00ab Java a Pego \u00bb ; int pos = s1 . indexOf ( \u00ab Pego \u00bb ); // Retorna 7 - int indexOf(String s, int i): retorna l\u2019\u00edndex dins de la cadena de la primera aparici\u00f3 de la subcadena s a partir de l\u2019\u00edndex i - int lastIndexOf(int ch): torna l\u2019\u00edndex de l\u2019\u00faltima vegada que apareix el caracter \u2018ch\u2019 dins de la cadena. - boolean equals(Sring str): Compara l\u2019string amb l\u2019objecte que es passa per par\u00e0metre. - boolean equalsIgnoreCase (String otroString): Compara dues cadenes sense tenir en compte maj\u00fascules i min\u00fascules. - int compareTo (String otroString): compara dues cadenes lexicogr\u00e0ficament. En altres paraules, diu quina \u00e9s major que l\u2019altra. - int compareToIgnoreCase (String otroString): com el m\u00e8tode anterior per\u00f2 sense tenir en compte maj\u00fascules ni min\u00fascules. - String toLowerCase(): converteix la cadena a min\u00fascules. - String toUpperCase(): converteix la cadena a maj\u00fascules. - String trim(): suprimeix els espais en blanc que puguen haver als extremps de la cadena - String replace (char oldChar, char newChar): substitueix totes les ocurr\u00e8ncies de oldChar que hi ha a la cadena per newChar","title":"Cadenes de caracters"},{"location":"Tema%2005.%20Tipus%20compostos%20de%20dades/#enumeracions","text":"Una enumeraci\u00f3 \u00e9s un tipus especial de \u2018classe\u2019 que representa un grup de constants. Cada element d\u2019aquesta estructura est\u00e0 associada a un valor de un tipus de dades concret (normalment enter) on el primer element de l\u2019enumeraci\u00f3 sol agafar el valor 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Exemple 1. Dies de la setmana enum Dies { Dilluns , Dimarts , Dimecres , Dijous , Divendres , Dissabte , Diumenge } // Exemple 2. Talles de roba enum Talles { XXL , XL , L , M , S , XS }","title":"Enumeracions"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/","text":"Tema 6. Programaci\u00f3 Orientada a Objectes. Introducci\u00f3 La programaci\u00f3 orientada a objectes tamb\u00e9 coneguda com POO \u00e9s el paradigma de programaci\u00f3 que m\u00e9s s\u2019utilitza hui en dia i que permet modelar de manera m\u00e9s eficient la realitat des del punt de vista del programari. La programaci\u00f3 orientada a objectes intenta proporcionar un model de programaci\u00f3 basat en objectes que contenen dades i procediments associats coneguts com a m\u00e8todes. Aquests objectes, que s\u00f3n inst\u00e0ncies de les classes, s\u00f3n tipus abstractes de dades que encapsulen (amaguen) tant les dades com les funcions per accedir-hi. Un dels objectius de la programaci\u00f3 orientada a objectes \u00e9s reflectir la realitat, de forma que els elements d\u2019un programa s\u2019ajusten a elements de la vida quotidiana. Per exemple, suposem que volem realitzar una aplicaci\u00f3 per un taller de vehicles. En un programa estructurat definir\u00edem funcions independentment de les dades, tal que per un costat crear\u00edem el codi de la funci\u00f3 i posteriorment al programa principal s\u2019establiria una variable o variables sobre les que aplicar\u00edem canvis, podria ser un array d\u2019una estructura a la que guardar\u00edem tipus de vehicle, matr\u00edcula, color, etc. En programaci\u00f3 orientada a objectes creem un objecte que simula un cotxe amb les seues caracter\u00edstiques generals i les funcions incloses, tal que en la funci\u00f3 principal de la nostra aplicaci\u00f3, crearem variables d\u2019aquest objecte i usarem els m\u00e8todes aplicats a unes dades concretes a cada moment. La programaci\u00f3 orientada a objectes permet la creaci\u00f3 de programari cada vegada m\u00e9s complexe a partir d\u2019unitats o blocs de codi reutilitzables. Caracter\u00edstiques principals Les propietats principals o caracter\u00edstiques fonamentals del paradigma de programaci\u00f3 orientada a objectes s\u00f3n: Abstracci\u00f3 Abstraure's \u00e9s a\u00efllar mentalment, considerar separadament (un o diversos atributs o qualitats) d'una cosa. Per exemple abstraure els conceptes m\u00e9s importants d'un discurs, \u00e9s a dir, quedar-se amb el important. En programaci\u00f3 orientada a objectes abstraure\u2019s, l\u2019abstracci\u00f3, seria mostrar \u00fanicament les caracter\u00edstiques essencials, que fa l\u2019objecte i per a que es crea, deixant de banda elements com la implementaci\u00f3. L\u2019abstracci\u00f3 permet representar les caracter\u00edstiques essencials d\u2019un objecte, deixant enrere aquelles que no tenen tanta import\u00e0ncia. A m\u00e9s a m\u00e9s, es centra en l\u2019objecte tal i com el coneixem en la vida real, de forma que ens centrem en all\u00f2 que es capa\u00e7 de fer per\u00f2 no en com ho fa. B\u00e0sicament, definir\u00edem l\u2019abstracci\u00f3 com la forma de descriure una entitat del m\u00f3n real sense importar la complexitat que est\u00e0 present i el poder utilitzar aquesta en qualsevol aplicaci\u00f3. Un altre exemple d'abstracci\u00f3: Encapsulament L\u2019encapsulament \u00e9s, en altres paraules, l\u2019ocultaci\u00f3 d\u2019informaci\u00f3, de forma que les dades internes d\u2019un objecte estan ocultes al m\u00f3n exterior, nom\u00e9s es coneix d\u2019ell la seua ess\u00e8ncia, \u00e9s a dir, qu\u00e8 podem fer amb ell. Per exemple, amb freq\u00fc\u00e8ncia es desenvolupa codi font o projectes en els que utilitzem la classe out, m\u00e9s concretament el m\u00e8tode println. Out es troba dins de l\u2019espai de noms (namespace) System i no \u00e9s m\u00e9s que una classe d\u2019aquest paquet. Dit en altres paraules. Out \u00e9s una classe i println() \u00e9s un m\u00e8tode de la classe Out. Modularitat Aquesta propietat fa refer\u00e8ncia a la forma en la que els elements en programaci\u00f3 orientada a objectes es troben organitzats en m\u00f2duls, facilitant aix\u00ed l\u2019encapsulament i abstracci\u00f3 de la informaci\u00f3. La modularitat permet dividir una aplicaci\u00f3 en parts. Aquestes parts han de ser tan independents com puguen de la resta de m\u00f2duls aix\u00ed com tamb\u00e9 de l\u2019aplicaci\u00f3 principal. El motiu pel qual els m\u00f2duls han de ser el m\u00e9s independents possibles de l\u2019aplicaci\u00f3 \u00e9s perqu\u00e8 aix\u00ed es podran reutilitzar en altres aplicacions m\u00e9s endavant. Jerarquia i her\u00e8ncia La jerarquia \u00e9s la propietat de la programaci\u00f3 orientada a objectes respecte de la relaci\u00f3 o ordre existent entre les distintes classes i objectes. El mecanisme principal per tal d\u2019ordenar les classes als nostres projectes \u00e9s l\u2019her\u00e8ncia. Podem parlar d\u2019her\u00e8ncia entre classes quan elements d\u2019una classe (superclasse) son heretats per una altra o incl\u00f2s els seus m\u00e8todes poden ser sobrecarregats. Suposem una aplicaci\u00f3 d\u2019un taller de vehicles en el qual treballen moltes persones per\u00f2 cadascuna fa una funci\u00f3 diferent al taller. Malgrat que cadascuna es dedique a un tasca concreta i no s\u00e0piga res de la resta de feines que es fan al taller, tots els empleats s\u00f3n persones, \u00e9s a dir, tots tenen un s\u00e8rie de caracter\u00edstiques comuns: Nom, cognoms, DNI, data de naixement etc.. Mentre que al mateix temps hi ha algunes caracter\u00edstiques especifiques per a cada tipus d\u2019empleat Imaginem que tenim dos classes d\u2019empleats: els mec\u00e0nics i els comercials. Dels primers hem de guardar informaci\u00f3 del nombre d\u2019hores extra que fa al mes mentre que dels segons hem de gestionar informaci\u00f3 sobre les cites que t\u00e9 amb clients durant la setmana. Polimorfisme Polimorfisme \u00e9s una paraula grega que significa \u00abmoltes formes\u00bb. Aquesta paraula \u00e9s ideal per definir aquesta caracter\u00edstica de la programaci\u00f3 orientada a objectes ja que en POO podem tindre objectes amb el mateix nom que realitzen funcions distintes o implementen codi diferent. El polimorfisme \u00e9s un mecanisme que s\u2019utilitza molt en POO juntament amb l\u2019her\u00e8ncia tal que quan una classe deriva d\u2019una altra hereta les seues caracter\u00edstiques i operacions. A la classe que hereta es pot redefinir qualsevol m\u00e8tode heretat, de forma que en funci\u00f3 de la refer\u00e8ncia a objectes que usem a cada moment s\u2019estar\u00e0 executant un m\u00e8tode o un altre. Un mateix missatge enviat a objectes diferents donar\u00e0 com a resposta eixides diferents, \u00e9s a dir, si tenim diversos objectes amb m\u00e8todes similars, segons es referencie l\u2019un o l\u2019altre objecte el resultat final ser\u00e0 diferent. Per exemple seguint amb l\u2019esquema dels empleats de la nostra empresa suposem que la classe (\u00absuperclasse\u00bb) t\u00e9 un m\u00e8tode que es diu \u00abcalcularSou\u00bb, aquest m\u00e8tode l\u2019hereten tant el mec\u00e0nic com el comercial per\u00f2 el seu c\u00e0lcul seria diferent en un i l\u2019altre. El sou del mec\u00e0nic ser\u00e0 el sou base m\u00e9s el n\u00famero d\u2019hores extra multiplicades pel preu al que es paguen les hores extra, mentre que el sou del comercial seria el sou base m\u00e9s el plus. Realitzaci\u00f3 de programes orientats a objectes A partir d\u2019ara, quan hajam de resoldre un problema hem de comen\u00e7ar a pensar d\u2019una forma diferent a la que est\u00e0vem fent fins ara. En programaci\u00f3 orientada a objectes seguirem usant els mecanismes de programaci\u00f3 estructurada com ara sent\u00e8ncies repetitives, alternatives, etc.. tanmateix hem de plantejar un sistema on les dades presenten una major import\u00e0ncia. L\u2019objectiu de l\u2019orientaci\u00f3 a objectes \u00e9s plasmar la realitat de manera que programem els elements el m\u00e9s pr\u00f2xim possible a com els veiem al seu entorn natural. Aix\u00ed, quan hajam d\u2019encarar un problema d\u2019aquest tipus: Ens preguntarem sobre aquells elements dels que realment es interessant emmagatzemar informaci\u00f3, \u00e9s a dir, localitzarem els possibles objectes del nostre programa. De cada element hem de con\u00e8ixer quines s\u00f3n les seues caracter\u00edstiques o quines s\u00f3n les caracter\u00edstiques que el representen. De cada element hem de con\u00e8ixer les operacions a realitzar ja que cada conjunt de dades permetr\u00e0 la realitzaci\u00f3 d\u2019un conjunt d\u2019operacions. Finalment, desenvoluparem un entorn on utilitzarem els elements configurats. Per exemple, a l\u2019hora de desenvolupar l\u2019aplicaci\u00f3 per al un taller de reparacions de vehicles, podem resoldre les seg\u00fcents q\u00fcestions per determinar els elements que inclourem: Quins elements del taller han de ser desats o s\u2019han de tenir en compte a la nostra aplicaci\u00f3? Els vehicles i els empleats De cada element, quines dades ens interessen? Dels vehicles: l\u2019hora d\u2019entrada al taller, danys que presenta, matr\u00edcula, marca i model, etc.. de cada empleat: nom i cognoms, adre\u00e7a, sou, c\u00e0rrec, reparacions associades, etc.. A cada element, quines operacions associarem? A un vehicle podem canviar-li l\u2019oli, reparar la xapa, canviar el color, posar a punt, etc.. als empleats podem modificar-los el sou base, establir hores de treball etc.. Pel que fa a l\u2019aplicaci\u00f3 principal que utilitze aquests objectes, podem plantejar un programa que emmagatzeme de forma din\u00e0mica els vehicles que van entrant al taller, aix\u00ed com tamb\u00e9 els empleats que treballen en ell estructurar la funcionalitat mitjan\u00e7ant un men\u00fa d\u2019opcions que permeta utilitzar les operacions anteriorment plantejades per a cada objecte. Activitat 1. Batalla Naval Fes un an\u00e0lisi semblant al de l\u2019aplicaci\u00f3 del taller per\u00f2 per al joc d\u2019enfonsar la flota. Quants objectes diferents hi ha? Quines s\u00f3n les seues caracter\u00edstiques principals? Quines accions poden realitzar? Classes i Objectes Una classe \u00e9s la definici\u00f3 d\u2019un objecte, \u00e9s l\u2019element que descriu els components d\u2019un objecte de forma general. Diem que hem creat un objecte quan donem valors i utilitzem els components definits a la classe. Per exemple, si continuem utilitzant el nostre taller de vehicles, una classe podria ser la classe cotxe, en la que es descriu de forma general aquest element de la vida quotidiana. S\u2019establiria que un cotxe es caracteritza per: Tindre rodes Tindre matricula Tindre portes Se d\u2019una marca i un model concrets. Etc.. Ara b\u00e9, si al nostre taller entra un Seat Arosa de tres portes, les caracter\u00edstiques abans esmentades adopten certs valors: Quatre m\u00e9s la de recanvi. Matricula. 1234ACB 3 portes Seat. Model Arosa Aix\u00ed tenim per un costat la classe cotxe i per l\u2019altra l\u2019objecte Seat Arosa. Alhora de crear una classe definim el que denominem propietats o atributs i m\u00e8todes de classe. Atributs: una caracter\u00edstica concreta d\u2019un objecte de la vida quotidiana. Quan s\u2019estableix un atribut a una classe, es defineix com quan cre\u00e0vem variables als nostres programes estructurats, indicant tipus de dades i nom amb el que el reconeixem. M\u00e8todes de la classe: donen funcionalitat a la classe, \u00e9s a dir, reflecteixen les operacions que aquesta pot fer sobre els atributs. Els m\u00e8todes s\u00f3n similars a les funcions o procediments que cre\u00e0vem en programaci\u00f3 estructurada per\u00f2 orientats a modificar i actuar sobre les propietats d\u2019una classe. Un objecte dona valors concrets als atributs que defineix la classe i utilitza els seus m\u00e8todes. Quan un objecte utilitza un m\u00e8tode concret es diu que aquesta enviant un missatge. D\u2019alguna manera a\u00e7\u00f2 t\u00e9 l\u00f2gica ja que estem donant una ordre a un component que reflecteix la realitat. Si a un taller hem de canviar el color d\u2019un vehicle, direm canvia el color a l\u2019operari que estiga treballant, li estem enviant un missatge de que ha de realitzar aquesta acci\u00f3 concreta. A l\u2019hora de enviar un missatge a un element concret d\u2019un objecte utilitzarem l\u2019operador punt, per exemple, arosa.canviaColor(). A sovint donem el nom d\u2019estat als valors que en un objecte t\u00e9 en un moment concret de la vida del programa on s\u2019est\u00e0 utilitzant. A m\u00e9s a m\u00e9s, quan creem un objecte, donem valors a les propietats de la classe, diem que estem instanciant aquesta classe. Definici\u00f3 de classes en Java Una vegada ja sabem que s\u00f3n les classes i els objectes veurem com es defineixen classes i instancien objectes en el llenguatge Java. Definir una classe implica donar-li nom a ella i als elements que emmagatzemen la seua informaci\u00f3, aix\u00ed com tamb\u00e9 descriure els m\u00e8todes que realitzaran les accions considerades als objectes. Les definicions o especificacions no constitueixen un codi de programa executable si no que s\u2019utilitzen per assignar mem\u00f2ria on emmagatzemar els valors dels atributs que utilitza el programa i recon\u00e8ixer els m\u00e8todes que aquesta utilitzar\u00e0; normalment es situen en arxius formant packages, utilitzant un arxiu per v\u00e0ries classes relacionades. 1 2 3 class nomClasse { llista_de_membres } - nomClasse: definit per l\u2019usuari i identifica la classe; pot incloure lletres, n\u00fameros i subratllats com qualsevol identificador. - llista_de_membres: s\u00f3n els m\u00e8todes i atributs de la classe, etc.. M\u00e9s concretament, una classe es podria definir de la seg\u00fcent manera: 1 2 3 4 5 6 7 class nomClasse { llista_de_constants ; llista_de_atributs ; constructor_de_classe ; constructor_de_c\u00f2pia ; m\u00e8todes ; } En realitat si la definici\u00f3 de les parts de la classe es fera en un altre ordre, no afectaria a la compilaci\u00f3 i execuci\u00f3 d\u2019aquesta per\u00f2 s\u00ed a la lectura del codi i el faria m\u00e9s complicat d\u2019interpretar. Exemple de classe: per tal d\u2019il\u00b7lustrar com es defineix una classe amb un exemple, definirem la classe \u2018punt\u2019. Aquesta classe determina les coordenades a les quals es troba un punt concret: x i y; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Punt { private int x ; private int y ; public Punt () { x = 0 ; y = 0 ; } public Punt ( int a , int b ) { x = a ; y = b ; } public int LlegirX () { return x ; } public int LlegirY () { return y ; } public void FixarX ( int valor ) { x = valor ; } public void FixarY ( int valor ) { y = valor ; } } Una vegada tenim la definici\u00f3 de la classe punt, instanciarem un punt concret que es troba a les coordenades 10 i 5 1 Punt a = new Punt ( 10 , 5 ); Visibilitat dels membres de la classe Un principi fonamental en la programaci\u00f3 orientada a objectes \u00e9s l\u2019ocultaci\u00f3 de la informaci\u00f3, a\u00e7\u00f2 significa que no es pot accedir per m\u00e8todes externs de la classe a determinada informaci\u00f3 interna. El mecanisme principal per aconseguir-ho \u00e9s posar-los dins d\u2019una classe i fer-los privats i aix\u00ed nom\u00e9s es podr\u00e0 accedir a aquests des de dins de la classe Existeixen tres diferents especificacions d\u2019acc\u00e9s o modificadors de visibilitat: public (+): un m\u00e8tode o atribut t\u00e9 una visibilitat p\u00fablica quan totes les dem\u00e8s classes poden accedir a ells, b\u00e9 siga una altra classe o una subclasse. Private (-): sols es pot accedir a ells des del propi codi de la classe. Protected (#): nom\u00e9s des del propi codi de la classe o de les seues subclasses es pot accedir. Package (~): nom\u00e9s accessible per membres del paquet. Atributs Els atributs s\u00f3n les caracter\u00edstiques individuals que diferencien un objecte d\u2019un altre i determinen la seua aparen\u00e7a, estat o altres qualitats. Els atributs es desen en variables anomenades variables d\u2019inst\u00e0ncia i cada objecte particular pot tindre valors distints per a aquestes variables. Per exemple, si hem de definir una persona en base a les seues caracter\u00edstiques individuals que diferencien a una persona d\u2019una altra en el m\u00f3n real, qu\u00e8 escollir\u00edem? Segurament: estatura, color de la pell, color dels ulls, color del pel, etc.. per\u00f2 segurament tamb\u00e9 altres caracter\u00edstiques no tan visualment evidents com podrien ser: nom, cognoms, data de naixement, etc.. i altres m\u00e9s \u00abadministratives\u00bb com podria ser el DNI. Aix\u00ed ens quedaria la classe persona: 1 2 3 4 5 6 7 8 9 10 public class Persona { private String DNI ; private String nom ; private String cognoms ; private String dataNaixement ; private double estatura ; private double pes ; private String colorUlls ; private String colorCabells ; } Les variables d\u2019inst\u00e0ncia tamb\u00e9 anomenades membres s\u00f3n declarades a la classe per\u00f2 els seus valors son canviats i fixats a l\u2019objectes ja que una classe no \u00e9s m\u00e9s que un esquema que defineix com seran les persones al nostre programa. A m\u00e9s de les variables d\u2019inst\u00e0ncia hi ha variables de classe, les quals s\u2019apliquen a la classe i a totes les inst\u00e0ncies. Per exemple, el n\u00famero de rodes d\u2019un cotxe \u00e9s el mateix per a tots els objectes cotxe. M\u00e8todes Els m\u00e8tode s\u00f3n aquelles accions que pot realitzar la classe que estem definint. B\u00e0sicament el que fa un m\u00e8tode \u00e9s modificar l\u2019estat de l\u2019objecte mitjan\u00e7ant el canvi del valor dels seus atributs. Continuant amb la classe persona que hem definit al punt anterior, caldria que ens f\u00e9rem les seg\u00fcents q\u00fcestions: quines accions s\u00f3n les que pot realitzar la nostra persona? En que afecta eixes accions als atributs que hem escollit per definir-la? A la q\u00fcesti\u00f3 primera dir\u00edem que una persona pot: caminar, botar, c\u00f3rrer, menjar, cr\u00e9ixer, tintar-se els cabells, etc.. Pel que fa a la segon q\u00fcesti\u00f3, podr\u00edem dir que nom\u00e9s modifiquen atributs: menjar, augmentant de pes; cr\u00e9ixer, modificant l\u2019estatura i tintar-se els cabells, canviant el color del pel. Aix\u00ed la classe persona podria quedar de la seg\u00fcent forma: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Persona { // Atributs private String DNI ; private String nom ; private String cognoms ; private String dataNaixement ; private double estatura ; private double pes ; private String colorUlls ; private String colorCabells ; // M\u00e8todes public void creixer ( ) { estatura ++ ; } public void menjar ( ) { pes ++ ; } public void tintarse ( String colorNou ) { colorCabells = colorNou ; } } Fixeu-se que mentre els atributs de la classe tenen un modificador de visibilitat private, els m\u00e8todes el solen tindre public. Encara que no necess\u00e0riament ha de ser aix\u00ed sempre per\u00f2 \u00e9s molt habitual. Els m\u00e8todes a Java sempre s\u00f3n membres d\u2019una classe, no hi ha m\u00e8todes o funcions fora d\u2019aquestes. La seua implementaci\u00f3 s\u2019inclou dins del cos de la classe. Exemple: A continuaci\u00f3 modelarem una s\u00e8rie de classes geom\u00e8triques sobre les quals farem una s\u00e8rie de c\u00e0lculs. Utilitzant un llenguatge de programaci\u00f3 orientada a objectes com \u00e9s Java, modelarem un triangle i un quadrat. Primer la classe triangle. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Triangle { int iTotalCostats ; private double dArea ; private double dCostat ; private double dAltura ; public Triangle () { iTotalCostats = 3 ; dCostat = 1 ; dAltura = Math . sqrt ( 3 * dCostat ) / 2 ; } public Triangle ( double dLong ) { iTotalCostats = 3 ; dCostat = dLong ; } public double getArea () { return ( dCostat * dAltura ) / 2 ; } } A continuaci\u00f3 la classe quadrat 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Quadrat { int iTotalCostats ; private double dArea ; private double dCostat ; private double dAltura ; public Quadrat () { iTotalCostats = 4 ; dCostat = 1 ; dAltura = Math . sqrt ( 3 * dCostat ) / 2 ; } public Triangle ( double dLong ) { iTotalCostats = 4 ; dCostat = dLong ; } public double getArea () { return dCostat * dAltura ; } } Inst\u00e0ncies La declaraci\u00f3 d\u2019una classe no \u00e9s m\u00e9s que la definici\u00f3 d\u2019una realitat utilitzant un llenguatge de programaci\u00f3 orientada a objectes. El seg\u00fcent pas seria fer \u00fas d\u2019aquesta definici\u00f3 o classe, \u00e9s a dir, instanciar o crear un objecte a partir d\u2019aquesta classe. Per tal d\u2019instanciar una classe s\u2019utilitza la seg\u00fcent sent\u00e8ncia: 1 nom_classe nom_instancia = new nom_classe ( par\u00e0metres ); La paraula \u00abnew\u00bb s\u2019encarrega de reservar espai en mem\u00f2ria i torna una refer\u00e8ncia a l\u2019adre\u00e7a de mem\u00f2ria on s\u2019ha emmagatzemat l\u2019objecte. nom_classe: en el primer cas \u00e9s el nom de la classe que es vol instanciar. A la segon part es refereix al constructor de la classe que ha de ser igual que el nom d\u2019aquesta. El constructor \u00e9s un m\u00e8tode especial de la classe i com a m\u00e8tode que \u00e9s pot rebre par\u00e0metres. nom_instancia: identificador amb el que s\u2019identificar\u00e0 l\u2019objecte instanciat. L\u2019espai reservat a mem\u00f2ria per un objecte dependr\u00e0 de la quantitat d\u2019elements o membres que continga. Quan un objecte no est\u00e0 siguen referenciat es treu de mem\u00f2ria per tal d\u2019alliberar espai pel \u00abgarbage collector\u00bb Quan creem un objecte d\u2019una classe, cada atribut ser\u00e0 inicialitzat amb els valors per defecte del tipus de dades utilitzat o b\u00e9 pel valor establert al constructor. Constructors Un constructor \u00e9s un m\u00e8tode membre d\u2019una classe que s\u2019executa de forma autom\u00e0tica quan es crea un instancia d\u2019aquesta. El constructor d\u2019una classe es diferencia de la resta perqu\u00e8 s\u2019ha d\u2019anomenar igual que la classe (respectant maj\u00fascules i min\u00fascules) i mai s\u2019especifica a la seua definici\u00f3 un tipus de dades a retornar encara que siga void. El constructor admet par\u00e0metres, sent un m\u00e8tode que es pot sobrecarregar, \u00e9s a dir, podem tindre diversos constructors amb un nombre diferent de par\u00e0metres o diferents tipus de dades. Els constructors tenen com a finalitat principal la inicialitzaci\u00f3 de les variables o atributs de la classe. No \u00e9s obligatori definir un constructor a cada classe, encara que es sol fer. Aix\u00ed establim els valors que desitgem per quan un atribut de forma autom\u00e0tica a la creaci\u00f3 de l\u2019objecte, en lloc de fer-ho en un altre moment mitjan\u00e7ant altres m\u00e8todes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Empleat { private String strNom ; private String strCognom ; private String strDNI ; private double dSouBase ; public Empleat () { strDNI = \"00000000Z\" ; } public Empleat ( String NIF ) { strDNI = NIF ; } public Empleat ( String NIF , String nom , String C1 ) { strDNI = NIF ; strNom = nom ; strCognom = C1 ; } } Acc\u00e9s als membres de la classe Podrem accedir als membres d\u2019una classe en funci\u00f3 de la seua visibilitat i el lloc on es desitge accedir. Els modificadors de visibilitat s\u00f3n: public, private, protected i internal. Per accedir a un membre de la classe utilitzem el \u00ab.\u00bb (punt): NomClasse.membre Basant-nos en la classe Persona dels punts anteriors farem un programa que inst\u00e0ncie un objecte Persona i veurem com s\u2019accedeix als membres de la classes Suposem que persona t\u00e9 un constructor de la classe al qual li passem els seg\u00fcents par\u00e0metres: DNI, nom, cognom, estatura, pes i color del p\u00e8l. 1 2 3 4 5 6 7 8 9 public class Programa { public static void main ( String [] args ) { Persona manolo ; manolo = new Persona ( \"11111111A\" , \"Manolo\" , \"Garibolo\" ); manolo . tintar ( \"blau\" ); manolo . menjar (); manolo . creixer (); } } Tanmateix no podr\u00edem accedir als membres privats de la classe des de fora, per exemple, no podr\u00edem fer vicent.nom= \u00abAntonio\u00bb ja que nom \u00e9s un membre privat. La paraula reservada 'this' La paraula reservada \u00abthis\u00bb s\u2019utilitza per fer refer\u00e8ncia a l\u2019objecte actual. Si est\u00e0s dissenyant una classe, \u00abthis\u00bb fa refer\u00e8ncia a la pr\u00f2pia classe. Quan es crida a un m\u00e8tode, es passa autom\u00e0ticament un argument impl\u00edcit que \u00e9s una refer\u00e8ncia a l\u2019objecte invocat, \u00e9s a dir, l\u2019objecte sobre el que es crida al m\u00e8tode. Aquesta refer\u00e8ncia \u00e9s \u00abthis\u00bb. Amb els atributs de la classe tamb\u00e9 passa el mateix. Per comprendre-ho millor, mirem el seg\u00fcent exemple: 1 2 3 4 5 6 7 8 9 10 11 public class Persona { public String nom ; public String cognom ; public String DNI ; public Persona ( String nom , String cognom , String DNI ) { this . nom = nom ; this . cognom = cognom ; this . DNI = DNI ; } } Aquesta paraula clau sol utilitzar-se quan hi han b\u00e9 m\u00e8todes o atributs (membres) a dues classes diferents amb el mateix nom per exemple. Desenvolupament d'un projecte en Java Vista ja un poc la teoria de com \u00e9s el paradigma de programaci\u00f3 orientada a objectes i continuant amb l\u2019activitat d'an\u00e0lisi del joc de \u00abBatalla Naval\u00bb, ha arribat el moment de desenvolupar un projecte utilitzant la metodologia POO amb el llenguatge de programaci\u00f3 Java. Donarem per suposat que les fases d\u2019an\u00e0lisi i disseny ja han sigut realitzades i disposem de l\u2019esquema UML amb el diagrama de classes del nostre joc. Per on comencem Si disposem d\u2019una eina de modelat UML, podr\u00edem a partir del diagrama de classes que ens han passat generar el codi en Java que ens serviria per poder comen\u00e7ar a programar ja el seu comportament. Existeixen m\u00faltiples eines lliures que s\u2019encarreguen de fer aquesta tasca autom\u00e0ticament com s\u00f3n: StarUML, ArgoUML, Umbrello i altres extensions que podem afegir a alguns IDEs com s\u00f3n Eclipse. Aquestes eines el que fan \u00e9s generar els esquelets de les classes amb tots els membres especificats al diagrama, \u00e9s a dir: constructors, atributs i m\u00e8todes. La qual cosa ens estalviar\u00e0 un munt de feina. Una vegada ja tenim cadascun dels esquelets de les nostres classes en fitxers, haur\u00edem de crear un nou projecte i afegir-li aquestes classes. Aquesta part es podria fer amb un IDE tipus Eclipse, NetBeans o Visual Studio Code per exemple. Arribats a aquest punt ja tenim preparat el nostre projecte i ja podem comen\u00e7ar a \u00abpicar codi\u00bb La funci\u00f3 main a Java El m\u00e8tode main a Java \u00e9s un est\u00e0ndard utilitzat per la maquina virtual de Java o JVM per iniciar la execuci\u00f3 de qualsevol programa escrit en Java. Aquest m\u00e8tode es coneix com el punt d\u2019entrada de l\u2019aplicaci\u00f3 Java. En altres paraules, per poder executar la nostra aplicaci\u00f3 \u00abBatalla Naval\u00bb haurem de tindre un m\u00e8tode main que instancie i utilitze les classes que hem creat a partir del diagrama de classes que ens han passat. Aquest m\u00e8tode main ha d\u2019estar dins d\u2019una classe, per tant, ens creem una classe nova que es diga \u00abJoc\u00bb i en ella podrem implementar el m\u00e8tode main. 1 2 3 4 5 public class Joc { public static void main ( String [] args ) { } } Main ha de ser \u00abpublic\u00bb perqu\u00e8 \u00e9s el punt d\u2019entrada a la nostra aplicaci\u00f3 i per tant ha de ser accessible de fora de la classe i ha de ser \u00abstatic\u00bb perqu\u00e8 \u00e9s un m\u00e8tode que s\u2019ha de poder cridar sense necessitat d\u2019instanciar un objecte de la classe Joc. Activitat 2. Tenda d'electrodom\u00e8stics Manolo \u00e9s el propietari d\u2019una tenda d\u2019electrodom\u00e8stics en la t\u00e9: televisors, neveres, microones, forns, llavadores, estufes i altres. A Manolo li agradaria tindre una aplicaci\u00f3 en la que puga emmagatzemar la informaci\u00f3 relativa a tots els electrodom\u00e8stics que t\u00e9 a la tenda en estoc aix\u00ed com tamb\u00e9 li agradaria tindre la informaci\u00f3 guardada de tots els clients en una agenda i quines s\u00f3n les compres que li han realitzat. De cada electrodom\u00e8stic vol saber coses com la marca, el model, el n\u00famero de refer\u00e8ncia, efici\u00e8ncia energ\u00e8tica i ja m\u00e9s espec\u00edficament la pot\u00e8ncia dels microones, el volum i l\u2019altura de les neveres aix\u00ed com si tenen o no congelador, les polzades i tipus de definici\u00f3 dels televisors, pot\u00e8ncia i volum del forn, programes de les llavadores i capacitat, potencia de les estufes etc... De cada client vol saber el seu nom, cognoms, adre\u00e7a, DNI i tots els electrodom\u00e8stics que ha comprat a la tenda. Tamb\u00e9 seria interessant poder guardar un inventari de la disponibilitat d\u2019electrodom\u00e8stics que hi han actualment. Les accions que podr\u00e0 realitzar la nostra aplicaci\u00f3 seran: donar de alta i baixa electrodom\u00e8stics i clients, comprar electrodom\u00e8stics per part dels clients, consultar l'estoc etc.. El diagrama de classes resultant de l\u2019an\u00e0lisi anterior podria ser el seg\u00fcent: Activitat 3. S\u00e8ries i Pel\u00b7l\u00edcules Imagina que volem fer una aplicaci\u00f3 sobre s\u00e8ries i pel\u00b7l\u00edcules de les distintes plataformes d\u2019streaming que existeixen en l\u2019actualitat. Aquesta aplicaci\u00f3 tindr\u00e0 usuaris que es connectaran mitjan\u00e7ant unes credencials (nick i contrasenya) i cada usuari podr\u00e0 afegir s\u00e8ries o pel\u00b7l\u00edcules, a banda de posar qualificacions amb comentaris als continguts. El nick de cada usuari d\u2019aquesta aplicaci\u00f3 ser\u00e0 el seu correu electr\u00f2nic, d\u2019aquesta forma ens assegurem un nom \u00fanic per cada usuari. Tamb\u00e9 s\u2019enregistrar\u00e0 per cada usuari el seu nom i cognoms. De cada pel\u00b7l\u00edcula ens agradaria saber: t\u00edtol, any, pa\u00eds de producci\u00f3, genere i resum de la mateixa. Els generes disponibles seran: acci\u00f3, aventures, animaci\u00f3, com\u00e8dia, documental, drama, terror, musical, rom\u00e0ntica, ci\u00e8ncia ficci\u00f3. A banda tamb\u00e9 s\u2019haur\u00e0 de guardar informaci\u00f3 relativa a les actrius i actors que intervenen aix\u00ed com tamb\u00e9 el director. De les quals haurem de saber el seu nom i cognoms aix\u00ed com tamb\u00e9 la seua nacionalitat i l\u2019any de naixement. Pel que fa les s\u00e8ries, a banda de la informaci\u00f3 que tamb\u00e9 tenen les pel\u00b7l\u00edcules, tamb\u00e9 ens agradaria saber el n\u00famero de temporades que t\u00e9, de quin any \u00e9s la temporada i quants cap\u00edtols t\u00e9 amb el seu t\u00edtol i breu sinopsis. Finalment cada usuari del nostre sistema podr\u00e0 afegir tant s\u00e8ries com pel\u00b7l\u00edcules i podr\u00e0 qualificar-les (de 0 a 10) a banda d\u2019acompanyar la qualificaci\u00f3 d\u2019un comentari al respecte. M\u00e8todes, variables i blocs statics La paraula reservada \u00abstatic\u00bb en Java \u00e9s un modificador que en Java es pot aplicar a variables, m\u00e8todes, classes i blocs de codi Variables est\u00e0tiques Una variable est\u00e0tica (static) \u00e9s una variable que pertany a la classe en la que va ser declarada i s\u2019inicialitza nom\u00e9s una vegada a l\u2019inici de l\u2019execuci\u00f3 del programa, la caracter\u00edstica principal d\u2019aquest tipus de variables \u00e9s que es pot accedir directamen amb el nom de la classe sense necessitat d\u2019instanciar un objecte. A banda tamb\u00e9: - \u00c9s una variable que pertany a la classe (variable de classe) i no a l\u2019objecte. - Les variables static s\u2019inicialitzen nom\u00e9s una vegada, a l\u2019inici de l\u2019execuci\u00f3. Aquestes variables s\u2019inicialitzaran primer abans de la inicialitzaci\u00f3 de qualsevol variable d\u2019inst\u00e0ncia. M\u00e8todes est\u00e0tics Un m\u00e8tode est\u00e0tic nom\u00e9s pot accedir a les variables o tipus de dades est\u00e0tiques i no pot accedir a les dades no est\u00e0tiques. Un m\u00e8tode est\u00e0tic nom\u00e9s pot accedir a dades est\u00e0tiques. No pot accedir a dades no est\u00e0tiques (variables d\u2019inst\u00e0ncia) Un m\u00e8tode est\u00e0tic pot cridar nom\u00e9s a m\u00e8todes est\u00e0tics i no pot invocar un m\u00e8tode no est\u00e0tic a partir d\u2019ell. Un m\u00e8tode est\u00e0tic es pot accedir directament pel nom de la classe i no es necessita crear un objecte per accedir al m\u00e8tode. Un m\u00e8tode est\u00e0tic no pot fer refer\u00e8ncia a \u00abthis\u00bb o \u00absuper\u00bb Blocs est\u00e0tics El bloc est\u00e0tic \u00e9s un bloc d\u2019instruccions dins de la classe (static { ... }) que s\u2019executa quan una classe es carrega per primera vegada en la m\u00e0quina virtual de Java (JVM). B\u00e0sicament un bloc est\u00e0tic inicialitza variables de tipus est\u00e0tic dins d\u2019una classe, de la mateixa forma que un constructor de classe ajuden a inicialitzar les variables d\u2019inst\u00e0ncia, un bloc est\u00e0tic inicialitza les variables tipus static de la classe. Sobrec\u00e0rrega d'operadors En Java \u00e9s possible sobrecarregar m\u00e8todes, \u00e9s dir, definir dos o m\u00e9s dins de la mateixa classe, que comparteix nombre i que les declaracions dels seus par\u00e0metres s\u00f3n diferents; la sobrec\u00e0rrega \u00e9s una forma de polimorfisme. En les cridades als m\u00e8todes sobrecarregats, el compilador determina quin \u00e9s el m\u00e8tode invocat basant-se en el nombre i tipus d\u2019arguments passats; per tant, els m\u00e8todes sobrecarregats han de diferir en nombre i tipus de par\u00e0metres. Quan Java troba una trucada a un m\u00e8tode sobrecarregat, s\u2019executa la versi\u00f3 del que t\u00e9 par\u00e0metres (n\u00famero i tipus) que coincideixen amb els arguments utilitzats en la trucada. Sobrecarrega de constructors En Java es possible sobrecarregar m\u00e8todes, \u00e9s dir, definir dos o m\u00e9s dins de la mateixa classe, que comparteixen nombre i que les declaracions dels seus par\u00e0metres s\u00f3n diferents; la sobrec\u00e0rrega \u00e9s una forma de polimorfisme. La classe descriu un conjunt d'objectes amb les mateixes propietats i comportament; quan l\u2019objecte es crea, es inicialitza amb valors predeterminats o amb els que es transmeten en el moment de la inst\u00e0ncia; el m\u00e8tode que realitza la inicialitzaci\u00f3 de l\u2019objecte \u00e9s el constructor, aquest t\u00e9 el mateix nombre que la classe i no t\u00e9 tipus de retorn. A m\u00e9s de la sobrec\u00e0rrega de m\u00e8todes normals, es poden sobrecarregar els constructors; estos \u00faltims normalment es sobrecarregaran a la majoria de les classes creades, encara que no es regla; fins i tot una classe pot definir-se sense constructor i, per ende, sense arguments.","title":"Tema 6. Programaci\u00f3 Orientada a Objectes."},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#tema-6-programacio-orientada-a-objectes","text":"","title":"Tema 6. Programaci\u00f3 Orientada a Objectes."},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#introduccio","text":"La programaci\u00f3 orientada a objectes tamb\u00e9 coneguda com POO \u00e9s el paradigma de programaci\u00f3 que m\u00e9s s\u2019utilitza hui en dia i que permet modelar de manera m\u00e9s eficient la realitat des del punt de vista del programari. La programaci\u00f3 orientada a objectes intenta proporcionar un model de programaci\u00f3 basat en objectes que contenen dades i procediments associats coneguts com a m\u00e8todes. Aquests objectes, que s\u00f3n inst\u00e0ncies de les classes, s\u00f3n tipus abstractes de dades que encapsulen (amaguen) tant les dades com les funcions per accedir-hi. Un dels objectius de la programaci\u00f3 orientada a objectes \u00e9s reflectir la realitat, de forma que els elements d\u2019un programa s\u2019ajusten a elements de la vida quotidiana. Per exemple, suposem que volem realitzar una aplicaci\u00f3 per un taller de vehicles. En un programa estructurat definir\u00edem funcions independentment de les dades, tal que per un costat crear\u00edem el codi de la funci\u00f3 i posteriorment al programa principal s\u2019establiria una variable o variables sobre les que aplicar\u00edem canvis, podria ser un array d\u2019una estructura a la que guardar\u00edem tipus de vehicle, matr\u00edcula, color, etc. En programaci\u00f3 orientada a objectes creem un objecte que simula un cotxe amb les seues caracter\u00edstiques generals i les funcions incloses, tal que en la funci\u00f3 principal de la nostra aplicaci\u00f3, crearem variables d\u2019aquest objecte i usarem els m\u00e8todes aplicats a unes dades concretes a cada moment. La programaci\u00f3 orientada a objectes permet la creaci\u00f3 de programari cada vegada m\u00e9s complexe a partir d\u2019unitats o blocs de codi reutilitzables.","title":"Introducci\u00f3"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#caracteristiques-principals","text":"Les propietats principals o caracter\u00edstiques fonamentals del paradigma de programaci\u00f3 orientada a objectes s\u00f3n:","title":"Caracter\u00edstiques principals"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#abstraccio","text":"Abstraure's \u00e9s a\u00efllar mentalment, considerar separadament (un o diversos atributs o qualitats) d'una cosa. Per exemple abstraure els conceptes m\u00e9s importants d'un discurs, \u00e9s a dir, quedar-se amb el important. En programaci\u00f3 orientada a objectes abstraure\u2019s, l\u2019abstracci\u00f3, seria mostrar \u00fanicament les caracter\u00edstiques essencials, que fa l\u2019objecte i per a que es crea, deixant de banda elements com la implementaci\u00f3. L\u2019abstracci\u00f3 permet representar les caracter\u00edstiques essencials d\u2019un objecte, deixant enrere aquelles que no tenen tanta import\u00e0ncia. A m\u00e9s a m\u00e9s, es centra en l\u2019objecte tal i com el coneixem en la vida real, de forma que ens centrem en all\u00f2 que es capa\u00e7 de fer per\u00f2 no en com ho fa. B\u00e0sicament, definir\u00edem l\u2019abstracci\u00f3 com la forma de descriure una entitat del m\u00f3n real sense importar la complexitat que est\u00e0 present i el poder utilitzar aquesta en qualsevol aplicaci\u00f3. Un altre exemple d'abstracci\u00f3:","title":"Abstracci\u00f3"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#encapsulament","text":"L\u2019encapsulament \u00e9s, en altres paraules, l\u2019ocultaci\u00f3 d\u2019informaci\u00f3, de forma que les dades internes d\u2019un objecte estan ocultes al m\u00f3n exterior, nom\u00e9s es coneix d\u2019ell la seua ess\u00e8ncia, \u00e9s a dir, qu\u00e8 podem fer amb ell. Per exemple, amb freq\u00fc\u00e8ncia es desenvolupa codi font o projectes en els que utilitzem la classe out, m\u00e9s concretament el m\u00e8tode println. Out es troba dins de l\u2019espai de noms (namespace) System i no \u00e9s m\u00e9s que una classe d\u2019aquest paquet. Dit en altres paraules. Out \u00e9s una classe i println() \u00e9s un m\u00e8tode de la classe Out.","title":"Encapsulament"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#modularitat","text":"Aquesta propietat fa refer\u00e8ncia a la forma en la que els elements en programaci\u00f3 orientada a objectes es troben organitzats en m\u00f2duls, facilitant aix\u00ed l\u2019encapsulament i abstracci\u00f3 de la informaci\u00f3. La modularitat permet dividir una aplicaci\u00f3 en parts. Aquestes parts han de ser tan independents com puguen de la resta de m\u00f2duls aix\u00ed com tamb\u00e9 de l\u2019aplicaci\u00f3 principal. El motiu pel qual els m\u00f2duls han de ser el m\u00e9s independents possibles de l\u2019aplicaci\u00f3 \u00e9s perqu\u00e8 aix\u00ed es podran reutilitzar en altres aplicacions m\u00e9s endavant.","title":"Modularitat"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#jerarquia-i-herencia","text":"La jerarquia \u00e9s la propietat de la programaci\u00f3 orientada a objectes respecte de la relaci\u00f3 o ordre existent entre les distintes classes i objectes. El mecanisme principal per tal d\u2019ordenar les classes als nostres projectes \u00e9s l\u2019her\u00e8ncia. Podem parlar d\u2019her\u00e8ncia entre classes quan elements d\u2019una classe (superclasse) son heretats per una altra o incl\u00f2s els seus m\u00e8todes poden ser sobrecarregats. Suposem una aplicaci\u00f3 d\u2019un taller de vehicles en el qual treballen moltes persones per\u00f2 cadascuna fa una funci\u00f3 diferent al taller. Malgrat que cadascuna es dedique a un tasca concreta i no s\u00e0piga res de la resta de feines que es fan al taller, tots els empleats s\u00f3n persones, \u00e9s a dir, tots tenen un s\u00e8rie de caracter\u00edstiques comuns: Nom, cognoms, DNI, data de naixement etc.. Mentre que al mateix temps hi ha algunes caracter\u00edstiques especifiques per a cada tipus d\u2019empleat Imaginem que tenim dos classes d\u2019empleats: els mec\u00e0nics i els comercials. Dels primers hem de guardar informaci\u00f3 del nombre d\u2019hores extra que fa al mes mentre que dels segons hem de gestionar informaci\u00f3 sobre les cites que t\u00e9 amb clients durant la setmana.","title":"Jerarquia i her\u00e8ncia"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#polimorfisme","text":"Polimorfisme \u00e9s una paraula grega que significa \u00abmoltes formes\u00bb. Aquesta paraula \u00e9s ideal per definir aquesta caracter\u00edstica de la programaci\u00f3 orientada a objectes ja que en POO podem tindre objectes amb el mateix nom que realitzen funcions distintes o implementen codi diferent. El polimorfisme \u00e9s un mecanisme que s\u2019utilitza molt en POO juntament amb l\u2019her\u00e8ncia tal que quan una classe deriva d\u2019una altra hereta les seues caracter\u00edstiques i operacions. A la classe que hereta es pot redefinir qualsevol m\u00e8tode heretat, de forma que en funci\u00f3 de la refer\u00e8ncia a objectes que usem a cada moment s\u2019estar\u00e0 executant un m\u00e8tode o un altre. Un mateix missatge enviat a objectes diferents donar\u00e0 com a resposta eixides diferents, \u00e9s a dir, si tenim diversos objectes amb m\u00e8todes similars, segons es referencie l\u2019un o l\u2019altre objecte el resultat final ser\u00e0 diferent. Per exemple seguint amb l\u2019esquema dels empleats de la nostra empresa suposem que la classe (\u00absuperclasse\u00bb) t\u00e9 un m\u00e8tode que es diu \u00abcalcularSou\u00bb, aquest m\u00e8tode l\u2019hereten tant el mec\u00e0nic com el comercial per\u00f2 el seu c\u00e0lcul seria diferent en un i l\u2019altre. El sou del mec\u00e0nic ser\u00e0 el sou base m\u00e9s el n\u00famero d\u2019hores extra multiplicades pel preu al que es paguen les hores extra, mentre que el sou del comercial seria el sou base m\u00e9s el plus.","title":"Polimorfisme"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#realitzacio-de-programes-orientats-a-objectes","text":"A partir d\u2019ara, quan hajam de resoldre un problema hem de comen\u00e7ar a pensar d\u2019una forma diferent a la que est\u00e0vem fent fins ara. En programaci\u00f3 orientada a objectes seguirem usant els mecanismes de programaci\u00f3 estructurada com ara sent\u00e8ncies repetitives, alternatives, etc.. tanmateix hem de plantejar un sistema on les dades presenten una major import\u00e0ncia. L\u2019objectiu de l\u2019orientaci\u00f3 a objectes \u00e9s plasmar la realitat de manera que programem els elements el m\u00e9s pr\u00f2xim possible a com els veiem al seu entorn natural. Aix\u00ed, quan hajam d\u2019encarar un problema d\u2019aquest tipus: Ens preguntarem sobre aquells elements dels que realment es interessant emmagatzemar informaci\u00f3, \u00e9s a dir, localitzarem els possibles objectes del nostre programa. De cada element hem de con\u00e8ixer quines s\u00f3n les seues caracter\u00edstiques o quines s\u00f3n les caracter\u00edstiques que el representen. De cada element hem de con\u00e8ixer les operacions a realitzar ja que cada conjunt de dades permetr\u00e0 la realitzaci\u00f3 d\u2019un conjunt d\u2019operacions. Finalment, desenvoluparem un entorn on utilitzarem els elements configurats. Per exemple, a l\u2019hora de desenvolupar l\u2019aplicaci\u00f3 per al un taller de reparacions de vehicles, podem resoldre les seg\u00fcents q\u00fcestions per determinar els elements que inclourem: Quins elements del taller han de ser desats o s\u2019han de tenir en compte a la nostra aplicaci\u00f3? Els vehicles i els empleats De cada element, quines dades ens interessen? Dels vehicles: l\u2019hora d\u2019entrada al taller, danys que presenta, matr\u00edcula, marca i model, etc.. de cada empleat: nom i cognoms, adre\u00e7a, sou, c\u00e0rrec, reparacions associades, etc.. A cada element, quines operacions associarem? A un vehicle podem canviar-li l\u2019oli, reparar la xapa, canviar el color, posar a punt, etc.. als empleats podem modificar-los el sou base, establir hores de treball etc.. Pel que fa a l\u2019aplicaci\u00f3 principal que utilitze aquests objectes, podem plantejar un programa que emmagatzeme de forma din\u00e0mica els vehicles que van entrant al taller, aix\u00ed com tamb\u00e9 els empleats que treballen en ell estructurar la funcionalitat mitjan\u00e7ant un men\u00fa d\u2019opcions que permeta utilitzar les operacions anteriorment plantejades per a cada objecte. Activitat 1. Batalla Naval Fes un an\u00e0lisi semblant al de l\u2019aplicaci\u00f3 del taller per\u00f2 per al joc d\u2019enfonsar la flota. Quants objectes diferents hi ha? Quines s\u00f3n les seues caracter\u00edstiques principals? Quines accions poden realitzar?","title":"Realitzaci\u00f3 de programes orientats a objectes"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#classes-i-objectes","text":"Una classe \u00e9s la definici\u00f3 d\u2019un objecte, \u00e9s l\u2019element que descriu els components d\u2019un objecte de forma general. Diem que hem creat un objecte quan donem valors i utilitzem els components definits a la classe. Per exemple, si continuem utilitzant el nostre taller de vehicles, una classe podria ser la classe cotxe, en la que es descriu de forma general aquest element de la vida quotidiana. S\u2019establiria que un cotxe es caracteritza per: Tindre rodes Tindre matricula Tindre portes Se d\u2019una marca i un model concrets. Etc.. Ara b\u00e9, si al nostre taller entra un Seat Arosa de tres portes, les caracter\u00edstiques abans esmentades adopten certs valors: Quatre m\u00e9s la de recanvi. Matricula. 1234ACB 3 portes Seat. Model Arosa Aix\u00ed tenim per un costat la classe cotxe i per l\u2019altra l\u2019objecte Seat Arosa. Alhora de crear una classe definim el que denominem propietats o atributs i m\u00e8todes de classe. Atributs: una caracter\u00edstica concreta d\u2019un objecte de la vida quotidiana. Quan s\u2019estableix un atribut a una classe, es defineix com quan cre\u00e0vem variables als nostres programes estructurats, indicant tipus de dades i nom amb el que el reconeixem. M\u00e8todes de la classe: donen funcionalitat a la classe, \u00e9s a dir, reflecteixen les operacions que aquesta pot fer sobre els atributs. Els m\u00e8todes s\u00f3n similars a les funcions o procediments que cre\u00e0vem en programaci\u00f3 estructurada per\u00f2 orientats a modificar i actuar sobre les propietats d\u2019una classe. Un objecte dona valors concrets als atributs que defineix la classe i utilitza els seus m\u00e8todes. Quan un objecte utilitza un m\u00e8tode concret es diu que aquesta enviant un missatge. D\u2019alguna manera a\u00e7\u00f2 t\u00e9 l\u00f2gica ja que estem donant una ordre a un component que reflecteix la realitat. Si a un taller hem de canviar el color d\u2019un vehicle, direm canvia el color a l\u2019operari que estiga treballant, li estem enviant un missatge de que ha de realitzar aquesta acci\u00f3 concreta. A l\u2019hora de enviar un missatge a un element concret d\u2019un objecte utilitzarem l\u2019operador punt, per exemple, arosa.canviaColor(). A sovint donem el nom d\u2019estat als valors que en un objecte t\u00e9 en un moment concret de la vida del programa on s\u2019est\u00e0 utilitzant. A m\u00e9s a m\u00e9s, quan creem un objecte, donem valors a les propietats de la classe, diem que estem instanciant aquesta classe.","title":"Classes i Objectes"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#definicio-de-classes-en-java","text":"Una vegada ja sabem que s\u00f3n les classes i els objectes veurem com es defineixen classes i instancien objectes en el llenguatge Java. Definir una classe implica donar-li nom a ella i als elements que emmagatzemen la seua informaci\u00f3, aix\u00ed com tamb\u00e9 descriure els m\u00e8todes que realitzaran les accions considerades als objectes. Les definicions o especificacions no constitueixen un codi de programa executable si no que s\u2019utilitzen per assignar mem\u00f2ria on emmagatzemar els valors dels atributs que utilitza el programa i recon\u00e8ixer els m\u00e8todes que aquesta utilitzar\u00e0; normalment es situen en arxius formant packages, utilitzant un arxiu per v\u00e0ries classes relacionades. 1 2 3 class nomClasse { llista_de_membres } - nomClasse: definit per l\u2019usuari i identifica la classe; pot incloure lletres, n\u00fameros i subratllats com qualsevol identificador. - llista_de_membres: s\u00f3n els m\u00e8todes i atributs de la classe, etc.. M\u00e9s concretament, una classe es podria definir de la seg\u00fcent manera: 1 2 3 4 5 6 7 class nomClasse { llista_de_constants ; llista_de_atributs ; constructor_de_classe ; constructor_de_c\u00f2pia ; m\u00e8todes ; } En realitat si la definici\u00f3 de les parts de la classe es fera en un altre ordre, no afectaria a la compilaci\u00f3 i execuci\u00f3 d\u2019aquesta per\u00f2 s\u00ed a la lectura del codi i el faria m\u00e9s complicat d\u2019interpretar. Exemple de classe: per tal d\u2019il\u00b7lustrar com es defineix una classe amb un exemple, definirem la classe \u2018punt\u2019. Aquesta classe determina les coordenades a les quals es troba un punt concret: x i y; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Punt { private int x ; private int y ; public Punt () { x = 0 ; y = 0 ; } public Punt ( int a , int b ) { x = a ; y = b ; } public int LlegirX () { return x ; } public int LlegirY () { return y ; } public void FixarX ( int valor ) { x = valor ; } public void FixarY ( int valor ) { y = valor ; } } Una vegada tenim la definici\u00f3 de la classe punt, instanciarem un punt concret que es troba a les coordenades 10 i 5 1 Punt a = new Punt ( 10 , 5 );","title":"Definici\u00f3 de classes en Java"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#visibilitat-dels-membres-de-la-classe","text":"Un principi fonamental en la programaci\u00f3 orientada a objectes \u00e9s l\u2019ocultaci\u00f3 de la informaci\u00f3, a\u00e7\u00f2 significa que no es pot accedir per m\u00e8todes externs de la classe a determinada informaci\u00f3 interna. El mecanisme principal per aconseguir-ho \u00e9s posar-los dins d\u2019una classe i fer-los privats i aix\u00ed nom\u00e9s es podr\u00e0 accedir a aquests des de dins de la classe Existeixen tres diferents especificacions d\u2019acc\u00e9s o modificadors de visibilitat: public (+): un m\u00e8tode o atribut t\u00e9 una visibilitat p\u00fablica quan totes les dem\u00e8s classes poden accedir a ells, b\u00e9 siga una altra classe o una subclasse. Private (-): sols es pot accedir a ells des del propi codi de la classe. Protected (#): nom\u00e9s des del propi codi de la classe o de les seues subclasses es pot accedir. Package (~): nom\u00e9s accessible per membres del paquet.","title":"Visibilitat dels membres de la classe"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#atributs","text":"Els atributs s\u00f3n les caracter\u00edstiques individuals que diferencien un objecte d\u2019un altre i determinen la seua aparen\u00e7a, estat o altres qualitats. Els atributs es desen en variables anomenades variables d\u2019inst\u00e0ncia i cada objecte particular pot tindre valors distints per a aquestes variables. Per exemple, si hem de definir una persona en base a les seues caracter\u00edstiques individuals que diferencien a una persona d\u2019una altra en el m\u00f3n real, qu\u00e8 escollir\u00edem? Segurament: estatura, color de la pell, color dels ulls, color del pel, etc.. per\u00f2 segurament tamb\u00e9 altres caracter\u00edstiques no tan visualment evidents com podrien ser: nom, cognoms, data de naixement, etc.. i altres m\u00e9s \u00abadministratives\u00bb com podria ser el DNI. Aix\u00ed ens quedaria la classe persona: 1 2 3 4 5 6 7 8 9 10 public class Persona { private String DNI ; private String nom ; private String cognoms ; private String dataNaixement ; private double estatura ; private double pes ; private String colorUlls ; private String colorCabells ; } Les variables d\u2019inst\u00e0ncia tamb\u00e9 anomenades membres s\u00f3n declarades a la classe per\u00f2 els seus valors son canviats i fixats a l\u2019objectes ja que una classe no \u00e9s m\u00e9s que un esquema que defineix com seran les persones al nostre programa. A m\u00e9s de les variables d\u2019inst\u00e0ncia hi ha variables de classe, les quals s\u2019apliquen a la classe i a totes les inst\u00e0ncies. Per exemple, el n\u00famero de rodes d\u2019un cotxe \u00e9s el mateix per a tots els objectes cotxe.","title":"Atributs"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#metodes","text":"Els m\u00e8tode s\u00f3n aquelles accions que pot realitzar la classe que estem definint. B\u00e0sicament el que fa un m\u00e8tode \u00e9s modificar l\u2019estat de l\u2019objecte mitjan\u00e7ant el canvi del valor dels seus atributs. Continuant amb la classe persona que hem definit al punt anterior, caldria que ens f\u00e9rem les seg\u00fcents q\u00fcestions: quines accions s\u00f3n les que pot realitzar la nostra persona? En que afecta eixes accions als atributs que hem escollit per definir-la? A la q\u00fcesti\u00f3 primera dir\u00edem que una persona pot: caminar, botar, c\u00f3rrer, menjar, cr\u00e9ixer, tintar-se els cabells, etc.. Pel que fa a la segon q\u00fcesti\u00f3, podr\u00edem dir que nom\u00e9s modifiquen atributs: menjar, augmentant de pes; cr\u00e9ixer, modificant l\u2019estatura i tintar-se els cabells, canviant el color del pel. Aix\u00ed la classe persona podria quedar de la seg\u00fcent forma: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Persona { // Atributs private String DNI ; private String nom ; private String cognoms ; private String dataNaixement ; private double estatura ; private double pes ; private String colorUlls ; private String colorCabells ; // M\u00e8todes public void creixer ( ) { estatura ++ ; } public void menjar ( ) { pes ++ ; } public void tintarse ( String colorNou ) { colorCabells = colorNou ; } } Fixeu-se que mentre els atributs de la classe tenen un modificador de visibilitat private, els m\u00e8todes el solen tindre public. Encara que no necess\u00e0riament ha de ser aix\u00ed sempre per\u00f2 \u00e9s molt habitual. Els m\u00e8todes a Java sempre s\u00f3n membres d\u2019una classe, no hi ha m\u00e8todes o funcions fora d\u2019aquestes. La seua implementaci\u00f3 s\u2019inclou dins del cos de la classe. Exemple: A continuaci\u00f3 modelarem una s\u00e8rie de classes geom\u00e8triques sobre les quals farem una s\u00e8rie de c\u00e0lculs. Utilitzant un llenguatge de programaci\u00f3 orientada a objectes com \u00e9s Java, modelarem un triangle i un quadrat. Primer la classe triangle. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Triangle { int iTotalCostats ; private double dArea ; private double dCostat ; private double dAltura ; public Triangle () { iTotalCostats = 3 ; dCostat = 1 ; dAltura = Math . sqrt ( 3 * dCostat ) / 2 ; } public Triangle ( double dLong ) { iTotalCostats = 3 ; dCostat = dLong ; } public double getArea () { return ( dCostat * dAltura ) / 2 ; } } A continuaci\u00f3 la classe quadrat 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Quadrat { int iTotalCostats ; private double dArea ; private double dCostat ; private double dAltura ; public Quadrat () { iTotalCostats = 4 ; dCostat = 1 ; dAltura = Math . sqrt ( 3 * dCostat ) / 2 ; } public Triangle ( double dLong ) { iTotalCostats = 4 ; dCostat = dLong ; } public double getArea () { return dCostat * dAltura ; } }","title":"M\u00e8todes"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#instancies","text":"La declaraci\u00f3 d\u2019una classe no \u00e9s m\u00e9s que la definici\u00f3 d\u2019una realitat utilitzant un llenguatge de programaci\u00f3 orientada a objectes. El seg\u00fcent pas seria fer \u00fas d\u2019aquesta definici\u00f3 o classe, \u00e9s a dir, instanciar o crear un objecte a partir d\u2019aquesta classe. Per tal d\u2019instanciar una classe s\u2019utilitza la seg\u00fcent sent\u00e8ncia: 1 nom_classe nom_instancia = new nom_classe ( par\u00e0metres ); La paraula \u00abnew\u00bb s\u2019encarrega de reservar espai en mem\u00f2ria i torna una refer\u00e8ncia a l\u2019adre\u00e7a de mem\u00f2ria on s\u2019ha emmagatzemat l\u2019objecte. nom_classe: en el primer cas \u00e9s el nom de la classe que es vol instanciar. A la segon part es refereix al constructor de la classe que ha de ser igual que el nom d\u2019aquesta. El constructor \u00e9s un m\u00e8tode especial de la classe i com a m\u00e8tode que \u00e9s pot rebre par\u00e0metres. nom_instancia: identificador amb el que s\u2019identificar\u00e0 l\u2019objecte instanciat. L\u2019espai reservat a mem\u00f2ria per un objecte dependr\u00e0 de la quantitat d\u2019elements o membres que continga. Quan un objecte no est\u00e0 siguen referenciat es treu de mem\u00f2ria per tal d\u2019alliberar espai pel \u00abgarbage collector\u00bb Quan creem un objecte d\u2019una classe, cada atribut ser\u00e0 inicialitzat amb els valors per defecte del tipus de dades utilitzat o b\u00e9 pel valor establert al constructor.","title":"Inst\u00e0ncies"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#constructors","text":"Un constructor \u00e9s un m\u00e8tode membre d\u2019una classe que s\u2019executa de forma autom\u00e0tica quan es crea un instancia d\u2019aquesta. El constructor d\u2019una classe es diferencia de la resta perqu\u00e8 s\u2019ha d\u2019anomenar igual que la classe (respectant maj\u00fascules i min\u00fascules) i mai s\u2019especifica a la seua definici\u00f3 un tipus de dades a retornar encara que siga void. El constructor admet par\u00e0metres, sent un m\u00e8tode que es pot sobrecarregar, \u00e9s a dir, podem tindre diversos constructors amb un nombre diferent de par\u00e0metres o diferents tipus de dades. Els constructors tenen com a finalitat principal la inicialitzaci\u00f3 de les variables o atributs de la classe. No \u00e9s obligatori definir un constructor a cada classe, encara que es sol fer. Aix\u00ed establim els valors que desitgem per quan un atribut de forma autom\u00e0tica a la creaci\u00f3 de l\u2019objecte, en lloc de fer-ho en un altre moment mitjan\u00e7ant altres m\u00e8todes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Empleat { private String strNom ; private String strCognom ; private String strDNI ; private double dSouBase ; public Empleat () { strDNI = \"00000000Z\" ; } public Empleat ( String NIF ) { strDNI = NIF ; } public Empleat ( String NIF , String nom , String C1 ) { strDNI = NIF ; strNom = nom ; strCognom = C1 ; } }","title":"Constructors"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#acces-als-membres-de-la-classe","text":"Podrem accedir als membres d\u2019una classe en funci\u00f3 de la seua visibilitat i el lloc on es desitge accedir. Els modificadors de visibilitat s\u00f3n: public, private, protected i internal. Per accedir a un membre de la classe utilitzem el \u00ab.\u00bb (punt): NomClasse.membre Basant-nos en la classe Persona dels punts anteriors farem un programa que inst\u00e0ncie un objecte Persona i veurem com s\u2019accedeix als membres de la classes Suposem que persona t\u00e9 un constructor de la classe al qual li passem els seg\u00fcents par\u00e0metres: DNI, nom, cognom, estatura, pes i color del p\u00e8l. 1 2 3 4 5 6 7 8 9 public class Programa { public static void main ( String [] args ) { Persona manolo ; manolo = new Persona ( \"11111111A\" , \"Manolo\" , \"Garibolo\" ); manolo . tintar ( \"blau\" ); manolo . menjar (); manolo . creixer (); } } Tanmateix no podr\u00edem accedir als membres privats de la classe des de fora, per exemple, no podr\u00edem fer vicent.nom= \u00abAntonio\u00bb ja que nom \u00e9s un membre privat.","title":"Acc\u00e9s als membres de la classe"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#la-paraula-reservada-this","text":"La paraula reservada \u00abthis\u00bb s\u2019utilitza per fer refer\u00e8ncia a l\u2019objecte actual. Si est\u00e0s dissenyant una classe, \u00abthis\u00bb fa refer\u00e8ncia a la pr\u00f2pia classe. Quan es crida a un m\u00e8tode, es passa autom\u00e0ticament un argument impl\u00edcit que \u00e9s una refer\u00e8ncia a l\u2019objecte invocat, \u00e9s a dir, l\u2019objecte sobre el que es crida al m\u00e8tode. Aquesta refer\u00e8ncia \u00e9s \u00abthis\u00bb. Amb els atributs de la classe tamb\u00e9 passa el mateix. Per comprendre-ho millor, mirem el seg\u00fcent exemple: 1 2 3 4 5 6 7 8 9 10 11 public class Persona { public String nom ; public String cognom ; public String DNI ; public Persona ( String nom , String cognom , String DNI ) { this . nom = nom ; this . cognom = cognom ; this . DNI = DNI ; } } Aquesta paraula clau sol utilitzar-se quan hi han b\u00e9 m\u00e8todes o atributs (membres) a dues classes diferents amb el mateix nom per exemple.","title":"La paraula reservada 'this'"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#desenvolupament-dun-projecte-en-java","text":"Vista ja un poc la teoria de com \u00e9s el paradigma de programaci\u00f3 orientada a objectes i continuant amb l\u2019activitat d'an\u00e0lisi del joc de \u00abBatalla Naval\u00bb, ha arribat el moment de desenvolupar un projecte utilitzant la metodologia POO amb el llenguatge de programaci\u00f3 Java. Donarem per suposat que les fases d\u2019an\u00e0lisi i disseny ja han sigut realitzades i disposem de l\u2019esquema UML amb el diagrama de classes del nostre joc.","title":"Desenvolupament d'un projecte en Java"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#per-on-comencem","text":"Si disposem d\u2019una eina de modelat UML, podr\u00edem a partir del diagrama de classes que ens han passat generar el codi en Java que ens serviria per poder comen\u00e7ar a programar ja el seu comportament. Existeixen m\u00faltiples eines lliures que s\u2019encarreguen de fer aquesta tasca autom\u00e0ticament com s\u00f3n: StarUML, ArgoUML, Umbrello i altres extensions que podem afegir a alguns IDEs com s\u00f3n Eclipse. Aquestes eines el que fan \u00e9s generar els esquelets de les classes amb tots els membres especificats al diagrama, \u00e9s a dir: constructors, atributs i m\u00e8todes. La qual cosa ens estalviar\u00e0 un munt de feina. Una vegada ja tenim cadascun dels esquelets de les nostres classes en fitxers, haur\u00edem de crear un nou projecte i afegir-li aquestes classes. Aquesta part es podria fer amb un IDE tipus Eclipse, NetBeans o Visual Studio Code per exemple. Arribats a aquest punt ja tenim preparat el nostre projecte i ja podem comen\u00e7ar a \u00abpicar codi\u00bb","title":"Per on comencem"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#la-funcio-main-a-java","text":"El m\u00e8tode main a Java \u00e9s un est\u00e0ndard utilitzat per la maquina virtual de Java o JVM per iniciar la execuci\u00f3 de qualsevol programa escrit en Java. Aquest m\u00e8tode es coneix com el punt d\u2019entrada de l\u2019aplicaci\u00f3 Java. En altres paraules, per poder executar la nostra aplicaci\u00f3 \u00abBatalla Naval\u00bb haurem de tindre un m\u00e8tode main que instancie i utilitze les classes que hem creat a partir del diagrama de classes que ens han passat. Aquest m\u00e8tode main ha d\u2019estar dins d\u2019una classe, per tant, ens creem una classe nova que es diga \u00abJoc\u00bb i en ella podrem implementar el m\u00e8tode main. 1 2 3 4 5 public class Joc { public static void main ( String [] args ) { } } Main ha de ser \u00abpublic\u00bb perqu\u00e8 \u00e9s el punt d\u2019entrada a la nostra aplicaci\u00f3 i per tant ha de ser accessible de fora de la classe i ha de ser \u00abstatic\u00bb perqu\u00e8 \u00e9s un m\u00e8tode que s\u2019ha de poder cridar sense necessitat d\u2019instanciar un objecte de la classe Joc.","title":"La funci\u00f3 main a Java"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#activitat-2-tenda-delectrodomestics","text":"Manolo \u00e9s el propietari d\u2019una tenda d\u2019electrodom\u00e8stics en la t\u00e9: televisors, neveres, microones, forns, llavadores, estufes i altres. A Manolo li agradaria tindre una aplicaci\u00f3 en la que puga emmagatzemar la informaci\u00f3 relativa a tots els electrodom\u00e8stics que t\u00e9 a la tenda en estoc aix\u00ed com tamb\u00e9 li agradaria tindre la informaci\u00f3 guardada de tots els clients en una agenda i quines s\u00f3n les compres que li han realitzat. De cada electrodom\u00e8stic vol saber coses com la marca, el model, el n\u00famero de refer\u00e8ncia, efici\u00e8ncia energ\u00e8tica i ja m\u00e9s espec\u00edficament la pot\u00e8ncia dels microones, el volum i l\u2019altura de les neveres aix\u00ed com si tenen o no congelador, les polzades i tipus de definici\u00f3 dels televisors, pot\u00e8ncia i volum del forn, programes de les llavadores i capacitat, potencia de les estufes etc... De cada client vol saber el seu nom, cognoms, adre\u00e7a, DNI i tots els electrodom\u00e8stics que ha comprat a la tenda. Tamb\u00e9 seria interessant poder guardar un inventari de la disponibilitat d\u2019electrodom\u00e8stics que hi han actualment. Les accions que podr\u00e0 realitzar la nostra aplicaci\u00f3 seran: donar de alta i baixa electrodom\u00e8stics i clients, comprar electrodom\u00e8stics per part dels clients, consultar l'estoc etc.. El diagrama de classes resultant de l\u2019an\u00e0lisi anterior podria ser el seg\u00fcent:","title":"Activitat 2. Tenda d'electrodom\u00e8stics"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#activitat-3-series-i-pellicules","text":"Imagina que volem fer una aplicaci\u00f3 sobre s\u00e8ries i pel\u00b7l\u00edcules de les distintes plataformes d\u2019streaming que existeixen en l\u2019actualitat. Aquesta aplicaci\u00f3 tindr\u00e0 usuaris que es connectaran mitjan\u00e7ant unes credencials (nick i contrasenya) i cada usuari podr\u00e0 afegir s\u00e8ries o pel\u00b7l\u00edcules, a banda de posar qualificacions amb comentaris als continguts. El nick de cada usuari d\u2019aquesta aplicaci\u00f3 ser\u00e0 el seu correu electr\u00f2nic, d\u2019aquesta forma ens assegurem un nom \u00fanic per cada usuari. Tamb\u00e9 s\u2019enregistrar\u00e0 per cada usuari el seu nom i cognoms. De cada pel\u00b7l\u00edcula ens agradaria saber: t\u00edtol, any, pa\u00eds de producci\u00f3, genere i resum de la mateixa. Els generes disponibles seran: acci\u00f3, aventures, animaci\u00f3, com\u00e8dia, documental, drama, terror, musical, rom\u00e0ntica, ci\u00e8ncia ficci\u00f3. A banda tamb\u00e9 s\u2019haur\u00e0 de guardar informaci\u00f3 relativa a les actrius i actors que intervenen aix\u00ed com tamb\u00e9 el director. De les quals haurem de saber el seu nom i cognoms aix\u00ed com tamb\u00e9 la seua nacionalitat i l\u2019any de naixement. Pel que fa les s\u00e8ries, a banda de la informaci\u00f3 que tamb\u00e9 tenen les pel\u00b7l\u00edcules, tamb\u00e9 ens agradaria saber el n\u00famero de temporades que t\u00e9, de quin any \u00e9s la temporada i quants cap\u00edtols t\u00e9 amb el seu t\u00edtol i breu sinopsis. Finalment cada usuari del nostre sistema podr\u00e0 afegir tant s\u00e8ries com pel\u00b7l\u00edcules i podr\u00e0 qualificar-les (de 0 a 10) a banda d\u2019acompanyar la qualificaci\u00f3 d\u2019un comentari al respecte.","title":"Activitat 3. S\u00e8ries i Pel\u00b7l\u00edcules"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#metodes-variables-i-blocs-statics","text":"La paraula reservada \u00abstatic\u00bb en Java \u00e9s un modificador que en Java es pot aplicar a variables, m\u00e8todes, classes i blocs de codi","title":"M\u00e8todes, variables i blocs statics"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#variables-estatiques","text":"Una variable est\u00e0tica (static) \u00e9s una variable que pertany a la classe en la que va ser declarada i s\u2019inicialitza nom\u00e9s una vegada a l\u2019inici de l\u2019execuci\u00f3 del programa, la caracter\u00edstica principal d\u2019aquest tipus de variables \u00e9s que es pot accedir directamen amb el nom de la classe sense necessitat d\u2019instanciar un objecte. A banda tamb\u00e9: - \u00c9s una variable que pertany a la classe (variable de classe) i no a l\u2019objecte. - Les variables static s\u2019inicialitzen nom\u00e9s una vegada, a l\u2019inici de l\u2019execuci\u00f3. Aquestes variables s\u2019inicialitzaran primer abans de la inicialitzaci\u00f3 de qualsevol variable d\u2019inst\u00e0ncia.","title":"Variables est\u00e0tiques"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#metodes-estatics","text":"Un m\u00e8tode est\u00e0tic nom\u00e9s pot accedir a les variables o tipus de dades est\u00e0tiques i no pot accedir a les dades no est\u00e0tiques. Un m\u00e8tode est\u00e0tic nom\u00e9s pot accedir a dades est\u00e0tiques. No pot accedir a dades no est\u00e0tiques (variables d\u2019inst\u00e0ncia) Un m\u00e8tode est\u00e0tic pot cridar nom\u00e9s a m\u00e8todes est\u00e0tics i no pot invocar un m\u00e8tode no est\u00e0tic a partir d\u2019ell. Un m\u00e8tode est\u00e0tic es pot accedir directament pel nom de la classe i no es necessita crear un objecte per accedir al m\u00e8tode. Un m\u00e8tode est\u00e0tic no pot fer refer\u00e8ncia a \u00abthis\u00bb o \u00absuper\u00bb","title":"M\u00e8todes est\u00e0tics"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#blocs-estatics","text":"El bloc est\u00e0tic \u00e9s un bloc d\u2019instruccions dins de la classe (static { ... }) que s\u2019executa quan una classe es carrega per primera vegada en la m\u00e0quina virtual de Java (JVM). B\u00e0sicament un bloc est\u00e0tic inicialitza variables de tipus est\u00e0tic dins d\u2019una classe, de la mateixa forma que un constructor de classe ajuden a inicialitzar les variables d\u2019inst\u00e0ncia, un bloc est\u00e0tic inicialitza les variables tipus static de la classe.","title":"Blocs est\u00e0tics"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#sobrecarrega-doperadors","text":"En Java \u00e9s possible sobrecarregar m\u00e8todes, \u00e9s dir, definir dos o m\u00e9s dins de la mateixa classe, que comparteix nombre i que les declaracions dels seus par\u00e0metres s\u00f3n diferents; la sobrec\u00e0rrega \u00e9s una forma de polimorfisme. En les cridades als m\u00e8todes sobrecarregats, el compilador determina quin \u00e9s el m\u00e8tode invocat basant-se en el nombre i tipus d\u2019arguments passats; per tant, els m\u00e8todes sobrecarregats han de diferir en nombre i tipus de par\u00e0metres. Quan Java troba una trucada a un m\u00e8tode sobrecarregat, s\u2019executa la versi\u00f3 del que t\u00e9 par\u00e0metres (n\u00famero i tipus) que coincideixen amb els arguments utilitzats en la trucada.","title":"Sobrec\u00e0rrega d'operadors"},{"location":"Tema%2006.%20Programaci%C3%B3%20Orientada%20a%20Objectes/#sobrecarrega-de-constructors","text":"En Java es possible sobrecarregar m\u00e8todes, \u00e9s dir, definir dos o m\u00e9s dins de la mateixa classe, que comparteixen nombre i que les declaracions dels seus par\u00e0metres s\u00f3n diferents; la sobrec\u00e0rrega \u00e9s una forma de polimorfisme. La classe descriu un conjunt d'objectes amb les mateixes propietats i comportament; quan l\u2019objecte es crea, es inicialitza amb valors predeterminats o amb els que es transmeten en el moment de la inst\u00e0ncia; el m\u00e8tode que realitza la inicialitzaci\u00f3 de l\u2019objecte \u00e9s el constructor, aquest t\u00e9 el mateix nombre que la classe i no t\u00e9 tipus de retorn. A m\u00e9s de la sobrec\u00e0rrega de m\u00e8todes normals, es poden sobrecarregar els constructors; estos \u00faltims normalment es sobrecarregaran a la majoria de les classes creades, encara que no es regla; fins i tot una classe pot definir-se sense constructor i, per ende, sense arguments.","title":"Sobrecarrega de constructors"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/","text":"Tema 7. Her\u00e8ncia, polimorfisme i interf\u00edcies Introducci\u00f3 Un dels mecanismes m\u00e9s potents que incorpora el paradigma de programaci\u00f3 orientada a objectes s\u00f3n l\u2019her\u00e8ncia i el polimorfisme. El primer ens permet crear una jerarquia de classes relacionades entre s\u00ed de tal forma que la quantitat de codi, especialment el codi redundant, es redueix significativament. El segon permet redefinir m\u00e8todes de tal forma que realitzen funcions diferents depenent del context en el qual es troben. En altres paraules, el polimorfisme \u00e9s el mecanisme de la programaci\u00f3 orientada a objectes que permet que una funci\u00f3 amb el mateix nom realitze tasques diferents depenent de l\u2019objecte des del qual es fa refer\u00e8ncia. Finalment tamb\u00e9 veurem com a les interf\u00edcies podrem especificar les operacions que haurien de definir-se a les classes que la implementen. Una interf\u00edcie \u00e9s un mitj\u00e0 per a que els objectes no relacionats es comuniquen entres s\u00ed. Aquestes s\u00f3n les definicions de m\u00e8todes i valors sobre els quals els objectes estan d\u2019acord per cooperar. Her\u00e8ncia En programaci\u00f3 orientada a objectes l\u2019her\u00e8ncia \u00e9s un mecanisme que permet potenciar la reutilitzaci\u00f3 i l\u2019extensibilitat en el desenvolupament de programari a banda de reduir la quantitat de codi redundant. Aquest mecanisme permet crear noves classes a partir d\u2019una classe o jerarquia de classes preexistent (ja comprovades i verificades) evitant d\u2019aquesta forma el redisseny, la modificaci\u00f3 i verificaci\u00f3 de la part ja implementada. L\u2019her\u00e8ncia facilita la creaci\u00f3 d\u2019objectes a partir d\u2019altres ja existents i implica que una subclasse obt\u00e9 tot el comportament (m\u00e8todes) i finalment els atributs (variables) de la seua superclasse. En aquest tema veurem com Java implementa el mecanisme de l\u2019her\u00e8ncia i quines s\u00f3n les opcions que ens dona. Suposem el cas en el que disposem de dues classes (amb menys classes resultaria impossible l\u2019her\u00e8ncia), una s\u2019anomenar\u00e0: classe base, superclasse o classe pare; mentre que l\u2019altra ser\u00e0 la classe derivada, subclasse o classe filla. En el nostre cas la classe pare, superclasse o classe base ser\u00e0 \u00abInstrument\u00bb i la classe derivada, filla o subclasse ser\u00e0 \u00abGuitarra\u00bb que en llenguatge natural es podria traduir com que una guitarra \u00e9s un tipus d\u2019instrument. La classe base en una jerarquia d\u2019her\u00e8ncia \u00e9s la classe que cont\u00e9 els atributs i m\u00e8todes comuns a totes les classes derivades i \u00e9s per aix\u00f2 que s\u2019evita la redund\u00e0ncia del codi que es produiria si hagu\u00e9rem de repetir codi com\u00fa a cadascuna de les subclasses, per tant, es podria deduir que una classe derivada \u00e9s de facto una ampliaci\u00f3 de les funcionalitats de la classe base ja que contindr\u00e0 tant els membres de la classe base com els que s'afegeixen de m\u00e9s a la classe derivada. Declaraci\u00f3 d'una classe derivada Per tal de declarar que una classe hereta d\u2019una altra, Java utilitza la paraula reservada \u2018extends\u2019. Mira l\u2019exemple seg\u00fcent: 1 2 3 public class Guitarra extends Instrument { } Afegim al nostre exemple dos instruments m\u00e9s; un baix i un teclat. El diagrama de classes quedaria aix\u00ed: El codi en Java resultant seria el seg\u00fcent: 1 2 3 4 5 6 7 8 9 10 11 public class Instrument { } public class Guitarra extends Instrument { } public class Baix extends Instrument { } Respecte de la visibilitat dels membre de la superclasse, les subclasses tindran acc\u00e9s als membres, siguen atributs o m\u00e8todes, public o protected mentre que no heretaran els membres privats de la classe pare. Disseny de subclasses Dissenyar \u00e9s adaptar la realitat que es vol representar a un model concret, en el nostre cas els diagrames de classes d\u2019UML. \u00c9s en aquest pas en el que s\u2019han de prendre les decisions que poden condicionar el resultat final de la nostra aplicaci\u00f3 i no sempre \u00e9s f\u00e0cil determinar quines s\u00f3n les relacions que s\u2019han d\u2019establir. \u00c9s per aix\u00f2 que cal tenir en ment sempre la seg\u00fcent m\u00e0xima: \u00abLa jerarquia de classes m\u00e9s eficient i efectiva \u00e9s aquella que minimitza el codi al redundant al m\u00e0xim i simplifica el codi\u00bb Al utilitzar el mecanisme de l\u2019her\u00e8ncia en programaci\u00f3 orientada a objectes hem d\u2019intentar sempre tindre un m\u00e0xim de membres a la superclasse i despr\u00e9s a les diferents subclasses nom\u00e9s aquells membres o atributs que fan de discriminador, \u00e9s a dir, que diferencien la classe especialitzada (o subclasse) de la classe superior. Ampliem el nostre exemple de banda de rock anterior i afegim atributs i membres a totes les classes. Per exemple cada instrument tindr\u00e0 amo, any, tipus, marca, model i clau d\u2019afinaci\u00f3. A m\u00e9s a m\u00e9s, podr\u00e0 afinar i tocar. Ja m\u00e9s espec\u00edficament d\u2019una bateria hem de saber el total de Toms que t\u00e9, el total de pedals (hi ha bateries amb doble pedal) i el total de plats a banda de poder tocar un redoble. D\u2019una guitarra hem d\u2019especificar quin ampli utilitza i quantes cordes t\u00e9 (pot tenir-ne fins 12). Finalment pel que fa al teclat, sabrem el nombre de tecles que t\u00e9 i podr\u00e0 tocar melodies. El codi resultant d\u2019aquest disseny seria el seg\u00fcent: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 public class Instrument { public Instrument () { } private String amo ; protected int any ; protected String marca ; protected String model ; protected String clauAfinacio ; public void afinar ( ) { } public void tocar ( ) { } } public class Guitarra extends Instrument { public Guitarra ( ) { } private int numCordes ; private String ampli ; public void ferSolo () { } } public class Teclat extends Instrument { public Teclat () { } private int totalTecles ; public void tocarMelodia () { } } public class Bateria extends Instrument { public Bateria () { } private int totalToms ; private int pedals ; private int totalPlats ; public void ferRedoble () { } } Del codi anterior es pot extreure la seg\u00fcent informaci\u00f3: Amo \u00e9s un atribut que no hereta cap subclasse al ser privat. Totes les subclasses tindran acc\u00e9s, encara que al codi no estiga, a any, marca, model i clauAfinaci\u00f3. Totes les subclasses quan criden als m\u00e8todes afinar i tocar, executaran el codi que hi ha a la superclasse sempre que no es s\u2019indique el contrari (sobrec\u00e0rrega) Guitarra i Bateria no tenen acc\u00e9s a l\u2019atribut totalTecles. Teclat i Bateria no tenen poden fer solos. Sobrec\u00e0rrega de m\u00e8todes a la classe derivada La sobrec\u00e0rrega de m\u00e8todes \u00e9s la creaci\u00f3 de diversos m\u00e8todes amb el mateix nom per\u00f2 amb diferent llista de tipus de par\u00e0metres. Java diferencia entre els m\u00e8todes sobrecarregats en base al n\u00famero i tipus de par\u00e0metres o arguments que t\u00e9 el m\u00e8tode i no pel tipus que retorna. classe derivada pot redefinir un m\u00e8tode de la classe base amb el mateix nom per\u00f2 una llista diferent d\u2019arguments Si pel contrari tenim un mateix m\u00e8tode amb el mateix nom i la mateixa signatura (els mateixos par\u00e0metres) el que estem fent es sobreescriure (overridint) i no sobrecarregar (overloading) Seguint amb l\u2019exemple de la nostra banda de rock mireu el seg\u00fcent codi: Com es pot observar a la imatge anterior hi ha una sobrecarrega del m\u00e8tode afinar a cada classe derivada perqu\u00e8 seria el mateix que el de la classe pare per\u00f2 amb diferents par\u00e0metres mentre que el m\u00e8tode tocar est\u00e0 sobreescrit ja que la interf\u00edcie \u00e9s id\u00e8ntica. En codi podria quedar de la seg\u00fcent forma: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 public class Instrument { public Instrument () { } private String amo ; protected int any ; protected String marca ; protected String model ; protected String clauAfinacio ; public void afinar ( ) { System . out . println ( \"Afinar la superclasse\" ); } public void tocar ( ) { System . out . println ( \"Tocar instrument\" ); } } public class Guitarra extends Instrument { public Guitarra ( ) { } private int numCordes ; private String ampli ; public void ferSolo () { } public void tocar ( ) { System . out . println ( \"Tocar Guitarra\" ); } public void afinar ( char clau ) { System . out . println ( \"Afinar guitarra en clau \" + clau ); } } public class Teclat extends Instrument { public Teclat () { } private int totalTecles ; public void tocarMelodia () { } public void tocar ( ) { System . out . println ( \"Tocar Teclat\" ); } public void afinar ( char clau ) { System . out . println ( \"Afinar teclat en clau \" + clau ); } } public class Bateria extends Instrument { public Bateria () { } private int totalToms ; private int pedals ; private int totalPlats ; public void ferRedoble () { } public void tocar ( ) { System . out . println ( \"Tocar Bateria\" ); } public void afinar ( char clau ) { System . out . println ( \"Afinar bateria en clau \" + clau ); } } Her\u00e8ncia p\u00fablica En Java tenim la possibilitat de fer protected (#) private (-) public (+) i package (~) ens determina la visibilitat dels membres d\u2019una classe. Java considera que l\u2019her\u00e8ncia \u00e9s sempre p\u00fablica i que la classe derivada tindr\u00e0 per tant acc\u00e9s als membres protected i public de la classe pare per\u00f2 no als membres privats. El fet de poder tindre elements privats a la nostra classe base seria per poder ocultar informaci\u00f3 a les classes derivades. Constructors en her\u00e8ncia De la mateixa manera que s\u2019hereten m\u00e8todes i atributs tamb\u00e9 s\u2019hereten els constructors de la classe. D\u2019aquesta forma si declarem un objecte d\u2019una classe derivada, primer s\u2019executa el constructor de la classe base i a continuaci\u00f3 s\u2019executa la part de codi de la classe derivada. Continuant amb la nostra banda de rock farem algunes modificacions. Afegim un constructor parametritzat a la classe instrument que s\u2019encarregar\u00e0 d\u2019inicialitzar els atributs amo, any, marca i model. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class Instrument { private String amo ; protected int any ; protected String marca ; protected String model ; protected String clauAfinacio ; public Instrument () { } public Instrument ( String strAmo , int iAny , String strMarca , String strModel ) { this . amo = strAmo ; this . any = iAny ; this . marca = strMarca ; this . model = strModel ; } public void afinar ( ) { System . out . println ( \"Afinar la superclasse\" ); } public void tocar ( ) { System . out . println ( \"Tocar instrument\" ); } } Per l\u2019altre costat a la classe Guitarra hi afegim tamb\u00e9 un nou constructor (sobrecarregat) amb els par\u00e0metres: amo, any, marca, model, n\u00famero de cordes i l\u2019amplificador que utilitza. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class Guitarra extends Instrument { private int numCordes ; private String ampli ; public Guitarra ( ) { } public Guitarra ( String strAmo , int iAny , String strMarca , String strModel , int iCordes , String strAmpli ) { super ( strAmo , iAny , strMarca , strModel ); this . numCordes = iCordes ; this . ampli = strAmpli ; } public void ferSolo () { } public void tocar ( ) { System . out . println ( \"Tocar Guitarra\" ); } public void afinar ( char clau ) { System . out . println ( \"Afinar guitarra en clau \" + clau ); } } Amb aquest disseny de classes podr\u00edem per exemple executar el seg\u00fcent codi 1 2 3 4 5 6 7 public class Test { public static void main ( String [] args ) { Guitarra lesPaul = new Guitarra ( \"Vicent\" , 2007 , \"Gibson\" , \"LesPaul\" , 6 , \"Marshall\" ); lesPaul . afinar ( 'R' ); lesPaul . tocar (); } } Qu\u00e8 \u00e9s el que estaria passant si ferem un tra\u00e7a? Al crear un objecte \u2018gibsonLesPaul\u2019 de la classe guitarra passant-li par\u00e0metres, es cridaria al constructor de la classe guitarra. Aquest el primer que faria seria cridar al constructor de la classe pare utlitzant \u2018super\u2019 per indicar-li que ha d\u2019executar el constructor de la superclasse assignant-li d\u2019aquesta forma: l\u2019amo, any, marca i model per immediatament despr\u00e9s assignar el nombre de cordes i l\u2019amplificador de la classe derivada. El m\u00e8tode super(), es crida nom\u00e9s quan s\u2019utilitzen constructors sobrecarregats per tal que execute tamb\u00e9 el constructor de la superclasse amb par\u00e0metres i no el constructor per defecte que \u00e9s el que faria si no li diguem el contrari. Exemple Que executaria el seg\u00fcent codi? A m\u00e9s a m\u00e9s, super() tamb\u00e9 ens permet cridar a m\u00e8todes de la classe pare de la seg\u00fcent forma: 1 super . metode ( argumnets ); Conversi\u00f3 entre subclasse i superclasse De vegades en programaci\u00f3 hem de poder convertir entre tipus de dades, aquest mecanisme s\u2019anomena tamb\u00e9 \u00abcast\u00bb. Per exemple si tenim un double amb valor 6,8 i volem convertir-lo en un moment determinat de la nostra aplicaci\u00f3 a un int, ho fariem de la seg\u00fcent forma: 1 2 double d = 6 , 8 ; int i = ( int ) d ; Entre objectes tamb\u00e9 existeix la possibilitat de aplicar aquest mecanisme. Al nostre model de banda de rock, ens podr\u00edem trobar amb la seg\u00fcent situaci\u00f3: 1 2 3 4 5 Instrument inst = new Instrument (); Guitarra git = new Guitarra (); Teclat tcl = new Teclat (); inst = git ; // Conversi\u00f3 autom\u00e0tica inst = tcl ; // Conversi\u00f3 autom\u00e0tica Classes no derivables: atribut final Si volem que alguna classe en concret no siga ja m\u00e9s derivable, \u00e9s a dir, que no volem que es creen m\u00e9s subclasses a partir d\u2019una classe concreta, ho indiquem utilitzant la paraula reservada \u00abfinal\u00bb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public final class Bateria extends Instrument { public Bateria () { } private int totalToms ; private int pedals ; private int totalPlats ; public void Tocar ( ) { System . out . println ( \"Tocar la bateria\" ); } public void afinar ( char clau ) { System . out . println ( \"Afinar la bateria en \" + clau ); } } Amb aquest codi aconseguim que no es puguen crear subclasses de la classe Bateria. Polimorfisme El polimorfisme (del Grec \u03c0\u03bf\u03bb\u03cd\u03c2, polys, \"molt, molts\" i \u03bc\u03bf\u03c1\u03c6\u03ae, morph\u0113, \"forma, figura\") \u00e9s una caracter\u00edstica d'alguns llenguatges de programaci\u00f3 que tenen la propietat d'enviar missatges sint\u00e0cticament iguals als objectes de diferents tipus. L'\u00fanic requisit que han de complir els objectes que s'utilitzen de manera polim\u00f2rfica \u00e9s saber respondre al missatge que se'ls hi envia. El polimorfisme permet fer refer\u00e8ncia a altres objectes de classes mitjan\u00e7ant el mateix element de programa i realitzar la mateixa operaci\u00f3 de diferents maneres d\u2019acord amb l\u2019objectes al qual es fa refer\u00e8ncia en cada moment. Si mirem la nostra banda de rock, l\u2019exemple m\u00e9s clar \u00e9s el del m\u00e8tode tocar, tots el nostres instruments poden tocar per\u00f2 cadascun ho fa d\u2019una forma diferent. Lligadura El terme lligadura es correspon a l\u2019enlla\u00e7 que es produeix entre un objecte o inst\u00e0ncia d\u2019una classe i les seues propietats. Si aquestes propietats s\u00f3n atributs, la lligadura \u00e9s refereix a la connexi\u00f3 entre l\u2019atribut i la refer\u00e8ncia a mem\u00f2ria on es trobaria el valor de l\u2019atribut en q\u00fcesti\u00f3 mentre que si estem parlant de m\u00e8todes, la lligadura \u00e9s refereix a la connexi\u00f3 entre el nom del m\u00e8tode que es pret\u00e9n executar i el codi que executaria. Per un altre costat, el temps de lligadura \u00e9s el moment en el que l\u2019atribut s\u2019associa amb el seu valor o que un m\u00e8tode s\u2019agrupa amb el seu codi corresponent. Aquest temps de lligadura pot ser \u2018est\u00e0tic\u2019 o \u2018din\u00e0mic\u2019. El primer es produeix durant la compilaci\u00f3 del programa mentre que la segona es produeix en temps d\u2019execuci\u00f3. La majoria de llenguatges de programaci\u00f3 com C utilitzen la lligadura est\u00e0tica en temps de compilaci\u00f3 mitjan\u00e7ant l\u2019enlla\u00e7ador, pel contrari els llenguatges de programaci\u00f3 que utilitzen lligadura din\u00e0mica, no determinen quin \u00e9s el codi que s\u2019executar\u00e0 en la crida al m\u00e8tode fins que arriba el moment en temps d\u2019execuci\u00f3 i \u00e9s nom\u00e9s en eixe cas en el que es determinar\u00e0 de totes les possibilitats de codi a executar (polimorfisme) quin \u00e9s el que s\u2019enlla\u00e7ar\u00e0 o lligar\u00e0 (lligadura efectiva). Java \u00e9s un llenguatge orientat a objectes que utilitza la lligadura din\u00e0mica en temps d\u2019execuci\u00f3 amb l\u2019excepci\u00f3 dels m\u00e8todes static o final que utilitzen lligadura est\u00e0tica. Classes i m\u00e8todes abstractes Les classes i m\u00e8todes abstractes s\u00f3n un \u00abfenomen\u00bb que es dona en algunes de les generalitzacions que ens apareixen quan analitzem una realitat des del punt de vista de la programaci\u00f3 orientada a objectes. \u00c9s a dir, l\u2019abstracci\u00f3 com a t\u00e8cnica en POO nom\u00e9s es pot donar en l\u2019her\u00e8ncia entre classes, concretament a les classes m\u00e9s altes de la jerarquia. Una classe abstracta \u00e9s aquella de la qual mai s\u2019instanciar\u00e0 cap objecte. Per exemple Instrument a la nostra banda de rock on o s\u2019instancia una guitarra, un baix o una bateria per\u00f2 mai un instrument com a tal. A nivell de codi l\u2019\u00fanic canvi que es produeix \u00e9s que a la classe general \u00abInstrument\u00bb se li afegeix la paraula reservada abstract com a modificador de comportament de la classe. 1 2 3 public abstract class Instrument { } Normalment els m\u00e8todes d\u2019una classe abstracta tamb\u00e9 seran abstractes. Al convertir la classe Instrument a abstracta ja no la podr\u00edem instanciar \u00e9s a dir, no podrem crear cap objecte de la classe Instrument, \u00e9s a dir, no podrem en cap moment fer Instrument ins = new Instrument(); ja que ens donaria error de compilaci\u00f3 per\u00f2 en canvi, si podr\u00edem fer Instrument ins = new Guitarra(); ja que la classe Guitarra no \u00e9s abstracta i una Guitarra \u00e9s, segons el nostre model, un instrument. M\u00e8todes Abstractes Un m\u00e8tode abstracte \u00e9s un m\u00e8tode que defineix un comportament o funcionalitat concreta per\u00f2 no especifica la seua implementaci\u00f3 i ha de ser la classe filla la que implemente el m\u00e8tode. En altres paraules, a la classe para o superclasse podem tindre m\u00e8tode tocar, public void abstract tocar(), que no tindra cap codi a la seua implementaci\u00f3 si no que ser\u00e0 la classe filla o subclasse, guitarra per exemple, la que incorpore el codi dins del seu m\u00e8tode public void tocar(). Fixeu-se que aquest \u00faltim ja no porta la paraula reservada \u00ababstract\u00bb La implementaci\u00f3 de m\u00e8todes abstractes per part de les classes filles en una jerarquia utilitzen la lligadura din\u00e0mica ja que no es possible determinar el codi que s\u2019ha d\u2019executar en temps de compilaci\u00f3. \u00das del polimorfisme Arribats a aquest punt podem treure les seg\u00fcents conclusions: que el polimorfisme ens permet que diferents objectes responguen de manera diferent al mateix missatge (m\u00e8tode amb el mateix nom) i que aquesta diferenciaci\u00f3 de quin codi executar ho fa el compilador amb lligadura din\u00e0mica (en temps d\u2019execuci\u00f3 i no de compilaci\u00f3) Per usar el polimorfisme a Java hem de seguir les seg\u00fcents regles: Crear una jerarquia de classes amb les operacions importants definies per els m\u00e8todes membre declarades com abstractes a la base. Les implementacions espec\u00edfiques dels m\u00e8todes abstractes s\u2019han de fer a les classes derivades. Les inst\u00e0ncies d\u2019aquestes classes s\u2019usen mitjan\u00e7ant una refer\u00e8ncia a la base amb lligadura din\u00e0mica la qual \u00e9s l\u2019ess\u00e8ncia del polimorfisme a Java Finalment,en realitat no \u00e9s necessari declarar abstractes els m\u00e8todes a la classe base si despr\u00e9s es redefineixen amb la mateixa signatura (nom m\u00e9s par\u00e0metres) a la classe derivada. Avantatges del polimorfisme El polimorfisme fa el seu sistema m\u00e9s flexible, sense perdre cap dels avantatges de la compilaci\u00f3 est\u00e0tica de tipus que tenen lloc en temps de compilaci\u00f3; tal \u00e9s el cas de Java. Les aplicacions m\u00e9s freq\u00fcents del polimorfisme s\u00f3n: - Especialitzaci\u00f3 de classes derivades. \u00c9s a dir, especialitzar classes que han estat definits des; per exemple: Quadrat \u00e9s una especialitzaci\u00f3 de la classe Rectangle perqu\u00e8 qualsevol quadrat \u00e9s un tipus de rectangle; aquesta classe de polimorfisme augmenta la efici\u00e8ncia de la subclasse, mentre conserva un alt grau de flexibilitat i permet un mitj\u00e0 uniforme de manejar rectangles i quadrats. - Estructures de dades heterogenis. De vegades \u00e9s \u00fatil poder manipular conjunts similars dors d'objectes; amb el polimorfisme es poden crear i gestionar f\u00e0cilment estructures de dades heterogenis que s\u00f3n f\u00e0cils de dissenyar i dibuixar, sense perdre la comprovaci\u00f3 de tipus dels elements utilitzats. - Gesti\u00f3 d'una jerarquia de classes. S\u00f3n col\u00b7leccions de classes altament estructurades amb relacions d'her\u00e8ncia que es poden estendre f\u00e0cilment. M\u00e8todes no derivables: atribut final Al context de l\u2019her\u00e8ncia, la paraula reservada final, s\u2019utilitza per protegir la redefinici\u00f3 dels m\u00e8todes de la classe base; un m\u00e8tode que t\u00e9 l\u2019atribut final, no pot tornar a definir-se a la o les classes derivades Interf\u00edcies Una interf\u00edcie en Java, \u00e9s sint\u00e0cticament similar a una classe abstracta, en la qual pot especificar un o m\u00e9s m\u00e8todes que no tenen cos. Aquests m\u00e8todes han de ser implementats per una classe perqu\u00e8 es defineixen les seues accions. Per tant, una interf\u00edcie especifica qu\u00e8 s'ha de fer, per\u00f2 no com fer-ho. Una vegada que es defineix una interf\u00edcie, qualsevol quantitat de classes pot implementar-la. A m\u00e9s, una classe pot implementar qualsevol quantitat d'interf\u00edcies. Per implementar una interf\u00edcie, una classe ha de proporcionar cossos (implementacions) per als m\u00e8todes descrits per la interf\u00edcie. Cada classe \u00e9s lliure de determinar els detalls de la seva pr\u00f2pia implementaci\u00f3. Dues classes poden implementar la mateixa interf\u00edcie de diferents maneres, per\u00f2 cada classe encara admet el mateix conjunt de m\u00e8todes. Per tant, el codi que t\u00e9. Her\u00e8ncia, polimorfisme i Interf\u00edcies coneixement de la interf\u00edcie pot usar objectes de qualsevol classe, ja que la interf\u00edcie amb aquests objectes \u00e9s la mateixa. Implementaci\u00f3 d'una interf\u00edcie La interf\u00edcie especifica el comportament com\u00fa que tenen un conjunt de dades el qual es realitza en cadascuna d\u2019elles i es coneix tamb\u00e9 com a implementaci\u00f3 d\u2019una interf\u00edcie. La sintaxis \u00e9s similar a la derivaci\u00f3 o extensi\u00f3 d\u2019una classe amb la paraula reservada implements en llo d\u2019extends. 1 2 3 4 5 Class nomClasse implements nomInterficie { // definici\u00f3 d\u2019atributs // implementaci\u00f3 dels m\u00e8todes de la classe // implementaci\u00f3 dels m\u00e8todes de la interf\u00edcies } La classe que implementa la interf\u00edcie ha d\u2019especificar el codi (la implementaci\u00f3) de cadascun dels m\u00e8todes, en cas de no fer-ho, la classe es. Her\u00e8ncia, polimorfisme i Interf\u00edcies converteix en abstracta i com a tal s\u2019ha de declarar. \u00c9s a dir, si una classe implementa una interf\u00edcie, est\u00e0 obligada a implementar tots els seus m\u00e8todes. Per tal d\u2019il\u00b7lustrar amb un exemple sobre una interf\u00edcie, utilitzarem un comandament a dist\u00e0ncia de qualsevol dispositiu electr\u00f2nic. Es suposa que des d\u2019un comandament a dist\u00e0ncia podrem: encendre i apagar el dispositiu, pujar i baixar el volum, silenciar etc.. La nostra interf\u00edcie creada amb Java podria ser com la seg\u00fcent: 1 2 3 4 5 6 7 public class Comandament { void engegar (); void apagar (); void pujarVolum ( int increment ); void baixarVolum ( int decrement ); void silenciar (); } Els m\u00e8todes declarats ac\u00ed a la interf\u00edcie Comandament deurien ser autoexplicatoris. Hem incl\u00f2s nom\u00e9s unes poques de les m\u00faltiples accions que es poden realitzar amb un comandament a dist\u00e0ncia d\u2019un dispositiu electr\u00f2nic i encara se li podrien afegir algunes m\u00e9s ben segur. No hi ha definici\u00f3 de cap dels m\u00e8todes ac\u00ed, Els m\u00e8todes declarats en una interf\u00edcie s\u00f3n sempre abstractes i sempre p\u00fablics per defecte. Ara qualsevol classe que necessite de l\u2019\u00fas de la funcionalitat prove\u00efda per Comandament nom\u00e9s ha de delcarar que implementa la interficie a m\u00e9s a m\u00e9s de definir cadascun dels m\u00e8todes que la formen. Posem per exemple una televisi\u00f3, el codi Java seria el seg\u00fcent: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class TV implements comandament { public void engegar () { // Codi necessari per engegar la televisi\u00f3 } public void apagar () { // Codi necessari per apagar la televisi\u00f3 } public void pujaVolum ( int increment ) { // Codi necessari per incrementar el volum en increment } public void baixaVolum ( int increment ) { // Codi necessari per disminuir el volum en increment } public void silenciar () { // Codi necessari per silenciar la televisi\u00f3 } } Jerarquia d'intef\u00edcies Les interf\u00edcies tamb\u00e9 es poden organitzar de forma jerarquica de manera que els m\u00e8todes siguen heredats 1 interficie extends interficie2 extends interficie3 ... Her\u00e8ncia de classes i implementaci\u00f3 d'interf\u00edcies es interf\u00edcies no s\u00f3n classes ja que especifiquen un comportament mitjan\u00e7ant m\u00e8todes per la classe que els implemente; per aix\u00f2, una classe pot heretar de la seua classe base i al mateix temps implementar una interf\u00edcie. Per exemple si tenim una classe base anomenada Electrodom\u00e8stic de la qual hereten una s\u00e8rie de classes com podrien ser: Televisi\u00f3, DVD, Microones, Forn, Nevera etc..i a m\u00e9s a m\u00e9s tamb\u00e9 disposem d\u2019una interf\u00edcie Comandament, podr\u00edem crear una aplicaci\u00f3 en la que la televisi\u00f3 herete de la classe general electrodom\u00e8stic i a banda implemente la interf\u00edcie comandament com hem vist abans. 1 public class Televisio extends Electrodomestic implements comandament { ... } Classes internes Una classe interna \u00e9s una classe que es declara dintre d\u2019una altra classe.","title":"Tema 7. Her\u00e8ncia, polimorfisme i interf\u00edcies"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#tema-7-herencia-polimorfisme-i-interficies","text":"","title":"Tema 7. Her\u00e8ncia, polimorfisme i interf\u00edcies"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#introduccio","text":"Un dels mecanismes m\u00e9s potents que incorpora el paradigma de programaci\u00f3 orientada a objectes s\u00f3n l\u2019her\u00e8ncia i el polimorfisme. El primer ens permet crear una jerarquia de classes relacionades entre s\u00ed de tal forma que la quantitat de codi, especialment el codi redundant, es redueix significativament. El segon permet redefinir m\u00e8todes de tal forma que realitzen funcions diferents depenent del context en el qual es troben. En altres paraules, el polimorfisme \u00e9s el mecanisme de la programaci\u00f3 orientada a objectes que permet que una funci\u00f3 amb el mateix nom realitze tasques diferents depenent de l\u2019objecte des del qual es fa refer\u00e8ncia. Finalment tamb\u00e9 veurem com a les interf\u00edcies podrem especificar les operacions que haurien de definir-se a les classes que la implementen. Una interf\u00edcie \u00e9s un mitj\u00e0 per a que els objectes no relacionats es comuniquen entres s\u00ed. Aquestes s\u00f3n les definicions de m\u00e8todes i valors sobre els quals els objectes estan d\u2019acord per cooperar.","title":"Introducci\u00f3"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#herencia","text":"En programaci\u00f3 orientada a objectes l\u2019her\u00e8ncia \u00e9s un mecanisme que permet potenciar la reutilitzaci\u00f3 i l\u2019extensibilitat en el desenvolupament de programari a banda de reduir la quantitat de codi redundant. Aquest mecanisme permet crear noves classes a partir d\u2019una classe o jerarquia de classes preexistent (ja comprovades i verificades) evitant d\u2019aquesta forma el redisseny, la modificaci\u00f3 i verificaci\u00f3 de la part ja implementada. L\u2019her\u00e8ncia facilita la creaci\u00f3 d\u2019objectes a partir d\u2019altres ja existents i implica que una subclasse obt\u00e9 tot el comportament (m\u00e8todes) i finalment els atributs (variables) de la seua superclasse. En aquest tema veurem com Java implementa el mecanisme de l\u2019her\u00e8ncia i quines s\u00f3n les opcions que ens dona. Suposem el cas en el que disposem de dues classes (amb menys classes resultaria impossible l\u2019her\u00e8ncia), una s\u2019anomenar\u00e0: classe base, superclasse o classe pare; mentre que l\u2019altra ser\u00e0 la classe derivada, subclasse o classe filla. En el nostre cas la classe pare, superclasse o classe base ser\u00e0 \u00abInstrument\u00bb i la classe derivada, filla o subclasse ser\u00e0 \u00abGuitarra\u00bb que en llenguatge natural es podria traduir com que una guitarra \u00e9s un tipus d\u2019instrument. La classe base en una jerarquia d\u2019her\u00e8ncia \u00e9s la classe que cont\u00e9 els atributs i m\u00e8todes comuns a totes les classes derivades i \u00e9s per aix\u00f2 que s\u2019evita la redund\u00e0ncia del codi que es produiria si hagu\u00e9rem de repetir codi com\u00fa a cadascuna de les subclasses, per tant, es podria deduir que una classe derivada \u00e9s de facto una ampliaci\u00f3 de les funcionalitats de la classe base ja que contindr\u00e0 tant els membres de la classe base com els que s'afegeixen de m\u00e9s a la classe derivada.","title":"Her\u00e8ncia"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#declaracio-duna-classe-derivada","text":"Per tal de declarar que una classe hereta d\u2019una altra, Java utilitza la paraula reservada \u2018extends\u2019. Mira l\u2019exemple seg\u00fcent: 1 2 3 public class Guitarra extends Instrument { } Afegim al nostre exemple dos instruments m\u00e9s; un baix i un teclat. El diagrama de classes quedaria aix\u00ed: El codi en Java resultant seria el seg\u00fcent: 1 2 3 4 5 6 7 8 9 10 11 public class Instrument { } public class Guitarra extends Instrument { } public class Baix extends Instrument { } Respecte de la visibilitat dels membre de la superclasse, les subclasses tindran acc\u00e9s als membres, siguen atributs o m\u00e8todes, public o protected mentre que no heretaran els membres privats de la classe pare.","title":"Declaraci\u00f3 d'una classe derivada"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#disseny-de-subclasses","text":"Dissenyar \u00e9s adaptar la realitat que es vol representar a un model concret, en el nostre cas els diagrames de classes d\u2019UML. \u00c9s en aquest pas en el que s\u2019han de prendre les decisions que poden condicionar el resultat final de la nostra aplicaci\u00f3 i no sempre \u00e9s f\u00e0cil determinar quines s\u00f3n les relacions que s\u2019han d\u2019establir. \u00c9s per aix\u00f2 que cal tenir en ment sempre la seg\u00fcent m\u00e0xima: \u00abLa jerarquia de classes m\u00e9s eficient i efectiva \u00e9s aquella que minimitza el codi al redundant al m\u00e0xim i simplifica el codi\u00bb Al utilitzar el mecanisme de l\u2019her\u00e8ncia en programaci\u00f3 orientada a objectes hem d\u2019intentar sempre tindre un m\u00e0xim de membres a la superclasse i despr\u00e9s a les diferents subclasses nom\u00e9s aquells membres o atributs que fan de discriminador, \u00e9s a dir, que diferencien la classe especialitzada (o subclasse) de la classe superior. Ampliem el nostre exemple de banda de rock anterior i afegim atributs i membres a totes les classes. Per exemple cada instrument tindr\u00e0 amo, any, tipus, marca, model i clau d\u2019afinaci\u00f3. A m\u00e9s a m\u00e9s, podr\u00e0 afinar i tocar. Ja m\u00e9s espec\u00edficament d\u2019una bateria hem de saber el total de Toms que t\u00e9, el total de pedals (hi ha bateries amb doble pedal) i el total de plats a banda de poder tocar un redoble. D\u2019una guitarra hem d\u2019especificar quin ampli utilitza i quantes cordes t\u00e9 (pot tenir-ne fins 12). Finalment pel que fa al teclat, sabrem el nombre de tecles que t\u00e9 i podr\u00e0 tocar melodies. El codi resultant d\u2019aquest disseny seria el seg\u00fcent: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 public class Instrument { public Instrument () { } private String amo ; protected int any ; protected String marca ; protected String model ; protected String clauAfinacio ; public void afinar ( ) { } public void tocar ( ) { } } public class Guitarra extends Instrument { public Guitarra ( ) { } private int numCordes ; private String ampli ; public void ferSolo () { } } public class Teclat extends Instrument { public Teclat () { } private int totalTecles ; public void tocarMelodia () { } } public class Bateria extends Instrument { public Bateria () { } private int totalToms ; private int pedals ; private int totalPlats ; public void ferRedoble () { } } Del codi anterior es pot extreure la seg\u00fcent informaci\u00f3: Amo \u00e9s un atribut que no hereta cap subclasse al ser privat. Totes les subclasses tindran acc\u00e9s, encara que al codi no estiga, a any, marca, model i clauAfinaci\u00f3. Totes les subclasses quan criden als m\u00e8todes afinar i tocar, executaran el codi que hi ha a la superclasse sempre que no es s\u2019indique el contrari (sobrec\u00e0rrega) Guitarra i Bateria no tenen acc\u00e9s a l\u2019atribut totalTecles. Teclat i Bateria no tenen poden fer solos.","title":"Disseny de subclasses"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#sobrecarrega-de-metodes-a-la-classe-derivada","text":"La sobrec\u00e0rrega de m\u00e8todes \u00e9s la creaci\u00f3 de diversos m\u00e8todes amb el mateix nom per\u00f2 amb diferent llista de tipus de par\u00e0metres. Java diferencia entre els m\u00e8todes sobrecarregats en base al n\u00famero i tipus de par\u00e0metres o arguments que t\u00e9 el m\u00e8tode i no pel tipus que retorna. classe derivada pot redefinir un m\u00e8tode de la classe base amb el mateix nom per\u00f2 una llista diferent d\u2019arguments Si pel contrari tenim un mateix m\u00e8tode amb el mateix nom i la mateixa signatura (els mateixos par\u00e0metres) el que estem fent es sobreescriure (overridint) i no sobrecarregar (overloading) Seguint amb l\u2019exemple de la nostra banda de rock mireu el seg\u00fcent codi: Com es pot observar a la imatge anterior hi ha una sobrecarrega del m\u00e8tode afinar a cada classe derivada perqu\u00e8 seria el mateix que el de la classe pare per\u00f2 amb diferents par\u00e0metres mentre que el m\u00e8tode tocar est\u00e0 sobreescrit ja que la interf\u00edcie \u00e9s id\u00e8ntica. En codi podria quedar de la seg\u00fcent forma: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 public class Instrument { public Instrument () { } private String amo ; protected int any ; protected String marca ; protected String model ; protected String clauAfinacio ; public void afinar ( ) { System . out . println ( \"Afinar la superclasse\" ); } public void tocar ( ) { System . out . println ( \"Tocar instrument\" ); } } public class Guitarra extends Instrument { public Guitarra ( ) { } private int numCordes ; private String ampli ; public void ferSolo () { } public void tocar ( ) { System . out . println ( \"Tocar Guitarra\" ); } public void afinar ( char clau ) { System . out . println ( \"Afinar guitarra en clau \" + clau ); } } public class Teclat extends Instrument { public Teclat () { } private int totalTecles ; public void tocarMelodia () { } public void tocar ( ) { System . out . println ( \"Tocar Teclat\" ); } public void afinar ( char clau ) { System . out . println ( \"Afinar teclat en clau \" + clau ); } } public class Bateria extends Instrument { public Bateria () { } private int totalToms ; private int pedals ; private int totalPlats ; public void ferRedoble () { } public void tocar ( ) { System . out . println ( \"Tocar Bateria\" ); } public void afinar ( char clau ) { System . out . println ( \"Afinar bateria en clau \" + clau ); } }","title":"Sobrec\u00e0rrega de m\u00e8todes a la classe derivada"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#herencia-publica","text":"En Java tenim la possibilitat de fer protected (#) private (-) public (+) i package (~) ens determina la visibilitat dels membres d\u2019una classe. Java considera que l\u2019her\u00e8ncia \u00e9s sempre p\u00fablica i que la classe derivada tindr\u00e0 per tant acc\u00e9s als membres protected i public de la classe pare per\u00f2 no als membres privats. El fet de poder tindre elements privats a la nostra classe base seria per poder ocultar informaci\u00f3 a les classes derivades.","title":"Her\u00e8ncia p\u00fablica"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#constructors-en-herencia","text":"De la mateixa manera que s\u2019hereten m\u00e8todes i atributs tamb\u00e9 s\u2019hereten els constructors de la classe. D\u2019aquesta forma si declarem un objecte d\u2019una classe derivada, primer s\u2019executa el constructor de la classe base i a continuaci\u00f3 s\u2019executa la part de codi de la classe derivada. Continuant amb la nostra banda de rock farem algunes modificacions. Afegim un constructor parametritzat a la classe instrument que s\u2019encarregar\u00e0 d\u2019inicialitzar els atributs amo, any, marca i model. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class Instrument { private String amo ; protected int any ; protected String marca ; protected String model ; protected String clauAfinacio ; public Instrument () { } public Instrument ( String strAmo , int iAny , String strMarca , String strModel ) { this . amo = strAmo ; this . any = iAny ; this . marca = strMarca ; this . model = strModel ; } public void afinar ( ) { System . out . println ( \"Afinar la superclasse\" ); } public void tocar ( ) { System . out . println ( \"Tocar instrument\" ); } } Per l\u2019altre costat a la classe Guitarra hi afegim tamb\u00e9 un nou constructor (sobrecarregat) amb els par\u00e0metres: amo, any, marca, model, n\u00famero de cordes i l\u2019amplificador que utilitza. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class Guitarra extends Instrument { private int numCordes ; private String ampli ; public Guitarra ( ) { } public Guitarra ( String strAmo , int iAny , String strMarca , String strModel , int iCordes , String strAmpli ) { super ( strAmo , iAny , strMarca , strModel ); this . numCordes = iCordes ; this . ampli = strAmpli ; } public void ferSolo () { } public void tocar ( ) { System . out . println ( \"Tocar Guitarra\" ); } public void afinar ( char clau ) { System . out . println ( \"Afinar guitarra en clau \" + clau ); } } Amb aquest disseny de classes podr\u00edem per exemple executar el seg\u00fcent codi 1 2 3 4 5 6 7 public class Test { public static void main ( String [] args ) { Guitarra lesPaul = new Guitarra ( \"Vicent\" , 2007 , \"Gibson\" , \"LesPaul\" , 6 , \"Marshall\" ); lesPaul . afinar ( 'R' ); lesPaul . tocar (); } } Qu\u00e8 \u00e9s el que estaria passant si ferem un tra\u00e7a? Al crear un objecte \u2018gibsonLesPaul\u2019 de la classe guitarra passant-li par\u00e0metres, es cridaria al constructor de la classe guitarra. Aquest el primer que faria seria cridar al constructor de la classe pare utlitzant \u2018super\u2019 per indicar-li que ha d\u2019executar el constructor de la superclasse assignant-li d\u2019aquesta forma: l\u2019amo, any, marca i model per immediatament despr\u00e9s assignar el nombre de cordes i l\u2019amplificador de la classe derivada. El m\u00e8tode super(), es crida nom\u00e9s quan s\u2019utilitzen constructors sobrecarregats per tal que execute tamb\u00e9 el constructor de la superclasse amb par\u00e0metres i no el constructor per defecte que \u00e9s el que faria si no li diguem el contrari.","title":"Constructors en her\u00e8ncia"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#exemple","text":"Que executaria el seg\u00fcent codi? A m\u00e9s a m\u00e9s, super() tamb\u00e9 ens permet cridar a m\u00e8todes de la classe pare de la seg\u00fcent forma: 1 super . metode ( argumnets );","title":"Exemple"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#conversio-entre-subclasse-i-superclasse","text":"De vegades en programaci\u00f3 hem de poder convertir entre tipus de dades, aquest mecanisme s\u2019anomena tamb\u00e9 \u00abcast\u00bb. Per exemple si tenim un double amb valor 6,8 i volem convertir-lo en un moment determinat de la nostra aplicaci\u00f3 a un int, ho fariem de la seg\u00fcent forma: 1 2 double d = 6 , 8 ; int i = ( int ) d ; Entre objectes tamb\u00e9 existeix la possibilitat de aplicar aquest mecanisme. Al nostre model de banda de rock, ens podr\u00edem trobar amb la seg\u00fcent situaci\u00f3: 1 2 3 4 5 Instrument inst = new Instrument (); Guitarra git = new Guitarra (); Teclat tcl = new Teclat (); inst = git ; // Conversi\u00f3 autom\u00e0tica inst = tcl ; // Conversi\u00f3 autom\u00e0tica","title":"Conversi\u00f3 entre subclasse i superclasse"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#classes-no-derivables-atribut-final","text":"Si volem que alguna classe en concret no siga ja m\u00e9s derivable, \u00e9s a dir, que no volem que es creen m\u00e9s subclasses a partir d\u2019una classe concreta, ho indiquem utilitzant la paraula reservada \u00abfinal\u00bb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public final class Bateria extends Instrument { public Bateria () { } private int totalToms ; private int pedals ; private int totalPlats ; public void Tocar ( ) { System . out . println ( \"Tocar la bateria\" ); } public void afinar ( char clau ) { System . out . println ( \"Afinar la bateria en \" + clau ); } } Amb aquest codi aconseguim que no es puguen crear subclasses de la classe Bateria.","title":"Classes no derivables: atribut final"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#polimorfisme","text":"El polimorfisme (del Grec \u03c0\u03bf\u03bb\u03cd\u03c2, polys, \"molt, molts\" i \u03bc\u03bf\u03c1\u03c6\u03ae, morph\u0113, \"forma, figura\") \u00e9s una caracter\u00edstica d'alguns llenguatges de programaci\u00f3 que tenen la propietat d'enviar missatges sint\u00e0cticament iguals als objectes de diferents tipus. L'\u00fanic requisit que han de complir els objectes que s'utilitzen de manera polim\u00f2rfica \u00e9s saber respondre al missatge que se'ls hi envia. El polimorfisme permet fer refer\u00e8ncia a altres objectes de classes mitjan\u00e7ant el mateix element de programa i realitzar la mateixa operaci\u00f3 de diferents maneres d\u2019acord amb l\u2019objectes al qual es fa refer\u00e8ncia en cada moment. Si mirem la nostra banda de rock, l\u2019exemple m\u00e9s clar \u00e9s el del m\u00e8tode tocar, tots el nostres instruments poden tocar per\u00f2 cadascun ho fa d\u2019una forma diferent.","title":"Polimorfisme"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#lligadura","text":"El terme lligadura es correspon a l\u2019enlla\u00e7 que es produeix entre un objecte o inst\u00e0ncia d\u2019una classe i les seues propietats. Si aquestes propietats s\u00f3n atributs, la lligadura \u00e9s refereix a la connexi\u00f3 entre l\u2019atribut i la refer\u00e8ncia a mem\u00f2ria on es trobaria el valor de l\u2019atribut en q\u00fcesti\u00f3 mentre que si estem parlant de m\u00e8todes, la lligadura \u00e9s refereix a la connexi\u00f3 entre el nom del m\u00e8tode que es pret\u00e9n executar i el codi que executaria. Per un altre costat, el temps de lligadura \u00e9s el moment en el que l\u2019atribut s\u2019associa amb el seu valor o que un m\u00e8tode s\u2019agrupa amb el seu codi corresponent. Aquest temps de lligadura pot ser \u2018est\u00e0tic\u2019 o \u2018din\u00e0mic\u2019. El primer es produeix durant la compilaci\u00f3 del programa mentre que la segona es produeix en temps d\u2019execuci\u00f3. La majoria de llenguatges de programaci\u00f3 com C utilitzen la lligadura est\u00e0tica en temps de compilaci\u00f3 mitjan\u00e7ant l\u2019enlla\u00e7ador, pel contrari els llenguatges de programaci\u00f3 que utilitzen lligadura din\u00e0mica, no determinen quin \u00e9s el codi que s\u2019executar\u00e0 en la crida al m\u00e8tode fins que arriba el moment en temps d\u2019execuci\u00f3 i \u00e9s nom\u00e9s en eixe cas en el que es determinar\u00e0 de totes les possibilitats de codi a executar (polimorfisme) quin \u00e9s el que s\u2019enlla\u00e7ar\u00e0 o lligar\u00e0 (lligadura efectiva). Java \u00e9s un llenguatge orientat a objectes que utilitza la lligadura din\u00e0mica en temps d\u2019execuci\u00f3 amb l\u2019excepci\u00f3 dels m\u00e8todes static o final que utilitzen lligadura est\u00e0tica.","title":"Lligadura"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#classes-i-metodes-abstractes","text":"Les classes i m\u00e8todes abstractes s\u00f3n un \u00abfenomen\u00bb que es dona en algunes de les generalitzacions que ens apareixen quan analitzem una realitat des del punt de vista de la programaci\u00f3 orientada a objectes. \u00c9s a dir, l\u2019abstracci\u00f3 com a t\u00e8cnica en POO nom\u00e9s es pot donar en l\u2019her\u00e8ncia entre classes, concretament a les classes m\u00e9s altes de la jerarquia. Una classe abstracta \u00e9s aquella de la qual mai s\u2019instanciar\u00e0 cap objecte. Per exemple Instrument a la nostra banda de rock on o s\u2019instancia una guitarra, un baix o una bateria per\u00f2 mai un instrument com a tal. A nivell de codi l\u2019\u00fanic canvi que es produeix \u00e9s que a la classe general \u00abInstrument\u00bb se li afegeix la paraula reservada abstract com a modificador de comportament de la classe. 1 2 3 public abstract class Instrument { } Normalment els m\u00e8todes d\u2019una classe abstracta tamb\u00e9 seran abstractes. Al convertir la classe Instrument a abstracta ja no la podr\u00edem instanciar \u00e9s a dir, no podrem crear cap objecte de la classe Instrument, \u00e9s a dir, no podrem en cap moment fer Instrument ins = new Instrument(); ja que ens donaria error de compilaci\u00f3 per\u00f2 en canvi, si podr\u00edem fer Instrument ins = new Guitarra(); ja que la classe Guitarra no \u00e9s abstracta i una Guitarra \u00e9s, segons el nostre model, un instrument. M\u00e8todes Abstractes Un m\u00e8tode abstracte \u00e9s un m\u00e8tode que defineix un comportament o funcionalitat concreta per\u00f2 no especifica la seua implementaci\u00f3 i ha de ser la classe filla la que implemente el m\u00e8tode. En altres paraules, a la classe para o superclasse podem tindre m\u00e8tode tocar, public void abstract tocar(), que no tindra cap codi a la seua implementaci\u00f3 si no que ser\u00e0 la classe filla o subclasse, guitarra per exemple, la que incorpore el codi dins del seu m\u00e8tode public void tocar(). Fixeu-se que aquest \u00faltim ja no porta la paraula reservada \u00ababstract\u00bb La implementaci\u00f3 de m\u00e8todes abstractes per part de les classes filles en una jerarquia utilitzen la lligadura din\u00e0mica ja que no es possible determinar el codi que s\u2019ha d\u2019executar en temps de compilaci\u00f3.","title":"Classes i m\u00e8todes abstractes"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#us-del-polimorfisme","text":"Arribats a aquest punt podem treure les seg\u00fcents conclusions: que el polimorfisme ens permet que diferents objectes responguen de manera diferent al mateix missatge (m\u00e8tode amb el mateix nom) i que aquesta diferenciaci\u00f3 de quin codi executar ho fa el compilador amb lligadura din\u00e0mica (en temps d\u2019execuci\u00f3 i no de compilaci\u00f3) Per usar el polimorfisme a Java hem de seguir les seg\u00fcents regles: Crear una jerarquia de classes amb les operacions importants definies per els m\u00e8todes membre declarades com abstractes a la base. Les implementacions espec\u00edfiques dels m\u00e8todes abstractes s\u2019han de fer a les classes derivades. Les inst\u00e0ncies d\u2019aquestes classes s\u2019usen mitjan\u00e7ant una refer\u00e8ncia a la base amb lligadura din\u00e0mica la qual \u00e9s l\u2019ess\u00e8ncia del polimorfisme a Java Finalment,en realitat no \u00e9s necessari declarar abstractes els m\u00e8todes a la classe base si despr\u00e9s es redefineixen amb la mateixa signatura (nom m\u00e9s par\u00e0metres) a la classe derivada.","title":"\u00das del polimorfisme"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#avantatges-del-polimorfisme","text":"El polimorfisme fa el seu sistema m\u00e9s flexible, sense perdre cap dels avantatges de la compilaci\u00f3 est\u00e0tica de tipus que tenen lloc en temps de compilaci\u00f3; tal \u00e9s el cas de Java. Les aplicacions m\u00e9s freq\u00fcents del polimorfisme s\u00f3n: - Especialitzaci\u00f3 de classes derivades. \u00c9s a dir, especialitzar classes que han estat definits des; per exemple: Quadrat \u00e9s una especialitzaci\u00f3 de la classe Rectangle perqu\u00e8 qualsevol quadrat \u00e9s un tipus de rectangle; aquesta classe de polimorfisme augmenta la efici\u00e8ncia de la subclasse, mentre conserva un alt grau de flexibilitat i permet un mitj\u00e0 uniforme de manejar rectangles i quadrats. - Estructures de dades heterogenis. De vegades \u00e9s \u00fatil poder manipular conjunts similars dors d'objectes; amb el polimorfisme es poden crear i gestionar f\u00e0cilment estructures de dades heterogenis que s\u00f3n f\u00e0cils de dissenyar i dibuixar, sense perdre la comprovaci\u00f3 de tipus dels elements utilitzats. - Gesti\u00f3 d'una jerarquia de classes. S\u00f3n col\u00b7leccions de classes altament estructurades amb relacions d'her\u00e8ncia que es poden estendre f\u00e0cilment.","title":"Avantatges del polimorfisme"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#metodes-no-derivables-atribut-final","text":"Al context de l\u2019her\u00e8ncia, la paraula reservada final, s\u2019utilitza per protegir la redefinici\u00f3 dels m\u00e8todes de la classe base; un m\u00e8tode que t\u00e9 l\u2019atribut final, no pot tornar a definir-se a la o les classes derivades","title":"M\u00e8todes no derivables: atribut final"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#interficies","text":"Una interf\u00edcie en Java, \u00e9s sint\u00e0cticament similar a una classe abstracta, en la qual pot especificar un o m\u00e9s m\u00e8todes que no tenen cos. Aquests m\u00e8todes han de ser implementats per una classe perqu\u00e8 es defineixen les seues accions. Per tant, una interf\u00edcie especifica qu\u00e8 s'ha de fer, per\u00f2 no com fer-ho. Una vegada que es defineix una interf\u00edcie, qualsevol quantitat de classes pot implementar-la. A m\u00e9s, una classe pot implementar qualsevol quantitat d'interf\u00edcies. Per implementar una interf\u00edcie, una classe ha de proporcionar cossos (implementacions) per als m\u00e8todes descrits per la interf\u00edcie. Cada classe \u00e9s lliure de determinar els detalls de la seva pr\u00f2pia implementaci\u00f3. Dues classes poden implementar la mateixa interf\u00edcie de diferents maneres, per\u00f2 cada classe encara admet el mateix conjunt de m\u00e8todes. Per tant, el codi que t\u00e9. Her\u00e8ncia, polimorfisme i Interf\u00edcies coneixement de la interf\u00edcie pot usar objectes de qualsevol classe, ja que la interf\u00edcie amb aquests objectes \u00e9s la mateixa.","title":"Interf\u00edcies"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#implementacio-duna-interficie","text":"La interf\u00edcie especifica el comportament com\u00fa que tenen un conjunt de dades el qual es realitza en cadascuna d\u2019elles i es coneix tamb\u00e9 com a implementaci\u00f3 d\u2019una interf\u00edcie. La sintaxis \u00e9s similar a la derivaci\u00f3 o extensi\u00f3 d\u2019una classe amb la paraula reservada implements en llo d\u2019extends. 1 2 3 4 5 Class nomClasse implements nomInterficie { // definici\u00f3 d\u2019atributs // implementaci\u00f3 dels m\u00e8todes de la classe // implementaci\u00f3 dels m\u00e8todes de la interf\u00edcies } La classe que implementa la interf\u00edcie ha d\u2019especificar el codi (la implementaci\u00f3) de cadascun dels m\u00e8todes, en cas de no fer-ho, la classe es. Her\u00e8ncia, polimorfisme i Interf\u00edcies converteix en abstracta i com a tal s\u2019ha de declarar. \u00c9s a dir, si una classe implementa una interf\u00edcie, est\u00e0 obligada a implementar tots els seus m\u00e8todes. Per tal d\u2019il\u00b7lustrar amb un exemple sobre una interf\u00edcie, utilitzarem un comandament a dist\u00e0ncia de qualsevol dispositiu electr\u00f2nic. Es suposa que des d\u2019un comandament a dist\u00e0ncia podrem: encendre i apagar el dispositiu, pujar i baixar el volum, silenciar etc.. La nostra interf\u00edcie creada amb Java podria ser com la seg\u00fcent: 1 2 3 4 5 6 7 public class Comandament { void engegar (); void apagar (); void pujarVolum ( int increment ); void baixarVolum ( int decrement ); void silenciar (); } Els m\u00e8todes declarats ac\u00ed a la interf\u00edcie Comandament deurien ser autoexplicatoris. Hem incl\u00f2s nom\u00e9s unes poques de les m\u00faltiples accions que es poden realitzar amb un comandament a dist\u00e0ncia d\u2019un dispositiu electr\u00f2nic i encara se li podrien afegir algunes m\u00e9s ben segur. No hi ha definici\u00f3 de cap dels m\u00e8todes ac\u00ed, Els m\u00e8todes declarats en una interf\u00edcie s\u00f3n sempre abstractes i sempre p\u00fablics per defecte. Ara qualsevol classe que necessite de l\u2019\u00fas de la funcionalitat prove\u00efda per Comandament nom\u00e9s ha de delcarar que implementa la interficie a m\u00e9s a m\u00e9s de definir cadascun dels m\u00e8todes que la formen. Posem per exemple una televisi\u00f3, el codi Java seria el seg\u00fcent: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class TV implements comandament { public void engegar () { // Codi necessari per engegar la televisi\u00f3 } public void apagar () { // Codi necessari per apagar la televisi\u00f3 } public void pujaVolum ( int increment ) { // Codi necessari per incrementar el volum en increment } public void baixaVolum ( int increment ) { // Codi necessari per disminuir el volum en increment } public void silenciar () { // Codi necessari per silenciar la televisi\u00f3 } }","title":"Implementaci\u00f3 d'una interf\u00edcie"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#jerarquia-dinteficies","text":"Les interf\u00edcies tamb\u00e9 es poden organitzar de forma jerarquica de manera que els m\u00e8todes siguen heredats 1 interficie extends interficie2 extends interficie3 ...","title":"Jerarquia d'intef\u00edcies"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#herencia-de-classes-i-implementacio-dinterficies","text":"es interf\u00edcies no s\u00f3n classes ja que especifiquen un comportament mitjan\u00e7ant m\u00e8todes per la classe que els implemente; per aix\u00f2, una classe pot heretar de la seua classe base i al mateix temps implementar una interf\u00edcie. Per exemple si tenim una classe base anomenada Electrodom\u00e8stic de la qual hereten una s\u00e8rie de classes com podrien ser: Televisi\u00f3, DVD, Microones, Forn, Nevera etc..i a m\u00e9s a m\u00e9s tamb\u00e9 disposem d\u2019una interf\u00edcie Comandament, podr\u00edem crear una aplicaci\u00f3 en la que la televisi\u00f3 herete de la classe general electrodom\u00e8stic i a banda implemente la interf\u00edcie comandament com hem vist abans. 1 public class Televisio extends Electrodomestic implements comandament { ... }","title":"Her\u00e8ncia de classes i implementaci\u00f3 d'interf\u00edcies"},{"location":"Tema%2007.%20Her%C3%A8ncia%2C%20polimorfisme%20i%20interf%C3%ADcies/#classes-internes","text":"Una classe interna \u00e9s una classe que es declara dintre d\u2019una altra classe.","title":"Classes internes"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/","text":"Tema 8. Entrada, eixida i excepcions Introducci\u00f3 Una part important de tot llenguatge de programaci\u00f3 \u00e9s com s\u2019establir\u00e0 el contacte amb l\u2019exterior, b\u00e9 siga mitjan\u00e7ant la consola o a trav\u00e9s del sistema de fitxers, per finalment poder actuar amb l\u2019usuari d\u2019una aplicaci\u00f3 en execuci\u00f3. Ambd\u00f3s, consola i sistema de fitxers, poden funcionar tant d\u2019entrada als nostres programes com d\u2019eixida. Java defineix una abstracci\u00f3, els streams o fluxos per tractar la comunicaci\u00f3 d\u2019informaci\u00f3 amb l\u2019exterior.. Per entendre-ho millor, un stream o flux \u00e9s com un canal de comunicaci\u00f3 entre un origen i un dest\u00ed. Per exemple suposem el cas d\u2019un programa que quan arranque haja de llegir una llista de clients d\u2019un fitxer de text per crear una agenda. En aquest cas l\u2019origen seria el fitxer de text i el dest\u00ed el programa o aplicaci\u00f3 que s\u2019encarrega d\u2019emplenar l\u2019agenda amb el llistat de clients, doncs b\u00e9, l\u2019stream en aquest escenari seria el canal de comunicaci\u00f3 que s\u2019establiria entre el fitxer de text i el programa per tal que aquest puga llegir la informaci\u00f3. En aquest tema explicarem com Java tracta mitjan\u00e7ant objectes l\u2019establiment d'aquests canals de comunicaci\u00f3 i quines s\u00f3n les operacions que hi podem fer i com s\u2019han d\u2019utilitzar aquestes abstraccions de Java. D\u2019altra banda Java tamb\u00e9 ofereix el mecanisme d\u2019excepcions per controlar els errors sobrevinguts. Una excepci\u00f3 \u00e9s un problema que es produeix en temps d\u2019execuci\u00f3. Java permet controlar aquests problemes i programar amb els try...catch la soluci\u00f3 als errors en temps d\u2019execuci\u00f3. Entrada i eixida Com hem dit abans, Java organitza la entrada i eixida mitjan\u00e7ant l\u2019\u00fas d\u2019streams, que s\u00f3n abstraccions en realitat, i aquests streams el que fan es transportar la informaci\u00f3 del programa o aplicaci\u00f3 a dispositius externs. Aquests dispositius externs poden ser b\u00e9 fitxers o incl\u00fas la consola, que es tractada com un fitxer per Java. Flux d'arxius Un arxiu o fitxer \u00e9s un conjunt de bytes que s\u00f3n emmagatzemats en un dispositiu. Un arxiu o fitxer es identificat per un nom i la descripci\u00f3 de la carpeta o directori (la ruta) que el cont\u00e9. Una de les principals finalitats dels arxius \u00e9s tindre desats en mem\u00f2ria secund\u00e0ria, quan les aplicacions ja han acabat d\u2019executar-se, i que siguen recuperables despr\u00e9s. Un fitxer s\u2019ha de poder llegir, actualitzar, esborrar registres i tornar a guardar-se de nou amb tots els canvis realitzats. Segons el dispositiu f\u00edsic que els emmagatzeme, els arxius poden ser directes o seq\u00fcencials, el primer implica que per poder accedir a qualsevol registre, hem de passar pr\u00e8viament pels anteriors, per exemple una cinta magn\u00e8tica, mentre que el segon tipus d\u2019arxiu permet l\u2019acc\u00e9s directe al registre en q\u00fcesti\u00f3 sense haver de passar pels anteriors. En Java un arxiu \u00e9s una seq\u00fcencia de bytes que contenen la informaci\u00f3 emmagatzemada. Per poder treballar amb aquestes seq\u00fcencies de bytes, Java disposa de classes com s\u00f3n els tipus b\u00e0sics (int, double, string..). D\u2019una altra banda, com ja hem explicat abans, un flux \u00e9s una abstracci\u00f3 que es refereix a una corrent (stream) de dades entre un origen (tamb\u00e9 conegut com a font o productor) i una destinaci\u00f3 o embornal (consumidor) i la connexi\u00f3 que existeix entre els dos tamb\u00e9 es coneix com a pipe o tub per on circules les dades. Quan comen\u00e7a qualsevol execuci\u00f3 d\u2019un programa Java, es creen tres objectes flux, canals pels que pot fluir informaci\u00f3 d\u2019entrada o eixida; aquests objectes estan definits a la classe System i s\u00f3n: Sytem.in: entrada est\u00e0ndard, permet l\u2019entrada de dades des del teclat.Una excepci\u00f3 \u00e9s un fallo que es produeix en temps d\u2019execuci\u00f3\u00cdndex de continguts System.out: eixida est\u00e0ndard, permet la programa imprimir per pantalla. System.err: eixida d\u2019errors, permet al programa imprimir errors per pantalla. Class File Per poder identificar d\u2019un fitxer al sistema de fitxers de qualsevol sistema operatiu, necessitem: nom i ruta. Per exemple \u2018/user/data/file.txt\u2019. El fitxer es diu file.txt i la ruta en la qual es troba \u00e9s \u2018/user/data/\u2019. Aquest identificador de fitxer \u00e9s el que es passa al constructor de la classe per tal d\u2019obrir un flux. 1 File fitxer = new File ( strPath + \"prova.txt\" ); En l\u2019exemple anterior hem utilitzat la classe File per tal d\u2019instanciar un stream al fitxer que li hem passat per par\u00e0metre \u00abprova.txt\u00bb. Compte que s\u2019ha de passar la ruta absoluta d\u2019on es troba el fitxer. Hi ha alternatives al constructor de la classe File que hem mostrat a l\u2019exemple anterior, es pot construir tamb\u00e9 amb dos par\u00e0metres: ruta i nom del fitxer o incl\u00fas indicar-li la ruta mitjan\u00e7ant un altre objecte File. Els m\u00e8todes de la classe File s\u00f3n: public bolean exists() Torna true si el fitxer existeix public boolean canWrite() Torna true si es pot escriure al fitxer. public boolean canRead() Torna true si es nom\u00e9s de lectura. public boolean isFile() Torna true si \u00e9s un fitxer. public boolean isDirectory() Torna true si \u00e9s un directori. public boolean isAbsolute() Torna true si el directori t\u00e9 ruta completa public long lenght() Torna la mida en bytes del fitxer. public long lastModified() Torna el timestamp de l\u2019\u00faltima modificaci\u00f3. public String getName() Torna una string amb el nom del fitxer. public String getPath() Torna una string amb el path del fitxer. public String getAbsolutePath() Torna la ruta absoluta del fitxer. public boolean setReadOnly() Converteix el fitxer en nom\u00e9s lectura. public boolean delete() Elimina el fitxer o directori (si est\u00e0 buit) public boolean renameTo(File nou) Canvia el nom pel del fitxer nou. public boolean mkdir() Crea el directori del fitxer. public String[] list() Torna un array d\u2019strings dels elements. Flux i jerarquia de classes Com que les possibilitats que tenim en programaci\u00f3 respecte de l\u2019\u00fas de fitxers \u00e9s ampla, podem: llegir de fitxers, escriure en fitxers, llegir per una entrada com un teclat System.in o escriure en una eixida com un monitor System.out , Java declara dues classes que deriven directament de la superclasse \u00abObject\u00bb que s\u00f3n: InputStream i OutputStream , ambdues abstractes, \u00e9s a dir, no podem instanciar cap objecte d\u2019aquestes classes. InputStream \u00e9s la base per a totes les classes definies per al flux d\u2019entrada de dades mentre que OutputStream \u00e9s la classe base per a les classes que gestionen el flux d\u2019eixida. B\u00e0sicament en la seg\u00fcent imatge podeu les principals classes derivades dels fluxos d\u2019entrada i eixida i la seua jerarquia. Arxius de baix nivell: FileInputStream i FileOutputStream Tot arxiu es pot considerar en s\u00ed mateix una seq\u00fc\u00e8ncia de bytes de baix nivell i despr\u00e9s sobre aquesta informaci\u00f3 es pot construir informaci\u00f3 de mes alt nivell per tal de processar dades m\u00e9s complexes des de tipus b\u00e0sic fins objectes. En altres paraules, si volem obrir un flux de dades a un fitxer o arxiu i volem llegir byte a byte per despr\u00e9s decidir nosaltres a nivell de programaci\u00f3 que volem fer amb aquests bytes, haur\u00edem d\u2019utilitzar aquestes classes. 1 FileInputStream fen = new FileInputStream ( strPath + \"provat.txt\" ); La classe FileInputStream s\u2019utilitza per llegir bytes o grups de bytes del fitxer associat. Tots els m\u00e8todes tenen visibilitat p\u00fablica i s\u2019ha de tenir en compte quina \u00e9s l\u2019excepci\u00f3 que llencen per controlar els possibles errors en temps d\u2019execuci\u00f3. FileOutputStream(String nombre) throws IOException; Crea un objecte inicialitzat amb el nom d\u2019arxiu que es passa com argument. FileOutputStream(String nombre, boolean sw) throws IOException; Crea un objecte inicialitzat amb el nom d\u2019arxiu que es passa per par\u00e0metre. Si sw \u00e9s true els nous bytes s\u2019afegeixen al final. FileOutputStream(File nombre) throws IOException; Crea un objecte inicialitzat amb l\u2019objecte file que es passa per par\u00e0metre. void write(byte a) throws IOException; Escriu el byte \u2018a\u2019 al flux associat. void write(byte[] s) throws IOException; Escriu l\u2019array de bytes \u2018s\u2019 al flux void write(byte[] s, int org, int len) throws IOException; Llig una seq\u00fc\u00e8ncia de bytes del flux i la desa a \u2018s\u2019 comen\u00e7ant per \u2018org\u2019 i una mida de \u2018len\u2019. Torna -1 si arriba al final del fitxer. void close()throws IOException; Tanca el flux i el fitxer queda lliure per al seu \u00fas posterior. Exemple A continuaci\u00f3 obrirem el fitxer \u00abprova.txt\u00bb amb un FileInputStream per llegir-lo i desarem el seu contingut a un fitxer d\u2019eixida \u00abresultat.txt\u00bb que obirem amb un FileOutputStream. Al fitxer d\u2019eixida, bolcarem el contingut de \u00abprova.txt\u00bb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 try { FileInputStream fen = new FileInputStream ( strPath + \"prova.txt\" ); FileOutputStream fout = new FileOutputStream ( strPath + \"resultat.txt\" ); int byteLlegit = fen . read (); while ( byteLlegit != - 1 ) { fout . write ( byteLlegit ); byteLlegit = fen . read (); } fen . close (); fout . close (); } catch ( FileNotFoundException f ) { System . out . println ( \"Fitxer no trobat\" ); } catch ( IOException e ) { System . out . println ( \"Error d'entrada eixida\" ); } Activitat. Basat en el codi anterior i fes que al fitxer resultat, el d\u2019eixida, es copie el que apareix a \u00abprova.txt\u00bb, el d\u2019entrada per\u00f2 a l\u2019inrev\u00e9s. Arxius de dades La veritat \u00e9s que treballar amb bytes quan estem parlant de fitxers o arxius que contenen informaci\u00f3 o dades de m\u00e9s nivell pot resultar incomode, ja que entre altres haur\u00edem de saber quants bytes t\u00e9 un car\u00e0cter, un enter o un doble. En Java tenim les classes DataInputStream i DataOutputStream que s\u00f3n subclasses de les classes FilterInputStream i FilterOutputStream 1 2 FileInputStream gs = new FileInputStream ( strPath + \"prova.txt\" ); DataInputStream ent = new DataInputStream ( gs ); B\u00e0sicament aquestes classes el que fan \u00e9s organitzar els bytes en tipus primitius de tal forma que ja podem treballar llegint i escrivint als fluxos: enters, car\u00e0cters, reals, cadenes etc.. public DataInputStream(InputStream entrada) throws IOException Crea un objecte associat a l\u2019stream que es passa per par\u00e0metre public final boolean readBoolean() throws IOException Torna el valor de tipus boole\u00e0 llegit public final byte readByte() throws IOException Torna el valor de tipus byte llegit public final short readShort() throws IOException Torna el valor de tipus short llegit public final char readChar() throws IOException Torna el valor de tipus char llegit public final int readInt() throws IOException Torna el valor de tipus int llegit. public final long readLong() throws IOException Torna el valor de tipus long llegit public final float readFloat() throws IOException Torna el valor de tipus float llegit public final double readDouble() throws IOException Torna el valor de tipus double llegit public final String readUTF() throws IOException Torna una cadena que es va escriure en UTF D\u2019aquesta forma ja no ens hem de preocupar de saber quants bytes de mem\u00f2ria s\u2019han de reservar per un car\u00e0cter o un enter. Per exemple si associem un DataOutputStream a un fitxer i despr\u00e9s cridem al m\u00e8tode writeInt , realment el que s\u2019est\u00e0 fent \u00e9s escriure 4 bytes d\u2019informaci\u00f3 al fitxer de la qual cosa s\u2019estaria encarregant de manera trans11parent a l\u2019usuari. 1 2 FileOutputStream fn = new FileOutputStream ( strPath + \"result.txt\" ); DataOutputStream snb = new DataOutputStream ( fn ); ||| |--|--| |public DataOutputStream(OutputStream destino) throws IOException|Crea un objecte associat a l\u2019out11putstream que es passa per par\u00e0metre| |public final void writeBoolean(boolean v) throws IOException|Escriu un boolean| |public final void writeByte(int v) throws IOException|Escriu un byte| |public final void writeShort(int v) throws IOException|Escriu un short| |public final void writeChar(int v) throws IOException|Escriu un char| |public final void writeChars(String v) throws IOException|Escriu tots els chars que cont\u00e9 la String v| |public final void writeInt(int v) throws IOException|Escriu un int |public final void writeLong(long v) throws IOException|Escriu un long| |public final void writeFloat(float v) throws IOException|Escriu un float| |public final void writeDouble(double v) throws IOException|Escriu un double| |public final void writeUTF(String cad) throws IOException|Escriu la cadena cad en format UTF| |public final int close()throws IOException|Tanca el flux| ||| A continuaci\u00f3 podem veure un exemple en el que fem \u00fas del DataOutputStream i DataInputStream. El que fa aquest exemple \u00e9s escriure a un fitxer d\u2019eixida \u00abpluges.dat\u00bb dos valors double aleatoris per despr\u00e9s llegir-los amb un DataInputStream i mostrar-los per pantalla. El codi podria ser el seg\u00fcent: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 try { FileOutputStream fos = new FileOutputStream ( strPath + \"pluges.dat\" ); DataOutputStream dos = new DataOutputStream ( fos ); double info Math . random () * 100 ; dos . writeDouble ( info ); FileInputStream fis = new FileInputStream ( strPath + \"pluges.dat\" ); DataInputStream dis = new DataInputStream ( fis ); double info2 = dis . readDouble (); System . out . println ( \"Primer valor: \" + info2 ); info2 = dis . readDouble (); System . out . println ( \"Segon valor: \" + info2 ); } catch ( FileNotFoundException e ) { System . out . println ( \"El fitxer no existeix\" ); } // Exemple 1. Dies de la setmana enum Dies { Dilluns , Dimarts , Dimecres , Dijous , Divendres , Dissabte , Diumenge } // Exemple 2. Talles de roba enum Talles { XXL , XL , L , M , S , XS } catch ( IOException e ) { System . out . println ( \"Error IO inesperat\" ); } Flux PrintStream La classe PrintStream deriva de FilterOutputStream i el valor afegit d\u2019aquesta classe derivada \u00e9s que permet afegir el car\u00e0cter final de l\u00ednia als fitxers. Aquests tipus de fluxos s\u00f3n sempre d\u2019eixida i s\u2019associen a un altre flux de bytes de m\u00e9s baix nivell 1 PrintStream ps = new PrintStream ( new FileOutputStream ( \"Complex.dat\" )); ||| |---|---| |public PrintStream(OutputStream destino)|Crea un objecte associat a qualsevol objecte d\u2019eixida per par\u00e0metre| |public PrintStream(OutputStream destino, boolean flag)| Crea un objecte associat a qualsevol objecte d\u2019eixida per par\u00e0metre. Si flag \u00e9s true, es produeix un bolcat autom\u00e0tic al escriure final de l\u00ednia.| |public void flush()|Bolca el flux actual| |ublic void print(Object obj)|Escriu la representaci\u00f3 de l\u2019objecte obj al flux| |public void print(String cad)|Escriu la cadena al flux| |public void print(char c)|Escriu un car\u00e0cter al flux| |public void println(Object obj)|Escriu la representaci\u00f3 de l\u2019objecte al flux i final de l\u00ednia| |public void println(String cad)|Escriu la cadena al flux i final de l\u00ednia| ||| Arxius de caracters: Reader i writer Reader i Writer s\u00f3n fluxos de Java orientats a car\u00e0cters. Amb aquests fluxos podem llegir i escriure car\u00e0cters o cadenes de car\u00e0cters al dispositius connectats mitjan\u00e7ant aquests fluxos. Per llegir arxius de car\u00e0cters s\u2019utilitzen fluxos derivats de la classe Reader on es declaren o sobreescriuen m\u00e8todes per la lectura de car\u00e0cters. Els m\u00e8todes m\u00e9s importants s\u00f3n: public int read() Llig un car\u00e0cter en forma d\u2019enter. Si arriba al final del fitxer torna -1 public int read(char [] b) Llig una seq\u00fcencia de car\u00e0cters fins completar l\u2019array b o llegir el final del fitxer. Torna el nombre de car\u00e0cters llegits o -1 si arriba al final de l\u2019arxiu. InputStremaReader Els fluxos de la classe IntpuStreamReader envolten a un flux de bytes; converteixen la seq\u00fc\u00e8ncia de bytes en seq\u00fc\u00e8ncia de car\u00e0cters i aix\u00ed ja no ho hem de fer nosaltres; la classe deriva directament de Reader, pel que t\u00e9 disponibles els m\u00e8todes read() de la seua classe pare per la lectura de car\u00e0cters 1 InputStreamReader ent = new InputStreamReader ( Sytem . in ); FileReader Per llegir arxius de text o de car\u00e0cters es pot crear un flux del tipus FileReader, aquesta classe deriva d\u2019InputStreamReader, hereta els m\u00e8todes read() per a llegir car\u00e0cters, el constructor t\u00e9 com entrada una cadena amb el nom de l\u2019arxiu Per exemple 1 FileReader fr = new FileReader ( \"cartes.dat\" ); En general no resulta eficient llegir directament d\u2019un flux d\u2019aquest tipus, s\u2019utilitzar\u00e0 un flux BufferedReader. BufferedReader La lectura d\u2019arxius de text es realitza amb un flux que emmagatzema els car\u00e0cters en un buffer intermedi, aquests no es lligen directament de l\u2019arxiu si no del buffer. D\u2019aquesta manera augmentem l\u2019efici\u00e8ncia a les operacions d\u2019entrada, la classe BufferReader permet crear fluxos de car\u00e0cters amb buffer que no \u00e9s m\u00e9s que una forma d\u2019organitzar el flux b\u00e0sic de car\u00e0cters del que ve el text perqu\u00e8 al crear un flux BufferReader, aquest s\u2019inicialitza com un flux de car\u00e0cters InputStreamReader o qualsevol altre. El constructor de la classe t\u00e9 un argument de tipus Reader, FileReader o InputStreamReader, el flux creat disposa d\u2019un buffer de grand\u00e0ria suficient, el qual es pot especificar en el constructor amb un segon argument encara que no fa falta. Exemples de fluxos amb buffer; Writer Els arxius de text s\u00f3n arxius de car\u00e0cters, es poden crear fluxos de bytes o de car\u00e0cters derivats de la classe abstracta Writer, la qual defineix m\u00e8todes write() per escriure arrays de car\u00e0cters o cadenes, d\u2019aquesta classe es deriva OutputStreamWriter que permet escriure car\u00e0cters en un flux de bytes al qual s\u2019associa la creaci\u00f3 de l\u2019objecte o flux. 1 OutputStreamWriter ot = new OutputStreamWriter ( new FileOutputStream ( arxiu )); No es freq\u00fcent utilitzar directament fluxos OutputStreamWriter, encara que resulta interessant perqu\u00e8 la classe FileWriter \u00e9s una extensi\u00f3 d\u2019ella. Dissenyada per escriure en un arxiu de car\u00e0cters, els fluxos d\u2019aquest tipus escriuen car\u00e0cters amb el m\u00e8tode write() a l\u2019arxiu al que s\u2019associa el flux quan es crea l\u2019objecte. 1 2 FileWriter nr = new FileWriter ( \"cartes.dat\" ); nr . write ( \"Frase qualsevol a escriure\" ); PrintWriter Els fluxos m\u00e9s utilitzats en l\u2019eixida de car\u00e0cters s\u00f3n de tipus PrintWriter, aquesta classe declara constructors per associar un flux PrintWriter amb qualsevol altre de tipus Writer o b\u00e9 OutputStream. public PrintWriter(OutputStream dest\u00ed) Crea un flux associat amb un altre d\u2019eixida a nivell de byte. public PrintWriter(Writer destino) Crea un flux associat amb un altre d\u2019eixida de car\u00e0cters de tipus Writer. La import\u00e0ncia d\u2019aquesta classe radica en que defineix m\u00e8todes print() i println() per cadascun dels tipus de dades simples, per String i per Object; la difer\u00e8ncia entre els m\u00e8todes print() i println() est\u00e0 en que el segon afegeix els car\u00e0cters de final de l\u00ednia a continuaci\u00f3 dels escrits per l\u2019argument. public void print(Object obj) Escriu la representaci\u00f3 de l\u2019objecte obj al flux public void print(String cad) Escriu la cadena al flux public void print(char c) Escriu el car\u00e0cter c al flux. public void println(Object obj) Escriu la representaci\u00f3 de l\u2019objecte obj al flux i final de l\u00ednia public void println(String cad) Escriu la cadena al flux i el final de l\u00ednia public void println(char c) Escriu el car\u00e0cter c al flux i final de l\u00ednia. Arxius d'objectes Per tal que un objecte continue existint una vegada ja hem finalitzat l\u2019execuci\u00f3 d\u2019un programa o aplicaci\u00f3 l\u2019hem de desar a un arxiu d\u2019objectes. Per poder aconseguir a\u00e7\u00f2, utilitzarem les classes ObjectInputStream i ObjectOutputStream Classe d'objecte persistent La declaraci\u00f3 de la classe els objectes de la qual van a ser persistents, han de implementar la interf\u00edcie \u00abserializable\u00bb del paquet java.io, la qual \u00e9s buida, no declara m\u00e8todes, simplement indica a la m\u00e0quina virtual de Java que les inst\u00e0ncies d\u2019aquestes classes podran gravar-se en un fitxer. 1 class racional implements serializable { ... } Flux ObjectOutputStream Els fluxos de la classe ObjectOutputStream s\u2019utilitzen per gravar objectes persistents. El m\u00e8tode writeObject() escriu qualsevol objecte d\u2019una classe serializable en el flux de bytes associat. Pot llen\u00e7ar excepcions del tipus IOException que \u00e9s necessari processar. 1 public void writeObject ( Object obj ) throws IOException ; El constructor de la classe espera un argument de tipus OutputStream, que \u00e9s la base dels fluxos d\u2019eixida a nivell de bytes, per tant, per crear aquest tipus de fluxos primer es crea un d\u2019eixida a nivell de bytes associat a un arxiu extern i a continuaci\u00f3, es passa com argument al constructor de ObjectOutputStream, per exemple: 1 2 FileOutputStream bn = new FileOutputStream ( \"dadesRac.dat\" ); ObjectOutputStream fobj = new ObjectOuputStream ( bn ); A continuaci\u00f3 es pot escriure qualsevol objecte al flux: 1 2 3 4 Persona juan = new Persona ( \"Juan\" , \"Martin\" , \"123432123X\" ); fobj . writeObject ( juan ); String str = new String ( \"Cadena de favors\" ); fobj . write ( str ); Flux ObjectInputStream El objectes guardats en arxius amb fluxos de la classe ObjectOutputStream es recuperen i lligen amb fluxos d\u2019entrada del tipus ObjectInputStream, aquesta classe \u00e9s una extensi\u00f3 d\u2019InputStream, a m\u00e9s a m\u00e9s, implementa la interf\u00edcie DataInput, per aix\u00f2 disposa de diversos m\u00e8todes d\u2019entrada (read) per cadascun dels tipus de dades com readInt() o altres. El m\u00e8tode m\u00e9s important definit per la classe ObjectInputStream \u00e9s readObject(), el qual llig un objecte del flux d\u2019entrada, \u00e9s a dir, de l\u2019arxiu associat al flux de baix nivell; l\u2019objecte llegit es va escriure en el seu moment amb el m\u00e8tode writeObject() 1 public Object readObject () throws IOException ; El constructor de fluxos ObjectInputStreeam t\u00e9 com entrada un altre flux de baix nivell de qualsevol tipus derivat d\u2019InputStream, per exemple: FileInputStream associat amb l\u2019arxiu d\u2019objectes. A continuaci\u00f3 es crea un flux d\u2019entrada per llegir els objectes de l\u2019arxiu \u00abarchivoObjects.dat\u00bb 1 ObjectInputStream obj = new ObjectInputStream ( new FileInputStream ( \"arxiuObjects.dat\" )); El constructor llen\u00e7a una excepci\u00f3 si, per exemple, l\u2019arxiu no existeix, aquella \u00e9s del tipus \u00abClassNotFoundException\u00bb o \u00abIOException\u00bb, \u00e9s necessari poder capturar aquestes excepcions Excepcions Un problema important en el desenvolupament del programari \u00e9s la gesti\u00f3 de les errades o errors. No importa quan b\u00e9 estiga planificat aquest desenvolupament i quan eficient siga l\u2019equip desenvolupador. \u00c9s una m\u00e0xima en inform\u00e0tica el fet que sempre apareixeran problemes. Aquests problemes inesperats s\u00f3n problemes o errors que apareixen en temps d\u2019execuci\u00f3, per exemple: esgotament de mem\u00f2ria o recursos, errors en els intervals dels bucles, divisions per zero, arxius no existents, etc.. Les excepcions s\u00f3n el mecanisme previst per Java per tractar aquests problemes sobrevinguts. Amb les excepcions, Java dona la possibilitat al programador salvar aquest tipus de situacions de manera controlada sense que el programa o aplicaci\u00f3 es tanque, bloquege o deixe de respondre. Condicions d'errors en programes Programar, escriure codi, m\u00e8todes, classes, etc.. que siga eficient, efica\u00e7 i lliure d\u2019errades \u00e9s altament complicat. El control d\u2019errades \u00e9s una part tant important en el disseny d\u2019aplicacions que a totes les diferents metodologia de cicle de vida software, hi ha una fase que es dedica \u00fanica i exclusivament a detectar aquestes errades i solucionar-les i aix\u00ed i tot \u00e9s impossible produir programari totalment lliure d\u2019errades. Tractament dels codis d'error Java inclou un mecanisme de gesti\u00f3 d\u2019excepcions per poder intentat cobrir possibles errades en els programes en temps d\u2019execuci\u00f3. Aquest mecanisme consisteix en capturar (catch) els errors quan es produeixen en temps d\u2019execuci\u00f3. Quan es produeix un fallo en temps d\u2019execuci\u00f3 es podrien fer tres coses: parar l\u2019execuci\u00f3 de sobte, continuar executant esperant que no passe res o establir una senyal d\u2019error que el mateix codi amb altres sent\u00e8ncies s\u2019encarregue de gestionar. Aquestes senyals que envia (throw) el programa quan es produeix alguna errada en Java s\u2019anomenen excepcions i el bloc del codi on es posen les sent\u00e8ncies per tal d\u2019intentar solucionar-lo en temps d\u2019execuci\u00f3 \u00e9s el bloc catch. Excepcions en Java Una excepci\u00f3 \u00e9s un fallo que es produeix en temps d\u2019execuci\u00f3. Si hem escrit b\u00e9 el codi per tal de gestionar aquest fallo, el flux d\u2019execuci\u00f3 passa al codi destinat a gestionar les excepcions, en cas contrari el programa acaba la seua execuci\u00f3. Aquestes excepcions es poden produir per exemple si intenten accedir a un element d\u2019un array fora dels seus l\u00edmits, si intentem obrir un fitxer que no existeix o est\u00e0 bloquejat, si dividim per zero, etc.. El model de gesti\u00f3 d\u2019excepcions a Java afegeix cinc noves paraules reservades: try, throw, throws, catch i finally. - try: bloc on es detectaran les excepcions - catch: captura les excepcions que es produiexen al bloc try - throw: expressi\u00f3 per llen\u00e7ar excepcions - throws: indica les excepcions que pot llen\u00e7ar un m\u00e8tode. - finally: bloc opcional situat despr\u00e9s del try catch Els pasos del model de control d\u2019excepcions en Java s\u00f3n: El bloc try cont\u00e9 les instruccions o part del codi susceptible de provocar algun error. Si en temps d\u2019execuci\u00f3 es produeix algun error dins de les sent\u00e8ncies que es troben dins del bloc try, es llen\u00e7a una excepci\u00f3. S\u2019executa el codi que es troba dins del bloc catch associat a la excepci\u00f3 que s\u2019ha llen\u00e7at al punt anterior. S\u2019executa el bloc finally (opcional) Exemple. Suposem una classe persona que incorporarem a la nostra aplicaci\u00f3. Aquesta classe t\u00e9 un constructor al qual se li passa el DNI, imaginem ara que de la nostra aplicaci\u00f3 instanciem un objecte de la classe persona a la qual l direm Joan per\u00f2 quan cridem al constructor de la classe no li passem un DNI, aquest \u00abmal \u00fas\u00bb de la classe Persona, llen\u00e7aria una excepci\u00f3 que hauria de capturar la nostra aplicaci\u00f3 al bloc catch i \u00e9s ac\u00ed, en aquest bloc d\u2019instruccions, en el que s\u2019hauria de corregir la situaci\u00f3 o avisar a l\u2019usuari de l\u2019aplicaci\u00f3 del que ha passat. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public void escolta () throws Exception { // Codi del metode escolta // ... throw new Exception (); } public static void main ( String [] args ) { try { escolta (); } catch ( Exception e ) { // Codi a executar quan es produeix una excepci\u00f3. } } Al codi anterior hem crear un m\u00e8tode escolta que l\u2019\u00fanic que fa \u00e9s lle\u00e7ar una excepci\u00f3. Quan al m\u00e8tode main cridem a la funci\u00f3 escolta, si volem fer \u00fas del sistema d\u2019excepcions de Java, l\u2019haurem de posar dins del bloc try. Just despr\u00e8s d\u2019acabar el conjunt d\u2019instruccions del bloc try posem un catch indicant-li quina \u00e9s la classe d\u2019excepci\u00f3 que hauriem de capturar, al nostre cas Exception, i dins del bloc catch posariem el codi que s\u2019hauria d\u2019executar en cas de produir-se eixe error. Normalment es solen posar missatges d\u2019error que alerten l\u2019usuari de l\u2019aplicaci\u00f3. A continuaci\u00f3 explicarem amb m\u00e9s detall qu\u00e8 \u00e9s el que fan cadascun dels blocs del mecanisme d\u2019excepcions que ha dissenyat Java. Bloc try Dins del bloc try s\u2019han de posar aquelles sent\u00e8ncies que poden llen\u00e7ar alguna excepci\u00f3 entre claud\u00e0tors, despr\u00e9s del claud\u00e0tor de tancament s\u2019ha de posar el bloc catch o controlador d\u2019excepcions almenys un bloc catch. Si l\u2019excepci\u00f3 que es produeix coincideix amb algun dels par\u00e0metres dels blocs catch que hi han, s\u2019executen les sent\u00e8ncies que es troben a dintre. Els blocs try, de la mateixa forma que amb totes les sent\u00e8ncies de programaci\u00f3 estructurada, es poden niar. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static void main ( String [] args ) { try { escolta (); try { tornaAEscoltar (); } catch ( Exception e ) { // Codi excepci\u00f3 interna } } catch ( Exception e ) { // Codi excepci\u00f3 externa } } A l\u2019exemple anterior \u00e9s pot observar un codi amb dos blocs try niats on el primer bloc try t\u00e9 dos blocs catch per controlar varies excepcions Bloc throw La sent\u00e8ncia throw llen\u00e7a (raise) una excepci\u00f3. Les excepcions en Java s\u00f3n objectes, per tant, una excepci\u00f3 \u00e9s una inst\u00e0ncia d\u2019una classe que deriva de la classe Exception A l\u2019exemple anterior com es pot observar es capturen dos tipus d\u2019excepcions diferents, una generica Exception i una altra FileNotFoundException. Aquesta \u00faltima es produiex normalment quan volem obrir un fitxer, amb la classe File per exemple, i aquest no existeix. Bloc catch El bloc catch o de captura d\u2019excepcions. Quan una excepci\u00f3 es llen\u00e7a des d\u2019un bloc try, si el tipus d\u2019excepci\u00f3 que s\u2019ha llen\u00e7at coincideix amb el tipus d\u2019excepci\u00f3 que s\u2019ha passat per par\u00e0metre al catch, s\u2019executarien les sent\u00e8ncies que hi han dins del bloc catch. Normalment es sol posar el codi necessari per poder eixir de la situaci\u00f3 en la que ens trobem quan s\u2019al\u00e7a una excepci\u00f3. Cl\u00e0usula finally El bloc finally en un try..catch, \u00e9s el bloc d\u2019instruccions que s\u2019executar\u00e0 sempre, hi haja excepcions o no, al final de tot el nostre codi. Normalment es solen posar sent\u00e8ncies per tal d\u2019alliberar tot all\u00f2 que pugam haver creat dins del bloc try, \u00e9s a dir, tancar fluxos, fitxers, connexions a bases de dades etc..amb la finalitat d\u2019alliberar mem\u00f2ria. Classes d'excepcions en Java Nove excepcions Java permet la creaci\u00f3 d\u2019excepcions noves que deriven de la classe base Exception","title":"Tema 8. Entrada, eixida i excepcions"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#tema-8-entrada-eixida-i-excepcions","text":"","title":"Tema 8. Entrada, eixida i excepcions"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#introduccio","text":"Una part important de tot llenguatge de programaci\u00f3 \u00e9s com s\u2019establir\u00e0 el contacte amb l\u2019exterior, b\u00e9 siga mitjan\u00e7ant la consola o a trav\u00e9s del sistema de fitxers, per finalment poder actuar amb l\u2019usuari d\u2019una aplicaci\u00f3 en execuci\u00f3. Ambd\u00f3s, consola i sistema de fitxers, poden funcionar tant d\u2019entrada als nostres programes com d\u2019eixida. Java defineix una abstracci\u00f3, els streams o fluxos per tractar la comunicaci\u00f3 d\u2019informaci\u00f3 amb l\u2019exterior.. Per entendre-ho millor, un stream o flux \u00e9s com un canal de comunicaci\u00f3 entre un origen i un dest\u00ed. Per exemple suposem el cas d\u2019un programa que quan arranque haja de llegir una llista de clients d\u2019un fitxer de text per crear una agenda. En aquest cas l\u2019origen seria el fitxer de text i el dest\u00ed el programa o aplicaci\u00f3 que s\u2019encarrega d\u2019emplenar l\u2019agenda amb el llistat de clients, doncs b\u00e9, l\u2019stream en aquest escenari seria el canal de comunicaci\u00f3 que s\u2019establiria entre el fitxer de text i el programa per tal que aquest puga llegir la informaci\u00f3. En aquest tema explicarem com Java tracta mitjan\u00e7ant objectes l\u2019establiment d'aquests canals de comunicaci\u00f3 i quines s\u00f3n les operacions que hi podem fer i com s\u2019han d\u2019utilitzar aquestes abstraccions de Java. D\u2019altra banda Java tamb\u00e9 ofereix el mecanisme d\u2019excepcions per controlar els errors sobrevinguts. Una excepci\u00f3 \u00e9s un problema que es produeix en temps d\u2019execuci\u00f3. Java permet controlar aquests problemes i programar amb els try...catch la soluci\u00f3 als errors en temps d\u2019execuci\u00f3.","title":"Introducci\u00f3"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#entrada-i-eixida","text":"Com hem dit abans, Java organitza la entrada i eixida mitjan\u00e7ant l\u2019\u00fas d\u2019streams, que s\u00f3n abstraccions en realitat, i aquests streams el que fan es transportar la informaci\u00f3 del programa o aplicaci\u00f3 a dispositius externs. Aquests dispositius externs poden ser b\u00e9 fitxers o incl\u00fas la consola, que es tractada com un fitxer per Java.","title":"Entrada i eixida"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#flux-darxius","text":"Un arxiu o fitxer \u00e9s un conjunt de bytes que s\u00f3n emmagatzemats en un dispositiu. Un arxiu o fitxer es identificat per un nom i la descripci\u00f3 de la carpeta o directori (la ruta) que el cont\u00e9. Una de les principals finalitats dels arxius \u00e9s tindre desats en mem\u00f2ria secund\u00e0ria, quan les aplicacions ja han acabat d\u2019executar-se, i que siguen recuperables despr\u00e9s. Un fitxer s\u2019ha de poder llegir, actualitzar, esborrar registres i tornar a guardar-se de nou amb tots els canvis realitzats. Segons el dispositiu f\u00edsic que els emmagatzeme, els arxius poden ser directes o seq\u00fcencials, el primer implica que per poder accedir a qualsevol registre, hem de passar pr\u00e8viament pels anteriors, per exemple una cinta magn\u00e8tica, mentre que el segon tipus d\u2019arxiu permet l\u2019acc\u00e9s directe al registre en q\u00fcesti\u00f3 sense haver de passar pels anteriors. En Java un arxiu \u00e9s una seq\u00fcencia de bytes que contenen la informaci\u00f3 emmagatzemada. Per poder treballar amb aquestes seq\u00fcencies de bytes, Java disposa de classes com s\u00f3n els tipus b\u00e0sics (int, double, string..). D\u2019una altra banda, com ja hem explicat abans, un flux \u00e9s una abstracci\u00f3 que es refereix a una corrent (stream) de dades entre un origen (tamb\u00e9 conegut com a font o productor) i una destinaci\u00f3 o embornal (consumidor) i la connexi\u00f3 que existeix entre els dos tamb\u00e9 es coneix com a pipe o tub per on circules les dades. Quan comen\u00e7a qualsevol execuci\u00f3 d\u2019un programa Java, es creen tres objectes flux, canals pels que pot fluir informaci\u00f3 d\u2019entrada o eixida; aquests objectes estan definits a la classe System i s\u00f3n: Sytem.in: entrada est\u00e0ndard, permet l\u2019entrada de dades des del teclat.Una excepci\u00f3 \u00e9s un fallo que es produeix en temps d\u2019execuci\u00f3\u00cdndex de continguts System.out: eixida est\u00e0ndard, permet la programa imprimir per pantalla. System.err: eixida d\u2019errors, permet al programa imprimir errors per pantalla.","title":"Flux d'arxius"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#class-file","text":"Per poder identificar d\u2019un fitxer al sistema de fitxers de qualsevol sistema operatiu, necessitem: nom i ruta. Per exemple \u2018/user/data/file.txt\u2019. El fitxer es diu file.txt i la ruta en la qual es troba \u00e9s \u2018/user/data/\u2019. Aquest identificador de fitxer \u00e9s el que es passa al constructor de la classe per tal d\u2019obrir un flux. 1 File fitxer = new File ( strPath + \"prova.txt\" ); En l\u2019exemple anterior hem utilitzat la classe File per tal d\u2019instanciar un stream al fitxer que li hem passat per par\u00e0metre \u00abprova.txt\u00bb. Compte que s\u2019ha de passar la ruta absoluta d\u2019on es troba el fitxer. Hi ha alternatives al constructor de la classe File que hem mostrat a l\u2019exemple anterior, es pot construir tamb\u00e9 amb dos par\u00e0metres: ruta i nom del fitxer o incl\u00fas indicar-li la ruta mitjan\u00e7ant un altre objecte File. Els m\u00e8todes de la classe File s\u00f3n: public bolean exists() Torna true si el fitxer existeix public boolean canWrite() Torna true si es pot escriure al fitxer. public boolean canRead() Torna true si es nom\u00e9s de lectura. public boolean isFile() Torna true si \u00e9s un fitxer. public boolean isDirectory() Torna true si \u00e9s un directori. public boolean isAbsolute() Torna true si el directori t\u00e9 ruta completa public long lenght() Torna la mida en bytes del fitxer. public long lastModified() Torna el timestamp de l\u2019\u00faltima modificaci\u00f3. public String getName() Torna una string amb el nom del fitxer. public String getPath() Torna una string amb el path del fitxer. public String getAbsolutePath() Torna la ruta absoluta del fitxer. public boolean setReadOnly() Converteix el fitxer en nom\u00e9s lectura. public boolean delete() Elimina el fitxer o directori (si est\u00e0 buit) public boolean renameTo(File nou) Canvia el nom pel del fitxer nou. public boolean mkdir() Crea el directori del fitxer. public String[] list() Torna un array d\u2019strings dels elements.","title":"Class File"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#flux-i-jerarquia-de-classes","text":"Com que les possibilitats que tenim en programaci\u00f3 respecte de l\u2019\u00fas de fitxers \u00e9s ampla, podem: llegir de fitxers, escriure en fitxers, llegir per una entrada com un teclat System.in o escriure en una eixida com un monitor System.out , Java declara dues classes que deriven directament de la superclasse \u00abObject\u00bb que s\u00f3n: InputStream i OutputStream , ambdues abstractes, \u00e9s a dir, no podem instanciar cap objecte d\u2019aquestes classes. InputStream \u00e9s la base per a totes les classes definies per al flux d\u2019entrada de dades mentre que OutputStream \u00e9s la classe base per a les classes que gestionen el flux d\u2019eixida. B\u00e0sicament en la seg\u00fcent imatge podeu les principals classes derivades dels fluxos d\u2019entrada i eixida i la seua jerarquia.","title":"Flux i jerarquia de classes"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#arxius-de-baix-nivell-fileinputstream-i-fileoutputstream","text":"Tot arxiu es pot considerar en s\u00ed mateix una seq\u00fc\u00e8ncia de bytes de baix nivell i despr\u00e9s sobre aquesta informaci\u00f3 es pot construir informaci\u00f3 de mes alt nivell per tal de processar dades m\u00e9s complexes des de tipus b\u00e0sic fins objectes. En altres paraules, si volem obrir un flux de dades a un fitxer o arxiu i volem llegir byte a byte per despr\u00e9s decidir nosaltres a nivell de programaci\u00f3 que volem fer amb aquests bytes, haur\u00edem d\u2019utilitzar aquestes classes. 1 FileInputStream fen = new FileInputStream ( strPath + \"provat.txt\" ); La classe FileInputStream s\u2019utilitza per llegir bytes o grups de bytes del fitxer associat. Tots els m\u00e8todes tenen visibilitat p\u00fablica i s\u2019ha de tenir en compte quina \u00e9s l\u2019excepci\u00f3 que llencen per controlar els possibles errors en temps d\u2019execuci\u00f3. FileOutputStream(String nombre) throws IOException; Crea un objecte inicialitzat amb el nom d\u2019arxiu que es passa com argument. FileOutputStream(String nombre, boolean sw) throws IOException; Crea un objecte inicialitzat amb el nom d\u2019arxiu que es passa per par\u00e0metre. Si sw \u00e9s true els nous bytes s\u2019afegeixen al final. FileOutputStream(File nombre) throws IOException; Crea un objecte inicialitzat amb l\u2019objecte file que es passa per par\u00e0metre. void write(byte a) throws IOException; Escriu el byte \u2018a\u2019 al flux associat. void write(byte[] s) throws IOException; Escriu l\u2019array de bytes \u2018s\u2019 al flux void write(byte[] s, int org, int len) throws IOException; Llig una seq\u00fc\u00e8ncia de bytes del flux i la desa a \u2018s\u2019 comen\u00e7ant per \u2018org\u2019 i una mida de \u2018len\u2019. Torna -1 si arriba al final del fitxer. void close()throws IOException; Tanca el flux i el fitxer queda lliure per al seu \u00fas posterior.","title":"Arxius de baix nivell: FileInputStream i FileOutputStream"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#exemple","text":"A continuaci\u00f3 obrirem el fitxer \u00abprova.txt\u00bb amb un FileInputStream per llegir-lo i desarem el seu contingut a un fitxer d\u2019eixida \u00abresultat.txt\u00bb que obirem amb un FileOutputStream. Al fitxer d\u2019eixida, bolcarem el contingut de \u00abprova.txt\u00bb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 try { FileInputStream fen = new FileInputStream ( strPath + \"prova.txt\" ); FileOutputStream fout = new FileOutputStream ( strPath + \"resultat.txt\" ); int byteLlegit = fen . read (); while ( byteLlegit != - 1 ) { fout . write ( byteLlegit ); byteLlegit = fen . read (); } fen . close (); fout . close (); } catch ( FileNotFoundException f ) { System . out . println ( \"Fitxer no trobat\" ); } catch ( IOException e ) { System . out . println ( \"Error d'entrada eixida\" ); } Activitat. Basat en el codi anterior i fes que al fitxer resultat, el d\u2019eixida, es copie el que apareix a \u00abprova.txt\u00bb, el d\u2019entrada per\u00f2 a l\u2019inrev\u00e9s.","title":"Exemple"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#arxius-de-dades","text":"La veritat \u00e9s que treballar amb bytes quan estem parlant de fitxers o arxius que contenen informaci\u00f3 o dades de m\u00e9s nivell pot resultar incomode, ja que entre altres haur\u00edem de saber quants bytes t\u00e9 un car\u00e0cter, un enter o un doble. En Java tenim les classes DataInputStream i DataOutputStream que s\u00f3n subclasses de les classes FilterInputStream i FilterOutputStream 1 2 FileInputStream gs = new FileInputStream ( strPath + \"prova.txt\" ); DataInputStream ent = new DataInputStream ( gs ); B\u00e0sicament aquestes classes el que fan \u00e9s organitzar els bytes en tipus primitius de tal forma que ja podem treballar llegint i escrivint als fluxos: enters, car\u00e0cters, reals, cadenes etc.. public DataInputStream(InputStream entrada) throws IOException Crea un objecte associat a l\u2019stream que es passa per par\u00e0metre public final boolean readBoolean() throws IOException Torna el valor de tipus boole\u00e0 llegit public final byte readByte() throws IOException Torna el valor de tipus byte llegit public final short readShort() throws IOException Torna el valor de tipus short llegit public final char readChar() throws IOException Torna el valor de tipus char llegit public final int readInt() throws IOException Torna el valor de tipus int llegit. public final long readLong() throws IOException Torna el valor de tipus long llegit public final float readFloat() throws IOException Torna el valor de tipus float llegit public final double readDouble() throws IOException Torna el valor de tipus double llegit public final String readUTF() throws IOException Torna una cadena que es va escriure en UTF D\u2019aquesta forma ja no ens hem de preocupar de saber quants bytes de mem\u00f2ria s\u2019han de reservar per un car\u00e0cter o un enter. Per exemple si associem un DataOutputStream a un fitxer i despr\u00e9s cridem al m\u00e8tode writeInt , realment el que s\u2019est\u00e0 fent \u00e9s escriure 4 bytes d\u2019informaci\u00f3 al fitxer de la qual cosa s\u2019estaria encarregant de manera trans11parent a l\u2019usuari. 1 2 FileOutputStream fn = new FileOutputStream ( strPath + \"result.txt\" ); DataOutputStream snb = new DataOutputStream ( fn ); ||| |--|--| |public DataOutputStream(OutputStream destino) throws IOException|Crea un objecte associat a l\u2019out11putstream que es passa per par\u00e0metre| |public final void writeBoolean(boolean v) throws IOException|Escriu un boolean| |public final void writeByte(int v) throws IOException|Escriu un byte| |public final void writeShort(int v) throws IOException|Escriu un short| |public final void writeChar(int v) throws IOException|Escriu un char| |public final void writeChars(String v) throws IOException|Escriu tots els chars que cont\u00e9 la String v| |public final void writeInt(int v) throws IOException|Escriu un int |public final void writeLong(long v) throws IOException|Escriu un long| |public final void writeFloat(float v) throws IOException|Escriu un float| |public final void writeDouble(double v) throws IOException|Escriu un double| |public final void writeUTF(String cad) throws IOException|Escriu la cadena cad en format UTF| |public final int close()throws IOException|Tanca el flux| ||| A continuaci\u00f3 podem veure un exemple en el que fem \u00fas del DataOutputStream i DataInputStream. El que fa aquest exemple \u00e9s escriure a un fitxer d\u2019eixida \u00abpluges.dat\u00bb dos valors double aleatoris per despr\u00e9s llegir-los amb un DataInputStream i mostrar-los per pantalla. El codi podria ser el seg\u00fcent: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 try { FileOutputStream fos = new FileOutputStream ( strPath + \"pluges.dat\" ); DataOutputStream dos = new DataOutputStream ( fos ); double info Math . random () * 100 ; dos . writeDouble ( info ); FileInputStream fis = new FileInputStream ( strPath + \"pluges.dat\" ); DataInputStream dis = new DataInputStream ( fis ); double info2 = dis . readDouble (); System . out . println ( \"Primer valor: \" + info2 ); info2 = dis . readDouble (); System . out . println ( \"Segon valor: \" + info2 ); } catch ( FileNotFoundException e ) { System . out . println ( \"El fitxer no existeix\" ); } // Exemple 1. Dies de la setmana enum Dies { Dilluns , Dimarts , Dimecres , Dijous , Divendres , Dissabte , Diumenge } // Exemple 2. Talles de roba enum Talles { XXL , XL , L , M , S , XS } catch ( IOException e ) { System . out . println ( \"Error IO inesperat\" ); }","title":"Arxius de dades"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#flux-printstream","text":"La classe PrintStream deriva de FilterOutputStream i el valor afegit d\u2019aquesta classe derivada \u00e9s que permet afegir el car\u00e0cter final de l\u00ednia als fitxers. Aquests tipus de fluxos s\u00f3n sempre d\u2019eixida i s\u2019associen a un altre flux de bytes de m\u00e9s baix nivell 1 PrintStream ps = new PrintStream ( new FileOutputStream ( \"Complex.dat\" )); ||| |---|---| |public PrintStream(OutputStream destino)|Crea un objecte associat a qualsevol objecte d\u2019eixida per par\u00e0metre| |public PrintStream(OutputStream destino, boolean flag)| Crea un objecte associat a qualsevol objecte d\u2019eixida per par\u00e0metre. Si flag \u00e9s true, es produeix un bolcat autom\u00e0tic al escriure final de l\u00ednia.| |public void flush()|Bolca el flux actual| |ublic void print(Object obj)|Escriu la representaci\u00f3 de l\u2019objecte obj al flux| |public void print(String cad)|Escriu la cadena al flux| |public void print(char c)|Escriu un car\u00e0cter al flux| |public void println(Object obj)|Escriu la representaci\u00f3 de l\u2019objecte al flux i final de l\u00ednia| |public void println(String cad)|Escriu la cadena al flux i final de l\u00ednia| |||","title":"Flux PrintStream"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#arxius-de-caracters-reader-i-writer","text":"Reader i Writer s\u00f3n fluxos de Java orientats a car\u00e0cters. Amb aquests fluxos podem llegir i escriure car\u00e0cters o cadenes de car\u00e0cters al dispositius connectats mitjan\u00e7ant aquests fluxos. Per llegir arxius de car\u00e0cters s\u2019utilitzen fluxos derivats de la classe Reader on es declaren o sobreescriuen m\u00e8todes per la lectura de car\u00e0cters. Els m\u00e8todes m\u00e9s importants s\u00f3n: public int read() Llig un car\u00e0cter en forma d\u2019enter. Si arriba al final del fitxer torna -1 public int read(char [] b) Llig una seq\u00fcencia de car\u00e0cters fins completar l\u2019array b o llegir el final del fitxer. Torna el nombre de car\u00e0cters llegits o -1 si arriba al final de l\u2019arxiu. InputStremaReader Els fluxos de la classe IntpuStreamReader envolten a un flux de bytes; converteixen la seq\u00fc\u00e8ncia de bytes en seq\u00fc\u00e8ncia de car\u00e0cters i aix\u00ed ja no ho hem de fer nosaltres; la classe deriva directament de Reader, pel que t\u00e9 disponibles els m\u00e8todes read() de la seua classe pare per la lectura de car\u00e0cters 1 InputStreamReader ent = new InputStreamReader ( Sytem . in ); FileReader Per llegir arxius de text o de car\u00e0cters es pot crear un flux del tipus FileReader, aquesta classe deriva d\u2019InputStreamReader, hereta els m\u00e8todes read() per a llegir car\u00e0cters, el constructor t\u00e9 com entrada una cadena amb el nom de l\u2019arxiu Per exemple 1 FileReader fr = new FileReader ( \"cartes.dat\" ); En general no resulta eficient llegir directament d\u2019un flux d\u2019aquest tipus, s\u2019utilitzar\u00e0 un flux BufferedReader. BufferedReader La lectura d\u2019arxius de text es realitza amb un flux que emmagatzema els car\u00e0cters en un buffer intermedi, aquests no es lligen directament de l\u2019arxiu si no del buffer. D\u2019aquesta manera augmentem l\u2019efici\u00e8ncia a les operacions d\u2019entrada, la classe BufferReader permet crear fluxos de car\u00e0cters amb buffer que no \u00e9s m\u00e9s que una forma d\u2019organitzar el flux b\u00e0sic de car\u00e0cters del que ve el text perqu\u00e8 al crear un flux BufferReader, aquest s\u2019inicialitza com un flux de car\u00e0cters InputStreamReader o qualsevol altre. El constructor de la classe t\u00e9 un argument de tipus Reader, FileReader o InputStreamReader, el flux creat disposa d\u2019un buffer de grand\u00e0ria suficient, el qual es pot especificar en el constructor amb un segon argument encara que no fa falta. Exemples de fluxos amb buffer; Writer Els arxius de text s\u00f3n arxius de car\u00e0cters, es poden crear fluxos de bytes o de car\u00e0cters derivats de la classe abstracta Writer, la qual defineix m\u00e8todes write() per escriure arrays de car\u00e0cters o cadenes, d\u2019aquesta classe es deriva OutputStreamWriter que permet escriure car\u00e0cters en un flux de bytes al qual s\u2019associa la creaci\u00f3 de l\u2019objecte o flux. 1 OutputStreamWriter ot = new OutputStreamWriter ( new FileOutputStream ( arxiu )); No es freq\u00fcent utilitzar directament fluxos OutputStreamWriter, encara que resulta interessant perqu\u00e8 la classe FileWriter \u00e9s una extensi\u00f3 d\u2019ella. Dissenyada per escriure en un arxiu de car\u00e0cters, els fluxos d\u2019aquest tipus escriuen car\u00e0cters amb el m\u00e8tode write() a l\u2019arxiu al que s\u2019associa el flux quan es crea l\u2019objecte. 1 2 FileWriter nr = new FileWriter ( \"cartes.dat\" ); nr . write ( \"Frase qualsevol a escriure\" ); PrintWriter Els fluxos m\u00e9s utilitzats en l\u2019eixida de car\u00e0cters s\u00f3n de tipus PrintWriter, aquesta classe declara constructors per associar un flux PrintWriter amb qualsevol altre de tipus Writer o b\u00e9 OutputStream. public PrintWriter(OutputStream dest\u00ed) Crea un flux associat amb un altre d\u2019eixida a nivell de byte. public PrintWriter(Writer destino) Crea un flux associat amb un altre d\u2019eixida de car\u00e0cters de tipus Writer. La import\u00e0ncia d\u2019aquesta classe radica en que defineix m\u00e8todes print() i println() per cadascun dels tipus de dades simples, per String i per Object; la difer\u00e8ncia entre els m\u00e8todes print() i println() est\u00e0 en que el segon afegeix els car\u00e0cters de final de l\u00ednia a continuaci\u00f3 dels escrits per l\u2019argument. public void print(Object obj) Escriu la representaci\u00f3 de l\u2019objecte obj al flux public void print(String cad) Escriu la cadena al flux public void print(char c) Escriu el car\u00e0cter c al flux. public void println(Object obj) Escriu la representaci\u00f3 de l\u2019objecte obj al flux i final de l\u00ednia public void println(String cad) Escriu la cadena al flux i el final de l\u00ednia public void println(char c) Escriu el car\u00e0cter c al flux i final de l\u00ednia.","title":"Arxius de caracters: Reader i writer"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#arxius-dobjectes","text":"Per tal que un objecte continue existint una vegada ja hem finalitzat l\u2019execuci\u00f3 d\u2019un programa o aplicaci\u00f3 l\u2019hem de desar a un arxiu d\u2019objectes. Per poder aconseguir a\u00e7\u00f2, utilitzarem les classes ObjectInputStream i ObjectOutputStream","title":"Arxius d'objectes"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#classe-dobjecte-persistent","text":"La declaraci\u00f3 de la classe els objectes de la qual van a ser persistents, han de implementar la interf\u00edcie \u00abserializable\u00bb del paquet java.io, la qual \u00e9s buida, no declara m\u00e8todes, simplement indica a la m\u00e0quina virtual de Java que les inst\u00e0ncies d\u2019aquestes classes podran gravar-se en un fitxer. 1 class racional implements serializable { ... }","title":"Classe d'objecte persistent"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#flux-objectoutputstream","text":"Els fluxos de la classe ObjectOutputStream s\u2019utilitzen per gravar objectes persistents. El m\u00e8tode writeObject() escriu qualsevol objecte d\u2019una classe serializable en el flux de bytes associat. Pot llen\u00e7ar excepcions del tipus IOException que \u00e9s necessari processar. 1 public void writeObject ( Object obj ) throws IOException ; El constructor de la classe espera un argument de tipus OutputStream, que \u00e9s la base dels fluxos d\u2019eixida a nivell de bytes, per tant, per crear aquest tipus de fluxos primer es crea un d\u2019eixida a nivell de bytes associat a un arxiu extern i a continuaci\u00f3, es passa com argument al constructor de ObjectOutputStream, per exemple: 1 2 FileOutputStream bn = new FileOutputStream ( \"dadesRac.dat\" ); ObjectOutputStream fobj = new ObjectOuputStream ( bn ); A continuaci\u00f3 es pot escriure qualsevol objecte al flux: 1 2 3 4 Persona juan = new Persona ( \"Juan\" , \"Martin\" , \"123432123X\" ); fobj . writeObject ( juan ); String str = new String ( \"Cadena de favors\" ); fobj . write ( str );","title":"Flux ObjectOutputStream"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#flux-objectinputstream","text":"El objectes guardats en arxius amb fluxos de la classe ObjectOutputStream es recuperen i lligen amb fluxos d\u2019entrada del tipus ObjectInputStream, aquesta classe \u00e9s una extensi\u00f3 d\u2019InputStream, a m\u00e9s a m\u00e9s, implementa la interf\u00edcie DataInput, per aix\u00f2 disposa de diversos m\u00e8todes d\u2019entrada (read) per cadascun dels tipus de dades com readInt() o altres. El m\u00e8tode m\u00e9s important definit per la classe ObjectInputStream \u00e9s readObject(), el qual llig un objecte del flux d\u2019entrada, \u00e9s a dir, de l\u2019arxiu associat al flux de baix nivell; l\u2019objecte llegit es va escriure en el seu moment amb el m\u00e8tode writeObject() 1 public Object readObject () throws IOException ; El constructor de fluxos ObjectInputStreeam t\u00e9 com entrada un altre flux de baix nivell de qualsevol tipus derivat d\u2019InputStream, per exemple: FileInputStream associat amb l\u2019arxiu d\u2019objectes. A continuaci\u00f3 es crea un flux d\u2019entrada per llegir els objectes de l\u2019arxiu \u00abarchivoObjects.dat\u00bb 1 ObjectInputStream obj = new ObjectInputStream ( new FileInputStream ( \"arxiuObjects.dat\" )); El constructor llen\u00e7a una excepci\u00f3 si, per exemple, l\u2019arxiu no existeix, aquella \u00e9s del tipus \u00abClassNotFoundException\u00bb o \u00abIOException\u00bb, \u00e9s necessari poder capturar aquestes excepcions","title":"Flux ObjectInputStream"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#excepcions","text":"Un problema important en el desenvolupament del programari \u00e9s la gesti\u00f3 de les errades o errors. No importa quan b\u00e9 estiga planificat aquest desenvolupament i quan eficient siga l\u2019equip desenvolupador. \u00c9s una m\u00e0xima en inform\u00e0tica el fet que sempre apareixeran problemes. Aquests problemes inesperats s\u00f3n problemes o errors que apareixen en temps d\u2019execuci\u00f3, per exemple: esgotament de mem\u00f2ria o recursos, errors en els intervals dels bucles, divisions per zero, arxius no existents, etc.. Les excepcions s\u00f3n el mecanisme previst per Java per tractar aquests problemes sobrevinguts. Amb les excepcions, Java dona la possibilitat al programador salvar aquest tipus de situacions de manera controlada sense que el programa o aplicaci\u00f3 es tanque, bloquege o deixe de respondre.","title":"Excepcions"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#condicions-derrors-en-programes","text":"Programar, escriure codi, m\u00e8todes, classes, etc.. que siga eficient, efica\u00e7 i lliure d\u2019errades \u00e9s altament complicat. El control d\u2019errades \u00e9s una part tant important en el disseny d\u2019aplicacions que a totes les diferents metodologia de cicle de vida software, hi ha una fase que es dedica \u00fanica i exclusivament a detectar aquestes errades i solucionar-les i aix\u00ed i tot \u00e9s impossible produir programari totalment lliure d\u2019errades.","title":"Condicions d'errors en programes"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#tractament-dels-codis-derror","text":"Java inclou un mecanisme de gesti\u00f3 d\u2019excepcions per poder intentat cobrir possibles errades en els programes en temps d\u2019execuci\u00f3. Aquest mecanisme consisteix en capturar (catch) els errors quan es produeixen en temps d\u2019execuci\u00f3. Quan es produeix un fallo en temps d\u2019execuci\u00f3 es podrien fer tres coses: parar l\u2019execuci\u00f3 de sobte, continuar executant esperant que no passe res o establir una senyal d\u2019error que el mateix codi amb altres sent\u00e8ncies s\u2019encarregue de gestionar. Aquestes senyals que envia (throw) el programa quan es produeix alguna errada en Java s\u2019anomenen excepcions i el bloc del codi on es posen les sent\u00e8ncies per tal d\u2019intentar solucionar-lo en temps d\u2019execuci\u00f3 \u00e9s el bloc catch.","title":"Tractament dels codis d'error"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#excepcions-en-java","text":"Una excepci\u00f3 \u00e9s un fallo que es produeix en temps d\u2019execuci\u00f3. Si hem escrit b\u00e9 el codi per tal de gestionar aquest fallo, el flux d\u2019execuci\u00f3 passa al codi destinat a gestionar les excepcions, en cas contrari el programa acaba la seua execuci\u00f3. Aquestes excepcions es poden produir per exemple si intenten accedir a un element d\u2019un array fora dels seus l\u00edmits, si intentem obrir un fitxer que no existeix o est\u00e0 bloquejat, si dividim per zero, etc.. El model de gesti\u00f3 d\u2019excepcions a Java afegeix cinc noves paraules reservades: try, throw, throws, catch i finally. - try: bloc on es detectaran les excepcions - catch: captura les excepcions que es produiexen al bloc try - throw: expressi\u00f3 per llen\u00e7ar excepcions - throws: indica les excepcions que pot llen\u00e7ar un m\u00e8tode. - finally: bloc opcional situat despr\u00e9s del try catch Els pasos del model de control d\u2019excepcions en Java s\u00f3n: El bloc try cont\u00e9 les instruccions o part del codi susceptible de provocar algun error. Si en temps d\u2019execuci\u00f3 es produeix algun error dins de les sent\u00e8ncies que es troben dins del bloc try, es llen\u00e7a una excepci\u00f3. S\u2019executa el codi que es troba dins del bloc catch associat a la excepci\u00f3 que s\u2019ha llen\u00e7at al punt anterior. S\u2019executa el bloc finally (opcional) Exemple. Suposem una classe persona que incorporarem a la nostra aplicaci\u00f3. Aquesta classe t\u00e9 un constructor al qual se li passa el DNI, imaginem ara que de la nostra aplicaci\u00f3 instanciem un objecte de la classe persona a la qual l direm Joan per\u00f2 quan cridem al constructor de la classe no li passem un DNI, aquest \u00abmal \u00fas\u00bb de la classe Persona, llen\u00e7aria una excepci\u00f3 que hauria de capturar la nostra aplicaci\u00f3 al bloc catch i \u00e9s ac\u00ed, en aquest bloc d\u2019instruccions, en el que s\u2019hauria de corregir la situaci\u00f3 o avisar a l\u2019usuari de l\u2019aplicaci\u00f3 del que ha passat. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public void escolta () throws Exception { // Codi del metode escolta // ... throw new Exception (); } public static void main ( String [] args ) { try { escolta (); } catch ( Exception e ) { // Codi a executar quan es produeix una excepci\u00f3. } } Al codi anterior hem crear un m\u00e8tode escolta que l\u2019\u00fanic que fa \u00e9s lle\u00e7ar una excepci\u00f3. Quan al m\u00e8tode main cridem a la funci\u00f3 escolta, si volem fer \u00fas del sistema d\u2019excepcions de Java, l\u2019haurem de posar dins del bloc try. Just despr\u00e8s d\u2019acabar el conjunt d\u2019instruccions del bloc try posem un catch indicant-li quina \u00e9s la classe d\u2019excepci\u00f3 que hauriem de capturar, al nostre cas Exception, i dins del bloc catch posariem el codi que s\u2019hauria d\u2019executar en cas de produir-se eixe error. Normalment es solen posar missatges d\u2019error que alerten l\u2019usuari de l\u2019aplicaci\u00f3. A continuaci\u00f3 explicarem amb m\u00e9s detall qu\u00e8 \u00e9s el que fan cadascun dels blocs del mecanisme d\u2019excepcions que ha dissenyat Java.","title":"Excepcions en Java"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#bloc-try","text":"Dins del bloc try s\u2019han de posar aquelles sent\u00e8ncies que poden llen\u00e7ar alguna excepci\u00f3 entre claud\u00e0tors, despr\u00e9s del claud\u00e0tor de tancament s\u2019ha de posar el bloc catch o controlador d\u2019excepcions almenys un bloc catch. Si l\u2019excepci\u00f3 que es produeix coincideix amb algun dels par\u00e0metres dels blocs catch que hi han, s\u2019executen les sent\u00e8ncies que es troben a dintre. Els blocs try, de la mateixa forma que amb totes les sent\u00e8ncies de programaci\u00f3 estructurada, es poden niar. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static void main ( String [] args ) { try { escolta (); try { tornaAEscoltar (); } catch ( Exception e ) { // Codi excepci\u00f3 interna } } catch ( Exception e ) { // Codi excepci\u00f3 externa } } A l\u2019exemple anterior \u00e9s pot observar un codi amb dos blocs try niats on el primer bloc try t\u00e9 dos blocs catch per controlar varies excepcions","title":"Bloc try"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#bloc-throw","text":"La sent\u00e8ncia throw llen\u00e7a (raise) una excepci\u00f3. Les excepcions en Java s\u00f3n objectes, per tant, una excepci\u00f3 \u00e9s una inst\u00e0ncia d\u2019una classe que deriva de la classe Exception A l\u2019exemple anterior com es pot observar es capturen dos tipus d\u2019excepcions diferents, una generica Exception i una altra FileNotFoundException. Aquesta \u00faltima es produiex normalment quan volem obrir un fitxer, amb la classe File per exemple, i aquest no existeix.","title":"Bloc throw"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#bloc-catch","text":"El bloc catch o de captura d\u2019excepcions. Quan una excepci\u00f3 es llen\u00e7a des d\u2019un bloc try, si el tipus d\u2019excepci\u00f3 que s\u2019ha llen\u00e7at coincideix amb el tipus d\u2019excepci\u00f3 que s\u2019ha passat per par\u00e0metre al catch, s\u2019executarien les sent\u00e8ncies que hi han dins del bloc catch. Normalment es sol posar el codi necessari per poder eixir de la situaci\u00f3 en la que ens trobem quan s\u2019al\u00e7a una excepci\u00f3.","title":"Bloc catch"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#clausula-finally","text":"El bloc finally en un try..catch, \u00e9s el bloc d\u2019instruccions que s\u2019executar\u00e0 sempre, hi haja excepcions o no, al final de tot el nostre codi. Normalment es solen posar sent\u00e8ncies per tal d\u2019alliberar tot all\u00f2 que pugam haver creat dins del bloc try, \u00e9s a dir, tancar fluxos, fitxers, connexions a bases de dades etc..amb la finalitat d\u2019alliberar mem\u00f2ria.","title":"Cl\u00e0usula finally"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#classes-dexcepcions-en-java","text":"","title":"Classes d'excepcions en Java"},{"location":"Tema%2008.%20Entrada%2C%20eixida%20i%20excepcions/#nove-excepcions","text":"Java permet la creaci\u00f3 d\u2019excepcions noves que deriven de la classe base Exception","title":"Nove excepcions"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/","text":"Tema 9. Gr\u00e0fics 1. Java Swing Introducci\u00f3 Fins ara hem estat utilitzant la consola i el teclat a les nostres aplicacions per tal de comunicar-nos amb l'usuari. En aquest tema utilitzarem l'API de Java per al desenvolupament de components gr\u00e0fics Swing. Swing \u00e9s un conjunt d'eines per a Java. \u00c9s una API que proporciona interf\u00edcie gr\u00e0fica d'usuari (GUI) per a programes de Java. Entre d'altres Swing cont\u00e9: frames, botons, textbox, men\u00fas a banda dels events associats als elements. Swing va ser desenvolupat per a proporcionar un conjunt m\u00e9s complex de components GUI que l'anterior Abstract Window Toolkit (AWT). Swing proporciona un aspecte i aparen\u00e7a natiu que emula diverses plataformes, tamb\u00e9 d\u00f3na suport a extensions d'aspecte i aparen\u00e7a que permeten a les aplicacions tindre un aspecte i apare\u00e7a que no guarda relaci\u00f3 amb la plataforma subjacent. Hu\u00ed en dia la majoria de desenvolupadors Java utilitzen Swing o JavaFX per construir interf\u00edcies d'usuari La llibreria Swing Com tot en Java, swing no anava a ser menys, est\u00e0 dissenyat com una llibreria de classes, interf\u00edcies, recursos, etc.. per la construcci\u00f3 d'insterf\u00edcies gr\u00e0fiques. Swing cont\u00e9 tres APIs una per a components 2D, una altra per al Drag & Drop i l'\u00faltima per facilitar l'acc\u00e9s. Swing est\u00e0 basada en AWT per\u00f2 \u00e9s independent de la plataforma, \u00e9s a dir, sempre mostra la mateixa aparen\u00e7a independentment del sistema en el que s'execute l'aplicaci\u00f3 a difer\u00e8ncia d'AWT. Amb Swing podem fer: - Marcs: Finestres amb de t\u00edtol, men\u00fa, botons maximitzar, minimitzar i tancar. - Contenidors: poden agrupar diversos controls. - Botons - Etiqutes: text - Camps i arees de text. - Desplegables Per tal de poder utilitzar les llibreries Swing de Java hauriem d'afegir al nostre codi el seg\u00fcent: 1 import javax.swing.* ; Components i contenidors En general, els components Swing es deriven de la classe JComponent. Les \u00faniques excepcions s\u00f3n els quatre contenidors de nivell superior. JComponent proporciona la funcionalitat que \u00e9s com\u00fa a tots els components. Per exemple, JComponent admet la look & feel conectables. JComponent hereta les classes AWT Container i Component. Per tant, un component Swing est\u00e0 integrat i es compatible amb un component AWT. Tots els components de Swing estan representats per classes definides dins del paquet javax.swing com hem explicat abans. La seg\u00fcent taula mostra els noms de classe per als components Swing inclosos els contenidors. Components Java Swing JApplet JButton JCheckBox JCheckBoxMenuItem JColorChooser JComboBox JComponent JDesktopPane JDialog JEditorPane JFileChooser JFormattedTextField JFrame JInternalFrame JLabel JLayer JLayeredPane JList JMenu JMenuBar JMenuItem JOptionPane JPanel JPasswordField JPopUpMenu JProgressBar JRadioButton JRadioButtonMenuItem JRootPane JScrollBar JScrollPane JSeparator JSlider JSpineer JSplitPane JTabbedPane JTable JTextArea JTextField JTextPane JTogglebutton JToolBar JToolTip JTree JViewport JWindows La majora de noms solen ser prou significatius i resulta intuitiu a primer cop d'ull saber quina \u00e9s la finalitat de cadascun dels components. Contenidors Java Swing Swing defineix dos tipus de contenidors. Els primers s\u00f3n contenidors de nivell superior: JFrame, JApplet, JWindow i JDialog. (JApplet, que admet applets basats en Swing, ha estat descartat per JDK 9.) Aquests contenidors no hereten JComponent. No obstant aix\u00f2, hereten les classes AWT Component i Container. A difer\u00e8ncia d'altres components de Swing, que s\u00f3n lightweight, els contenidors de nivell superior s\u00f3n heavyweight. Aix\u00f2 fa que els contenidors de nivell superior siguin un cas especial a la biblioteca de components Swing. Com el seu nom indica, un contenidor de nivell superior ha d'estar a la part superior d'una jerarquia de contenci\u00f3. Un contenidor de nivell superior no est\u00e0 contingut en cap altre contenidor. A m\u00e9s, cada jerarquia de contenci\u00f3 ha de comen\u00e7ar amb un contenidor de nivell superior. El m\u00e9s comunament utilitzat per les aplicacions \u00e9s JFrame. El segon tipus de contenidor compatible amb Swing \u00e9s el contenidor lightweight. Els contenidors lightweight hereten JComponent. Exemples de contenidors lightweight s\u00f3n JPanel, JScrollPane i JRootPane. Els contenidors lightweight sovint es fan servir per a organitzar i administrar col\u00b7lectivament grups de components relacionats perqu\u00e8 un contenidor lightweight es pot contenir dins d'un altre contenidor. Per tant, pot utilitzar contenidors lightweight per crear subgrups de controls relacionats que estan continguts dins d'un contenidor extern. Swing vs AWT \u00c9s possible utilitzar Swing i AWT a la mateixa interf\u00edcie, per\u00f2 podria donar problemes. \u00c9s recomanable utilitzar nom\u00e9s components Swing, ja que tot component AWT t\u00e9 el seu equivalent Swing. La majoria de classes Swing comencen per J, per exemple: JButton, JFrame... encara que tamb\u00e9 existeixen Frame i Button que pertanyen a la llibreria AWT. Cal tindre molta cura en no oblidar de posar la 'J' davant dels components ja que si no podria portar a inconsist\u00e8ncies a causa de mesclar components. A l'actualitat quasi tota la programaci\u00f3 gr\u00e0fica en Java es fa amb Swing que implemente una interf\u00edcie gr\u00e0fica normalment va a tenir quatre tipus d'elements: 1. Un contenidor de nivell superior: un marc (JFrame), un applet (JApplet) o b\u00e9 objectes JDialog. Aquests contenidors no estan dins d'una altra finestra, s\u00f3n les finestres principals. 2. Components de la interf\u00edcie gr\u00e0fica: botons, camps de text, etc\u00e8tera, que se situen a la finestra principal o en contenidors. 3. Contenidors dissenyats per altres elements de la interf\u00edcie; JPanel i JScrollPane s\u00f3n dos contenidors i, a el mateix temps, s\u00f3n components. 4. Elements per a la gesti\u00f3 d'esdeveniments. Els components sempre s'afegeixen a una l\u00e0mina o panell; pot ser la de el marc, o b\u00e9 un panell tipus JPanel. En general, sempre es creen classes derivades de les classes contenidors de nivell superior; tot marc ser\u00e0 una subclasse de JFrame, a l'igual que un applet \u00e9s una subclasse de JApplet. Creaci\u00f3 d'un JFrame La difer\u00e8ncia entre crear programes que es comuniquen amb l'usuari mitjan\u00e7ant el terminal i el teclat i fer programes amb Swing \u00e9s considerable. Al crear una aplicaci\u00f3 Swing s'han de tenir en compte conceptes nous com el threading . Per\u00f2 per entendre-ho tot millor, farem un programa Swing d'exemple. Per al programa d'exemple crearem un JFrame al qual li posarem una JLabel Exemple 1. Programa simple Swing 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // Un simple programa Swing import javax.swing.* ; public class SwingDemo { SwingDemo (){ JFrame jfrm = new JFrame ( \"Aplicaci\u00f3 Simple Swing\" ); // Crea un nou contenidor JFrame. jfrm . setSize ( 475 , 200 ); // Establim el tamany inicial jfrm . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); // Acabe el programa quan l'usuari tanque l'aplicaci\u00f3. JLabel jLabel = new JLabel ( \"Programaci\u00f3 GUI amb Swing.\" ); // Creem una etiqueta jLabel . setHorizontalAlignment ( SwingConstants . CENTER ); // Situem l'etiqueta al centre del frame jfrm . add ( jLabel ); // Afegim l'etiqueta al frame jfrm . setVisible ( true ); // Visualitzem el marc. } public static void main ( String [] args ) { SwingUtilities . invokeLater ( new Runnable () { public void run (){ new SwingDemo (); } }); } } El resultat del codi anterior seria el seg\u00fcent: JFrame \u00e9s un contenidor de nivell superior que s'utilitza de forma com\u00fa a les aplicacions Swing, mentre que JLabel \u00e9s una etiqueta que ens servir\u00e0 per posar text. Expliquem amb m\u00e9s detall el que fa la funci\u00f3 main: - SwingUtilities.invokeLater() - static void invokeLater(Runnable doRun): Executa un doRun.run() per tal que s'execute de forma asincrona al AWT event dispatching thread. A aquets m\u00e8tode se li ha de passar un objecte Runnable - new Runnable() { }: - Objecte Runnable que s'ha de passar al m\u00e8tode invokeLater - public void run() { }: M\u00e8tode run que s'executa de l'objecte runnable que se li passa a InvokeLater - new SwingDemo() - Codi del m\u00e8tode run de l'objecte runnable. Una aplicaci\u00f3 que implemente una interf\u00edcie gr\u00e0fica normalment va a tindre quatre tipus d'elements. 1. Un contenidor de nivell superior: un marc (JFrame), un applet (JApplet) o b\u00e9 di\u00e0legs (JDialog) que faran el paper de finestra principal. 2. Components de la interf\u00edcie gr\u00e0fica: botons, camps de text, etc, que s'afegiran al contenidor de nivell superior anterior. 3. Contenidors dissenyats per altres elements de la interf\u00edcie: JPanel i JScrollPane s\u00f3n dos contenidors i al mateix temps s\u00f3n components. 4. Elements per la gesti\u00f3 d'events. Els components sempre s'afegeixen a una l\u00e0mina o paper; pot ser la del marc o b\u00e9 un panel tipus JPanel. En general, sempre es creen classes derivades de les classes contenidores de nivell superior. Tot marc ser\u00e0 una subclasse de JFrame, de la mateixa forma que un applet \u00e9s una subclasse de JApplet JFrame La classe JFrame \u00e9s un tipus de contenidor que hereta de la classe java.awt.Frame. JFrame funciona com la finestra principal on components com etiquetes, botons, camps de text etc, s'afegeixen per crear una interf\u00edcie gr\u00e0fica. M\u00e8todes M\u00e8tode Descripci\u00f3 JFrame() Constructor de la classe. Crea un marca sense t\u00edtol JFrame (String titol) Crea un marc amb t\u00edtol. void setTitle (String titlo) Estableix el t\u00edtol del marc void setIconImage ( Image img ) Estableix la icona del marc void setDefaultCloseOperation (int op ) programa el comportament del marca quan es tanca. Possibles valors: EXIT_ON_CLOSE, DO_NOTHING_ON_CLOSE, DISPOSE_ON_CLOSE, HIDE_ON_CLOSE Container getContentPane () proporciona el layout de continguts del marc, \u00e9s a dir, les vores void setResizable ( boolean r ) si r val true, es pot redimensionar el marc void add (Component c) Afegeix el component c al marc void removeComponent (Component c) elimina el component c del marc Component add (Component c, int p) Coloca el component c a la posici\u00f3 p del marc void setLayout (LayoutManager mngr) estableix la forma de distribuir el components al marc, els quals normalment es distribueixen en posicions relatives, segons el layout que tinga associat el marc void setVisible (boolean b) fa visible el component si b \u00e9s true void setBounds (int x, int y, int ample, int alt) situa el component i canvia el seu tamany void setLocation (int x, int y) situa el component a les coordenades x i y void setLocation (Point p) situa el component al punt p void setSize (int ample, int alt) estableix les dimensions del component void setSize (Dimension dim) estableix la dimensi\u00f3 del component a dim Layout Manager - Gestor de posicionament A difer\u00e8ncia d'altres aplicacions que es dediquen al disseny d'interf\u00edcies gr\u00e0fiques, les posicions dels elements dintre del nostre contenidor no es fan en pixels ni valors absoluts, s'utilitzen els Layout Manager que ho podriem traduir com \"gestors de disposici\u00f3\" o \"gestor de plantilla\" o \"gestor de posicionament\". Aquestos gestors de posicionament s\u00f3n elements que implementen la interf\u00edcie \"LayoutManager\". Cada cotenidor t\u00e9 associat un Layout Manager que pot ser: BorderLayout, FlowLayout, GridLayout, BoxLayout, GridBagLayout, CardLayout, SpringLayout... Veiem un exemple: Exemple 2. Marc de prova 1 2 JFrame marc = new JFrame ( \"MarcProva\" ); marco . setLayout ( new GridLayout ( 3 , 4 )); El que hem fet al codi anterior \u00e9s crear i instanciar un nou marc de tipus JFrame amb el t\u00edtol \"MarcProva\" i despr\u00e9s hem establert el seu gestor de posicionament de tipus GridLayout. A continuaci\u00f3 detallarem els m\u00e9s utilitzats BorderLayout Gestor de posicionament per defecte dels marcs (JFrame) i di\u00e0legs (JDialog). Divideix al contenidor en cinc zones: nord, sud, est, oest i centre, que es corresponen a: BorderLayout.NORTH, BorderLayout.SOUTH, BorderLayout.EAST, BorderLayout.WEST i BorderLayout.CENTER Veiem un exemple: Exemple 3. Marc amb vora 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import javax.swing.* ; import java.awt.* ; public class MarcBorder extends JFrame { static int AMPLE = 350 ; static int ALT = 200 ; public MarcBorder () { super ( \"T\u00edtol Marc\" ); add ( new JLabel ( \"Nord\" , SwingConstants . CENTER ), BorderLayout . NORTH ); add ( new JLabel ( \"Sud\" , SwingConstants . CENTER ), BorderLayout . SOUTH ); add ( new JLabel ( \"Centre\" , SwingConstants . CENTER ), BorderLayout . CENTER ); add ( new JLabel ( \"Oest\" , SwingConstants . CENTER ), BorderLayout . WEST ); add ( new JLabel ( \"Est\" , SwingConstants . CENTER ), BorderLayout . EAST ); setSize ( AMPLE , ALT ); setVisible ( true ); } public static void main ( String args [] ) { MarcBorder marc = new MarcBorder (); marc . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); } } El resultat del codi anterior \u00e9s: FlowLayout Amb aquest gestor podem colocar els elements d'esquerra cap a dreta i de dalt cap avall. La classe FlowLayout disposa de diversos constructors, un d'ells ens permet establir l'alineaci\u00f3 dels components FlowLayout(int align) on align pot ser: FlowLayout.RIGHT, FlowLayout.CENTER, FlowLayout.LEFT. Exemple 4. Flowlayout 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import java.awt.* ; import javax.swing.* ; public class MarcFlow extends JFrame { static int AMPLE = 175 ; static int ALT = 100 ; public MarcFlow () { super ( \"El meu marc\" ); setLayout ( new FlowLayout ()); add ( new JLabel ( \"Primera\" )); add ( new JLabel ( \"Segona\" )); add ( new JLabel ( \"Tercera\" )); add ( new JLabel ( \"Quarta\" )); add ( new JLabel ( \"Cinquena\" )); add ( new JLabel ( \"Sisena\" )); setSize ( AMPLE , ALT ); setVisible ( true ); } public static void main ( String args [] ) { MarcFlow marc = new MarcFlow (); marc . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); } } I aquest \u00e9s el resultat: GridLayout Aquest gestor de posicionament distribueix els components del container associat en forma de graella de cel\u00b7les iguals en forma de quadricula de dalt cap avall i de esquerra a dreta, \u00e9s a dir, en files i columnes. Exemple 5. GridLayout 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import java.awt.* ; import javax.swing.* ; public class MarcGrid extends JFrame { static int AMPLE = 175 ; static int ALT = 100 ; public MarcGrid () { super ( \"El meu marc\" ); setLayout ( new GridLayout ( 3 , 2 , 15 , 15 )); add ( new JLabel ( \"Primera\" )); add ( new JLabel ( \"Segona\" )); add ( new JLabel ( \"Tercera\" )); add ( new JLabel ( \"Quarta\" )); add ( new JLabel ( \"Cinquena\" )); add ( new JLabel ( \"Sisena\" )); setSize ( AMPLE , ALT ); setVisible ( true ); } public static void main ( String args [] ) { MarcGrid marc = new MarcGrid (); marc . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); } } Resultat del codi anterior: BoxLayout Aquest gestor coloca els components en una \u00fanica fila o una \u00fanica columna, s'assembla a una caixa amb orientaci\u00f3 horitzontal o vertical; el constructor necessita un argument amb el contenidor que es va a utilitzar i l'orientaci\u00f3 que pot ser: BoxLayout.X_AXIS o BoxLayout.Y_AXIS. El format del constructor \u00e9s: BoxLayout (Container desti, int orientacio) Exemple 6. BoxLayout 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import javax.swing.* ; import java.awt.* ; public class MarcBox extends JFrame { static int AMPLE = 175 ; static int ALT = 150 ; public MarcBox () { super ( \"El meu marcBox\" ); JPanel panel = new JPanel () ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . Y_AXIS )); panel . add ( new JLabel ( \"Primera\" )); panel . add ( new JLabel ( \"Segona\" )); panel . add ( new JLabel ( \"Tercera\" )); panel . add ( new JLabel ( \"Quarta\" )); panel . add ( new JLabel ( \"Cinquena\" )); panel . add ( new JLabel ( \"Sisena\" )); add ( panel ); setSize ( AMPLE , ALT ); setVisible ( true ); } public static void main ( String args [] ) { MarcBox miMarcBox = new MarcBox (); miMarcBox . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); } } BoxLayout - Box Box o caixa, \u00e9s un contenidor que t\u00e9 com gestor de posicionament (LayoutManager) predeterminat un BoxLayout; utilitzant aquest contenidor no cal crear un panel perqu\u00e8 directament es crea un objecte Box i a continuaci\u00f3 s'afegeixen els components. La classe Box disposa de dos m\u00e8todes static (m\u00e8todes factoria) que creen l'objecte, i s\u00f3n: 1 2 Box . createHorizontalBox (); Box . createVerticalBox (); Aleshores, per crear un Box no s'utilitza el constructor sino que es crida a un d'aquestos dos m\u00e8todes; per un objecte Box amb orientaci\u00f3 horitzontal, per exemple: 1 Box caixaHoriz = Box . createHorizontalBox (); Al contenidor se li afegeix el component caixaHoriz.add(element) i despr\u00e9s el contenidor al marc. Exemple 7. BoxLayout - Box 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import javax.swing.* ; import java.awt.* ; public class Marc2Box extends JFrame { static int AMPLE = 275 ; static int ALT = 175 ; public Marc2Box () { super ( \"El meu marc\" ); JButton b1 = new JButton ( \"Boto1\" ); JButton b2 = new JButton ( \"Boto2\" ); JButton b3 = new JButton ( \"Boto3\" ); JButton b4 = new JButton ( \"Boto4\" ); JButton b5 = new JButton ( \"Boto5\" ); JButton b6 = new JButton ( \"Boto6\" ); Box caixaH = Box . createHorizontalBox (); // m\u00e9todo factor\u00eda caixaH . add ( b1 ); // separaci\u00f3n horizontal de 10 pixeles caixaH . add ( Box . createHorizontalStrut ( 10 )); caixaH . add ( b2 ); // zona r\u00edgida, separaci\u00f3n horizontal caixaH . add ( Box . createRigidArea ( new Dimension ( 5 , 5 ))); caixaH . add ( b3 ); add ( caixaH , BorderLayout . NORTH ); Box caixaV = Box . createVerticalBox (); caixaV . add ( Box . createHorizontalStrut ( 70 )); caixaV . add ( b4 ); // separaci\u00f3n horizontal 10 pixeles caixaV . add ( Box . createVerticalStrut ( 10 )); caixaV . add ( b5 ); caixaV . add ( Box . createRigidArea ( new Dimension ( 5 , 5 ))); caixaV . add ( b6 ); add ( caixaV , BorderLayout . CENTER ); setSize ( AMPLE , ALT ); setVisible ( true ); } public static void main ( String args [] ) { Marc2Box marcBox2 = new Marc2Box (); marcBox2 . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); } } Combinar Layouts JFrame, JDialog i JPanel nom\u00e9s poden tindre un gestor de posicionament per\u00f2 si agafem un contenidor de primer nivell com un marc, podr\u00edem combinar diversos layouts niats (nested). Al seg\u00fcent exemple podem veure una combinaci\u00f3 de tres gestors de posicionament en un mateix contenidor. Exemple 8. Combinaci\u00f3 de disposicions (layouts) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import javax.swing.* ; import java.awt.* ; public class MarcGestors extends JFrame { public MarcGestors () { JPanel pa1 = new JPanel ( new FlowLayout ()); JPanel pa2 = new JPanel ( new BorderLayout ()); JPanel pa3 = new JPanel (); pa3 . setLayout ( new BoxLayout ( pa3 , BoxLayout . Y_AXIS )); // componentes del panel 1 String [] opc = { \"Alta mar\" , \"Baixa mar\" , \" Muntanya\" }; pa1 . add ( new JLabel ( \"Tria..\" , JLabel . CENTER )); pa1 . add ( new JList ( opc )); pa1 . add ( new JButton ( \"Pr\u00e8mer\" )); // componentes del panel 2 JTextField j = new JTextField ( \"Raons \" ); j . setEditable ( false ); pa2 . add ( j , BorderLayout . WEST ); pa2 . add ( new JButton ( \"Bot\u00f3\" ), BorderLayout . EAST ); // componentes del panel 3 pa3 . add ( new JCheckBox ( \"Box \" , false )); pa3 . add ( new JLabel ( \"Calendari\" , JLabel . CENTER )); pa3 . add ( new JRadioButton ( \"Bot Radio\" , true )); // asigna layout al marco y se ponen los paneles setLayout ( new BorderLayout ( 10 , 15 )); add ( pa1 , BorderLayout . NORTH ); add ( pa2 , BorderLayout . CENTER ); add ( pa3 , BorderLayout . SOUTH ); } public static void main ( String [] args ) { MarcGestors m ; m = new MarcGestors (); m . setSize ( 200 , 300 ); m . setLocation ( 20 , 200 ); m . setResizable ( false ); m . setVisible ( true ); m . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); } } El resultat seria: Desactivar gestor de posicionament Per defecte un contenidor sempre t\u00e9 associat un gestor de posicionament (layout) per\u00f2 de vegades ens pot resultar interessant desactivar aquest gestor de posicionament. Utilitzarem el m\u00e8tode setLayout i li passarem per parametre null. Etiqutes Una etiqueta \u00e9s un component nom\u00e9s lectura al qual li podem modificar el text que cont\u00e9 i que normalment s'utilitza per posar algun missatge significatiu de la nostra interf\u00edcie a l'usuari final. En altres paraules, s\u00f3n components de text fixe que nom\u00e9s mostren text per\u00f2 que no reben cap event. Per gestionar les etiquetes a Java utilitzem la classe JLabel M\u00e8todes JLabel (): Crea una etiqueta sense text associat. JLabel (String msg): Crea una etiqueta amb el text msg. JLabel (String msg, Icon icona): Crea una etiqueta amb el text msg i la icona icon. JLabel (String msg, int align): crea una etiqueta amb el text msg alineat segons el segon argument que pot ser SwingConstants.CENTER, SwingConstants.LEFT o SwingConstants.RIGHT. public String getText (): torna el text de l'etiqueta public void setText (String msg): estableix el text de l'etiqueta. Botons A Swing es defineixe diversos tipus de botons, la classe base dels quals \u00e9s Abstract Button , \u00e9s una classe abstracta que encapsula propietats i m\u00e8todes comuns als diversos tipus de botons M\u00e8todes void setText (String text) : Estableix el text del bot\u00f3. String getText () : Obt\u00e9 el text del bot\u00f3. boolean isSelected() : true si s'ha seleccionat el bot\u00f3. void setSelectes (boolean b) : selecciona el bot\u00f3. void doClick (int temps) : tria el bot\u00f3 durant temps milisegons void setIcon (Icon icona) : estableix la icona del bot\u00f3. void setMnemonic (int mnemonic) : relaciona una tecla amb el bot\u00f3. void addActionListener(ActionListener al) : assigna un listener per controlar events. JButton La classe JButton representa el bot\u00f3 com\u00fa; es crea especificament una cadena, una icona, ambdos, o un element encara sense especificar; els constructors de la classe s\u00f3n: - JButton() : Constructor de la classe - JButton(String text) : Constructor amb text del bot\u00f3. - JButton(String text, Icon icona) : Constructor amb text i icona. La classe deriva d'AbstractButton per tant tots els seus m\u00e8todes estaran disponibles tamb\u00e9. 1 2 3 4 JButton b1 , b2 , b3 ; b1 = new JButton (); b2 = new JButton ( \"GROC\" ); b3 = new JButton ( new LibroIcon ()); Botons amb dos estats JToogleButton \u00e9s la classe base dels botons amb dos estats; JRadioButton que s'utilitza per definir un grup de botons d'opci\u00f3 \u00fanica; per agrupar botons d'opci\u00f3 \u00fanica s'utilitza la classe ButtonGroup, primer es crea un objecte ButtonGroup (constructor sense arguments); a continuaci\u00f3 s'afegeix JRadioButton amb el m\u00e8tode de ButtonGroup, add(AbstracButton b). Constructors de JRadioButton JRadioButton() : Constructor per defecte. JRadioButton(String msg) : Constructor amb text del bot\u00f3. JRadioButton(String msg, boolean sel) : Constructor amb el text i si sel \u00e9s true, el bot\u00f3 ja estaria seleccionat. Exemple 9. Diversons botons 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import javax.swing.* ; class PanelJRadio extends JPanel { ButtonGroup grb ; JRadioButton jr1 , jr2 , jr3 ; public PanelJRadio () { grb = new ButtonGroup (); setLayout ( new GridLayout ( 4 , 1 )); add ( new JLabel ( \"Selecci\u00f3 excloent\" )); // se crea bot\u00f3n de radio, se a\u00f1ade al panel y a la agrupaci\u00f3n jr1 = new JRadioButton ( \"Avi\u00f3\" , false ); add ( jr1 ); grb . add ( jr1 ); // se crea bot\u00f3n de radio, se a\u00f1ade al panel y a la agrupaci\u00f3n jr2 = new JRadioButton ( \"Tren\" , false ); add ( jr2 ); grb . add ( jr2 ); // se crea bot\u00f3n de radio, se a\u00f1ade al panel y a la agrupaci\u00f3n jr3 = new JRadioButton ( \"Cotxe\" , false ); add ( jr3 ); grb . add ( jr3 ); } } JCheckBox o tamb\u00e9 anomenat: casella de verificaci\u00f3, check o checkbox. Constructors de JCheckBox JCheckBox(): Constructor per defecte. JCheckBox(String text): : Constructor amb el text associat. JCheckBox(String text, boolean sel): Constructor amb text i si sel \u00e9s true, la casella vindria ja marcada. La classe JComboBox no est\u00e0 a la jerarquia de botons, no deriva d'AbstractButton; combina en un sol component un bot\u00f3 amb una llista d'elements. Una JComboBox s'utilitza per crear una llista desplegable a la que es poden afegir opcions, editarles o fer seleccions. Constructors de JComboBox JComboBox(): Constructor per defecte. JComboBox(Object llista[]): Constructor amb una llista d'objectes per par\u00e0metre. Alguns dels seus m\u00e8todes s\u00f3n: - public void addItem(Object q): afegeix un element a la llista (pel final). - public insertItemAt(Object q, int indice): insereix en \u00edndex l'element. - public void setEditable(boolean flag): si flag \u00e9s true l'element de llista seleccionat \u00e9s editable. - public void setMaximumRowCount(int n): posa el m\u00e0xim d'elements a mostrar en el combo, si hi ha m\u00e9s elements apareix la barra d'scroll. - public Object getSelectedItem(): torna l'element seleccionat. Els m\u00e8todes seg\u00fcents s\u00f3n per la gesti\u00f3 d'events al combobox: - public void actionPerformed(ActionEvent ev); - public void addActionListener(ActionListener ae); - public void addItemListener(ItemListener it); - public void addStateChanged(ItemEvent ev); Exemple 10. ComboBox 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import javax.swing.* ; import java.awt.* ; import java.awt.event.* ; class PanelJCombo extends JPanel { private JComboBox jcb ; public PanelJCombo () { jcb = new JComboBox (); setLayout ( new BorderLayout ()); jcb . addItem ( \"MAD - BCN\" ); jcb . addItem ( \"MAD - AGP\" ); jcb . addItem ( \"MAD - XRY\" ); jcb . addItem ( \"BRU - TFN\" ); jcb . addItem ( \"LEN - BCN\" ); jcb . addItem ( \"ROM - BCN\" ); jcb . setMaximumRowCount ( 4 ); add ( jcb , BorderLayout . NORTH ); } } Components de text Els components Swing que s'utilitzen per editar o mostrar text formen una jerarquia de classes la base de la qual \u00e9s JTextComponent; aquesta \u00faltima \u00e9s una classe abstracta que es troba al paquet java.swing.text JTextComponent Els components de text suporten una ampla varietat de caracters de c\u00f2dis alfab\u00e8tics; en ells es pot inserir, esborrar o seleccionar caracters; \u00e9s text modificable per l'usuari; la classe disposa del constructor JTextComponent() que crea una component de text editable. Els seus m\u00e8todes s\u00f3n: - String getText(): torna el text que t\u00e9 el component. - String getText(int dspl,int lon): torna el text del component a partir del despla\u00e7ament dspl i de la longitud lon. - void setText(String txt): : substituieix el text del component per txt; si txt \u00e9s null o \u00e9s una cadena buida, esborra el text del component. - void setEditable(boolean b): un component de text \u00e9s editable per omisi\u00f3; amb aquest m\u00e8tode s'especifica si \u00e9s o no. JTextField, JPasswordText La classe JTextField representa un camp de text modificable per l'usuar; amb aquest component s'edita una l\u00ednia de text amb l'ample, alineaci\u00f3 i tipus de lletra que es desitge. JPasswordField es deriva de JTextField; representa un camp de text amb la particularitat de que emmascara els caracters quan es visualitza; s'utilitza per editar una clau secreta, contrasenya o password; per omisi\u00f3, cada caracter de un JPasswordField es substitueix per un '*'. Els constructors de JTextField s\u00f3n: - JTextField(): camp de text buit de 0 columnes. - JTextField(int cols): camp de text buit de cols columnes. - JTextField(String msg): camp de text ajustat a la cadena msg. - JTextField(String msg,int col): camp de text amb la cadena msg i de cols columnes. Els constructors de JPasswordField tenen els mateixos arguments que JTextField; els seus m\u00e8todes s\u00f3n: - void setFont(Font tipo) - void setHorizontalAlignment(int alig): alineaci\u00f3 del text; els valors possibles d'alig son les constants de SwingConstants : RIGHT, LEFT, CENTER, TRAILING, LEADING (aquest \u00e9s el predeterminat) - void setColumns(int cols): posa el n\u00famero de columnes preferit per al camp. JPasswordField hereta els m\u00e8todes anteriors i a m\u00e9s a m\u00e9s disposa d'aquestos: - void setEchoChar(char c): coloca c per emmascarar els caracters del camp. - char getEchoChar(): torna el caracter que emmascara; per defecte ' '. - char[] getPassword(): * torna la cadena del camp en un array de caracters. Exemple 11. Passwords i Labels 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 import javax.swing.* ; import java.awt.* ; import java.awt.event.* ; public class MarcPassWord extends JFrame { private static final int AMPLE = 300 , ALT = 150 ; private JPasswordField clau = null ; private JLabel et1 = null ; private JLabel res = null ; public MarcPassWord ( String c ) { super ( c ); setSize ( ANCHO , ALTO ); creaComponentes (); pack (); } private void creaComponents () { clau = new JPasswordField ( 20 ); et1 = new JLabel (); // oyente para proceso de la acci\u00f3n del usuario clave . addActionListener ( new ActionListener () { public void actionPerformed ( ActionEvent evt ) { procesoAccionUser ( evt ); } }); // pone el campo de texto con la clave add ( clau , BorderLayout . CENTER ); // crea y pone la etiqueta en el marco et1 . setFont ( new java . awt . Font ( \"Times New Roman\" , 3 , 12 )); et1 . setHorizontalAlignment ( javax . swing . SwingConstants . CENTER ); et1 . setText ( \"PASSWORD \" ); et1 . setToolTipText ( \"Exemple\" ); add ( et1 , BorderLayout . NORTH ); // m\u00e9todo que se ejecuta al actuar el usuario sobre el campo private void procesoAccionUser ( ActionEvent evt ) { char pas [] ; pas = clau . getPassword (); res = new JLabel ( \" \" ); res . setFont ( new Font ( \"Book Antiqua\" , 3 , 14 )); if ( pas . length == 0 ) { System . out . println ( \"Teclejar Password \" ); et1 . setText ( \"PASSWORD(teclejar) \" ); } else { clau . setEditable ( false ); res . setText ( \"Es valida la clau\" ); } add ( res , BorderLayout . SOUTH ); validate (); pack (); } public static void main ( String args [] ) { MarcPassWord marc ; marc = new MarcPassWord ( \"Marc amb password\" ); marc . setVisible ( true ); marc . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); } } } Resultat JTextArea El component JTextArea s'utilitza amb la finalitat de mostrar moltes l\u00ednies de text; disposa de m\u00e8todes per fixar l'ample de cada l\u00ednia i l'acci\u00f3 a realitzar si la l\u00ednia que s'insereix \u00e9s major que l'ample prefixat; tamb\u00e9 permet decidir si es trenquen o no les paraules al canvi de l\u00ednia. Aquest component no disposa de barra d'scroll JScrollPane , cal crear l'scroll i associar-lo al component; per exemple: es crea el component areaText: 1 2 3 4 5 JTextArea areaText = new JTextArea (); // A continuaci\u00f3 es crea l'scroll i s'associa a **areaText**: JScrollPane barra = new JScrollPane ( areaText ); // Per \u00faltim, l'scroll es posa al marc areaText . add ( barra ); Els constructors s\u00f3n: - JTextArea(): crea el component amb cadena nula, zero files i columnes. - JTextArea(int filas,int cols): crea amb cadena nula i el n\u00famero de files i columnes especificat. - JTextArea(String t): crea el component amb cadena t i zero files i columnes. - JTextArea(String t,int filas, int col): crea el component amb cadena t i el n\u00famero de files i columnes especificat. Els seus m\u00e8todes s\u00f3n: - public void append(String t): afegeix la cadena t al final del document. - public void insert(String t,int p): insereix la cadena t a partir de la posici\u00f3 p. - void replaceRange(String t, int inici, int fi): substitueix el text del document al rang inici-fi per la cadena t. - public void setColumns(int cols): fixa l'ample de cada l\u00ednia. - public void setLineWrap(boolean f): si f \u00e9s true activa el canvi autom\u00e0tica de l\u00ednia. - public void setWrapStyleWord(boolean f): si f \u00e9s true no 'trenca' les paraules en el canvi de l\u00ednia. Esdeveniments En aquest punt tractarem l'\u00fas dels esdeveniments per tal que la nostra aplicaci\u00f3 interactue amb l'usuari. Esdeveniment: All\u00f2 que s'esdev\u00e9. Fet considerat extraordinari o molt important en la vida d'una persona o col\u00b7lectivitat. Esdeveniment (Inform\u00e0tica): Fet que s'esdev\u00e9 o canvi d'un conjunt particular de circumst\u00e0ncies. En altres paraules un esdeveniment en una aplicaci\u00f3 inform\u00e0tica \u00e9s all\u00f3 que passa sense que necessariament estiga controlat al codi. Exemples d'esdeveniments: - Fer clic a un bot\u00f3. - Fer clic dins d'un textbox. - Minimitzar una finestra. - Escriure al teclat - etc Arribats a aquest punt podriem tindre una interf\u00edcie totalment dissenyada per\u00f2 no completament funcional, \u00e9s a dir, imagineu que hem dissenyat la interf\u00edcie per a una calculadora amb tots els seus controls necessaris. Qu\u00e8 passa si fem clic en algun bot\u00f3 de la calculadora? No res ,veritat. Encara hem de programar el comportament d'aquesta calculadora i per tal d'aconseguir-ho hem de fer \u00fas de la programaci\u00f3 d'esdeveniments. Aquest procediment es diu Event Handling i es pot aplicar a aquells elements gr\u00e0fics que produeixen algun esdeveniment. Els esdeveniments s\u00f3n essencials per als usuaris interactuen amb els components de una aplicaci\u00f3 gr\u00e0fica; el model d'esdeveniments segueix el AWT de Java. Aquest cap\u00edtol estudia la forma general de captura d'esdeveniments, la jerarquia de classes del model i les interfaces desenvolupades per a la seva captura; inclou exemples senzills de captura d\u2019esdeveniments de los botons. Veiem un exemple 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import java.awt.* ; import java.awt.event.* ; import javax.swing.* ; public class EventDemo { JLabel lab ; public EventDemo () { JFrame jfrm = new JFrame ( \"Esdeveniments\" ); jfrm . setLayout ( new FlowLayout ()); jfrm . setSize ( 220 , 90 ); jfrm . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JButton btnAlpha = new JButton ( \"Alpha\" ); JButton btnBeta = new JButton ( \"Beta\" ); btnAlpha . addActionListener ( new ActionListener () { public void actionPerformed ( ActionEvent ae ) { lab . setText ( \"Alpha Pressed\" ); } }); btnBeta . addActionListener ( new ActionListener () { public void actionPerformed ( ActionEvent ae ) { lab . setText ( \"Beta Pressed\" ); } }); jfrm . add ( btnAlpha ); jfrm . add ( btnBeta ); lab = new JLabel ( \"Apreta un bot\u00f3\" ); jfrm . add ( lab ); jfrm . setVisible ( true ); } public static void main ( String [] args ) { SwingUtilities . invokeLater ( new Runnable () { public void run () { new EventDemo (); } }); } } El resultat seria Jlist Selection Listener A continuaci\u00f3 escriurem un 'listener' per a un control JList. Suposem una llista que nom\u00e9s pot sel\u00b7leccionar un element de la llista","title":"Tema 9. Gr\u00e0fics 1. Java Swing"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#tema-9-grafics-1-java-swing","text":"","title":"Tema 9. Gr\u00e0fics 1. Java Swing"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#introduccio","text":"Fins ara hem estat utilitzant la consola i el teclat a les nostres aplicacions per tal de comunicar-nos amb l'usuari. En aquest tema utilitzarem l'API de Java per al desenvolupament de components gr\u00e0fics Swing. Swing \u00e9s un conjunt d'eines per a Java. \u00c9s una API que proporciona interf\u00edcie gr\u00e0fica d'usuari (GUI) per a programes de Java. Entre d'altres Swing cont\u00e9: frames, botons, textbox, men\u00fas a banda dels events associats als elements. Swing va ser desenvolupat per a proporcionar un conjunt m\u00e9s complex de components GUI que l'anterior Abstract Window Toolkit (AWT). Swing proporciona un aspecte i aparen\u00e7a natiu que emula diverses plataformes, tamb\u00e9 d\u00f3na suport a extensions d'aspecte i aparen\u00e7a que permeten a les aplicacions tindre un aspecte i apare\u00e7a que no guarda relaci\u00f3 amb la plataforma subjacent. Hu\u00ed en dia la majoria de desenvolupadors Java utilitzen Swing o JavaFX per construir interf\u00edcies d'usuari","title":"Introducci\u00f3"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#la-llibreria-swing","text":"Com tot en Java, swing no anava a ser menys, est\u00e0 dissenyat com una llibreria de classes, interf\u00edcies, recursos, etc.. per la construcci\u00f3 d'insterf\u00edcies gr\u00e0fiques. Swing cont\u00e9 tres APIs una per a components 2D, una altra per al Drag & Drop i l'\u00faltima per facilitar l'acc\u00e9s. Swing est\u00e0 basada en AWT per\u00f2 \u00e9s independent de la plataforma, \u00e9s a dir, sempre mostra la mateixa aparen\u00e7a independentment del sistema en el que s'execute l'aplicaci\u00f3 a difer\u00e8ncia d'AWT. Amb Swing podem fer: - Marcs: Finestres amb de t\u00edtol, men\u00fa, botons maximitzar, minimitzar i tancar. - Contenidors: poden agrupar diversos controls. - Botons - Etiqutes: text - Camps i arees de text. - Desplegables Per tal de poder utilitzar les llibreries Swing de Java hauriem d'afegir al nostre codi el seg\u00fcent: 1 import javax.swing.* ;","title":"La llibreria Swing"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#components-i-contenidors","text":"En general, els components Swing es deriven de la classe JComponent. Les \u00faniques excepcions s\u00f3n els quatre contenidors de nivell superior. JComponent proporciona la funcionalitat que \u00e9s com\u00fa a tots els components. Per exemple, JComponent admet la look & feel conectables. JComponent hereta les classes AWT Container i Component. Per tant, un component Swing est\u00e0 integrat i es compatible amb un component AWT. Tots els components de Swing estan representats per classes definides dins del paquet javax.swing com hem explicat abans. La seg\u00fcent taula mostra els noms de classe per als components Swing inclosos els contenidors.","title":"Components i contenidors"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#components-java-swing","text":"JApplet JButton JCheckBox JCheckBoxMenuItem JColorChooser JComboBox JComponent JDesktopPane JDialog JEditorPane JFileChooser JFormattedTextField JFrame JInternalFrame JLabel JLayer JLayeredPane JList JMenu JMenuBar JMenuItem JOptionPane JPanel JPasswordField JPopUpMenu JProgressBar JRadioButton JRadioButtonMenuItem JRootPane JScrollBar JScrollPane JSeparator JSlider JSpineer JSplitPane JTabbedPane JTable JTextArea JTextField JTextPane JTogglebutton JToolBar JToolTip JTree JViewport JWindows La majora de noms solen ser prou significatius i resulta intuitiu a primer cop d'ull saber quina \u00e9s la finalitat de cadascun dels components.","title":"Components Java Swing"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#contenidors-java-swing","text":"Swing defineix dos tipus de contenidors. Els primers s\u00f3n contenidors de nivell superior: JFrame, JApplet, JWindow i JDialog. (JApplet, que admet applets basats en Swing, ha estat descartat per JDK 9.) Aquests contenidors no hereten JComponent. No obstant aix\u00f2, hereten les classes AWT Component i Container. A difer\u00e8ncia d'altres components de Swing, que s\u00f3n lightweight, els contenidors de nivell superior s\u00f3n heavyweight. Aix\u00f2 fa que els contenidors de nivell superior siguin un cas especial a la biblioteca de components Swing. Com el seu nom indica, un contenidor de nivell superior ha d'estar a la part superior d'una jerarquia de contenci\u00f3. Un contenidor de nivell superior no est\u00e0 contingut en cap altre contenidor. A m\u00e9s, cada jerarquia de contenci\u00f3 ha de comen\u00e7ar amb un contenidor de nivell superior. El m\u00e9s comunament utilitzat per les aplicacions \u00e9s JFrame. El segon tipus de contenidor compatible amb Swing \u00e9s el contenidor lightweight. Els contenidors lightweight hereten JComponent. Exemples de contenidors lightweight s\u00f3n JPanel, JScrollPane i JRootPane. Els contenidors lightweight sovint es fan servir per a organitzar i administrar col\u00b7lectivament grups de components relacionats perqu\u00e8 un contenidor lightweight es pot contenir dins d'un altre contenidor. Per tant, pot utilitzar contenidors lightweight per crear subgrups de controls relacionats que estan continguts dins d'un contenidor extern.","title":"Contenidors Java Swing"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#swing-vs-awt","text":"\u00c9s possible utilitzar Swing i AWT a la mateixa interf\u00edcie, per\u00f2 podria donar problemes. \u00c9s recomanable utilitzar nom\u00e9s components Swing, ja que tot component AWT t\u00e9 el seu equivalent Swing. La majoria de classes Swing comencen per J, per exemple: JButton, JFrame... encara que tamb\u00e9 existeixen Frame i Button que pertanyen a la llibreria AWT. Cal tindre molta cura en no oblidar de posar la 'J' davant dels components ja que si no podria portar a inconsist\u00e8ncies a causa de mesclar components. A l'actualitat quasi tota la programaci\u00f3 gr\u00e0fica en Java es fa amb Swing que implemente una interf\u00edcie gr\u00e0fica normalment va a tenir quatre tipus d'elements: 1. Un contenidor de nivell superior: un marc (JFrame), un applet (JApplet) o b\u00e9 objectes JDialog. Aquests contenidors no estan dins d'una altra finestra, s\u00f3n les finestres principals. 2. Components de la interf\u00edcie gr\u00e0fica: botons, camps de text, etc\u00e8tera, que se situen a la finestra principal o en contenidors. 3. Contenidors dissenyats per altres elements de la interf\u00edcie; JPanel i JScrollPane s\u00f3n dos contenidors i, a el mateix temps, s\u00f3n components. 4. Elements per a la gesti\u00f3 d'esdeveniments. Els components sempre s'afegeixen a una l\u00e0mina o panell; pot ser la de el marc, o b\u00e9 un panell tipus JPanel. En general, sempre es creen classes derivades de les classes contenidors de nivell superior; tot marc ser\u00e0 una subclasse de JFrame, a l'igual que un applet \u00e9s una subclasse de JApplet.","title":"Swing vs AWT"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#creacio-dun-jframe","text":"La difer\u00e8ncia entre crear programes que es comuniquen amb l'usuari mitjan\u00e7ant el terminal i el teclat i fer programes amb Swing \u00e9s considerable. Al crear una aplicaci\u00f3 Swing s'han de tenir en compte conceptes nous com el threading . Per\u00f2 per entendre-ho tot millor, farem un programa Swing d'exemple. Per al programa d'exemple crearem un JFrame al qual li posarem una JLabel","title":"Creaci\u00f3 d'un JFrame"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#exemple-1-programa-simple-swing","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // Un simple programa Swing import javax.swing.* ; public class SwingDemo { SwingDemo (){ JFrame jfrm = new JFrame ( \"Aplicaci\u00f3 Simple Swing\" ); // Crea un nou contenidor JFrame. jfrm . setSize ( 475 , 200 ); // Establim el tamany inicial jfrm . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); // Acabe el programa quan l'usuari tanque l'aplicaci\u00f3. JLabel jLabel = new JLabel ( \"Programaci\u00f3 GUI amb Swing.\" ); // Creem una etiqueta jLabel . setHorizontalAlignment ( SwingConstants . CENTER ); // Situem l'etiqueta al centre del frame jfrm . add ( jLabel ); // Afegim l'etiqueta al frame jfrm . setVisible ( true ); // Visualitzem el marc. } public static void main ( String [] args ) { SwingUtilities . invokeLater ( new Runnable () { public void run (){ new SwingDemo (); } }); } } El resultat del codi anterior seria el seg\u00fcent: JFrame \u00e9s un contenidor de nivell superior que s'utilitza de forma com\u00fa a les aplicacions Swing, mentre que JLabel \u00e9s una etiqueta que ens servir\u00e0 per posar text. Expliquem amb m\u00e9s detall el que fa la funci\u00f3 main: - SwingUtilities.invokeLater() - static void invokeLater(Runnable doRun): Executa un doRun.run() per tal que s'execute de forma asincrona al AWT event dispatching thread. A aquets m\u00e8tode se li ha de passar un objecte Runnable - new Runnable() { }: - Objecte Runnable que s'ha de passar al m\u00e8tode invokeLater - public void run() { }: M\u00e8tode run que s'executa de l'objecte runnable que se li passa a InvokeLater - new SwingDemo() - Codi del m\u00e8tode run de l'objecte runnable. Una aplicaci\u00f3 que implemente una interf\u00edcie gr\u00e0fica normalment va a tindre quatre tipus d'elements. 1. Un contenidor de nivell superior: un marc (JFrame), un applet (JApplet) o b\u00e9 di\u00e0legs (JDialog) que faran el paper de finestra principal. 2. Components de la interf\u00edcie gr\u00e0fica: botons, camps de text, etc, que s'afegiran al contenidor de nivell superior anterior. 3. Contenidors dissenyats per altres elements de la interf\u00edcie: JPanel i JScrollPane s\u00f3n dos contenidors i al mateix temps s\u00f3n components. 4. Elements per la gesti\u00f3 d'events. Els components sempre s'afegeixen a una l\u00e0mina o paper; pot ser la del marc o b\u00e9 un panel tipus JPanel. En general, sempre es creen classes derivades de les classes contenidores de nivell superior. Tot marc ser\u00e0 una subclasse de JFrame, de la mateixa forma que un applet \u00e9s una subclasse de JApplet","title":"Exemple 1. Programa simple Swing"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#jframe","text":"La classe JFrame \u00e9s un tipus de contenidor que hereta de la classe java.awt.Frame. JFrame funciona com la finestra principal on components com etiquetes, botons, camps de text etc, s'afegeixen per crear una interf\u00edcie gr\u00e0fica.","title":"JFrame"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#metodes","text":"M\u00e8tode Descripci\u00f3 JFrame() Constructor de la classe. Crea un marca sense t\u00edtol JFrame (String titol) Crea un marc amb t\u00edtol. void setTitle (String titlo) Estableix el t\u00edtol del marc void setIconImage ( Image img ) Estableix la icona del marc void setDefaultCloseOperation (int op ) programa el comportament del marca quan es tanca. Possibles valors: EXIT_ON_CLOSE, DO_NOTHING_ON_CLOSE, DISPOSE_ON_CLOSE, HIDE_ON_CLOSE Container getContentPane () proporciona el layout de continguts del marc, \u00e9s a dir, les vores void setResizable ( boolean r ) si r val true, es pot redimensionar el marc void add (Component c) Afegeix el component c al marc void removeComponent (Component c) elimina el component c del marc Component add (Component c, int p) Coloca el component c a la posici\u00f3 p del marc void setLayout (LayoutManager mngr) estableix la forma de distribuir el components al marc, els quals normalment es distribueixen en posicions relatives, segons el layout que tinga associat el marc void setVisible (boolean b) fa visible el component si b \u00e9s true void setBounds (int x, int y, int ample, int alt) situa el component i canvia el seu tamany void setLocation (int x, int y) situa el component a les coordenades x i y void setLocation (Point p) situa el component al punt p void setSize (int ample, int alt) estableix les dimensions del component void setSize (Dimension dim) estableix la dimensi\u00f3 del component a dim","title":"M\u00e8todes"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#layout-manager-gestor-de-posicionament","text":"A difer\u00e8ncia d'altres aplicacions que es dediquen al disseny d'interf\u00edcies gr\u00e0fiques, les posicions dels elements dintre del nostre contenidor no es fan en pixels ni valors absoluts, s'utilitzen els Layout Manager que ho podriem traduir com \"gestors de disposici\u00f3\" o \"gestor de plantilla\" o \"gestor de posicionament\". Aquestos gestors de posicionament s\u00f3n elements que implementen la interf\u00edcie \"LayoutManager\". Cada cotenidor t\u00e9 associat un Layout Manager que pot ser: BorderLayout, FlowLayout, GridLayout, BoxLayout, GridBagLayout, CardLayout, SpringLayout... Veiem un exemple:","title":"Layout Manager - Gestor de posicionament"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#exemple-2-marc-de-prova","text":"1 2 JFrame marc = new JFrame ( \"MarcProva\" ); marco . setLayout ( new GridLayout ( 3 , 4 )); El que hem fet al codi anterior \u00e9s crear i instanciar un nou marc de tipus JFrame amb el t\u00edtol \"MarcProva\" i despr\u00e9s hem establert el seu gestor de posicionament de tipus GridLayout. A continuaci\u00f3 detallarem els m\u00e9s utilitzats","title":"Exemple 2. Marc de prova"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#borderlayout","text":"Gestor de posicionament per defecte dels marcs (JFrame) i di\u00e0legs (JDialog). Divideix al contenidor en cinc zones: nord, sud, est, oest i centre, que es corresponen a: BorderLayout.NORTH, BorderLayout.SOUTH, BorderLayout.EAST, BorderLayout.WEST i BorderLayout.CENTER Veiem un exemple:","title":"BorderLayout"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#exemple-3-marc-amb-vora","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import javax.swing.* ; import java.awt.* ; public class MarcBorder extends JFrame { static int AMPLE = 350 ; static int ALT = 200 ; public MarcBorder () { super ( \"T\u00edtol Marc\" ); add ( new JLabel ( \"Nord\" , SwingConstants . CENTER ), BorderLayout . NORTH ); add ( new JLabel ( \"Sud\" , SwingConstants . CENTER ), BorderLayout . SOUTH ); add ( new JLabel ( \"Centre\" , SwingConstants . CENTER ), BorderLayout . CENTER ); add ( new JLabel ( \"Oest\" , SwingConstants . CENTER ), BorderLayout . WEST ); add ( new JLabel ( \"Est\" , SwingConstants . CENTER ), BorderLayout . EAST ); setSize ( AMPLE , ALT ); setVisible ( true ); } public static void main ( String args [] ) { MarcBorder marc = new MarcBorder (); marc . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); } } El resultat del codi anterior \u00e9s:","title":"Exemple 3. Marc amb vora"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#flowlayout","text":"Amb aquest gestor podem colocar els elements d'esquerra cap a dreta i de dalt cap avall. La classe FlowLayout disposa de diversos constructors, un d'ells ens permet establir l'alineaci\u00f3 dels components FlowLayout(int align) on align pot ser: FlowLayout.RIGHT, FlowLayout.CENTER, FlowLayout.LEFT.","title":"FlowLayout"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#exemple-4-flowlayout","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import java.awt.* ; import javax.swing.* ; public class MarcFlow extends JFrame { static int AMPLE = 175 ; static int ALT = 100 ; public MarcFlow () { super ( \"El meu marc\" ); setLayout ( new FlowLayout ()); add ( new JLabel ( \"Primera\" )); add ( new JLabel ( \"Segona\" )); add ( new JLabel ( \"Tercera\" )); add ( new JLabel ( \"Quarta\" )); add ( new JLabel ( \"Cinquena\" )); add ( new JLabel ( \"Sisena\" )); setSize ( AMPLE , ALT ); setVisible ( true ); } public static void main ( String args [] ) { MarcFlow marc = new MarcFlow (); marc . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); } } I aquest \u00e9s el resultat:","title":"Exemple 4. Flowlayout"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#gridlayout","text":"Aquest gestor de posicionament distribueix els components del container associat en forma de graella de cel\u00b7les iguals en forma de quadricula de dalt cap avall i de esquerra a dreta, \u00e9s a dir, en files i columnes.","title":"GridLayout"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#exemple-5-gridlayout","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import java.awt.* ; import javax.swing.* ; public class MarcGrid extends JFrame { static int AMPLE = 175 ; static int ALT = 100 ; public MarcGrid () { super ( \"El meu marc\" ); setLayout ( new GridLayout ( 3 , 2 , 15 , 15 )); add ( new JLabel ( \"Primera\" )); add ( new JLabel ( \"Segona\" )); add ( new JLabel ( \"Tercera\" )); add ( new JLabel ( \"Quarta\" )); add ( new JLabel ( \"Cinquena\" )); add ( new JLabel ( \"Sisena\" )); setSize ( AMPLE , ALT ); setVisible ( true ); } public static void main ( String args [] ) { MarcGrid marc = new MarcGrid (); marc . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); } } Resultat del codi anterior:","title":"Exemple 5. GridLayout"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#boxlayout","text":"Aquest gestor coloca els components en una \u00fanica fila o una \u00fanica columna, s'assembla a una caixa amb orientaci\u00f3 horitzontal o vertical; el constructor necessita un argument amb el contenidor que es va a utilitzar i l'orientaci\u00f3 que pot ser: BoxLayout.X_AXIS o BoxLayout.Y_AXIS. El format del constructor \u00e9s: BoxLayout (Container desti, int orientacio)","title":"BoxLayout"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#exemple-6-boxlayout","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import javax.swing.* ; import java.awt.* ; public class MarcBox extends JFrame { static int AMPLE = 175 ; static int ALT = 150 ; public MarcBox () { super ( \"El meu marcBox\" ); JPanel panel = new JPanel () ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . Y_AXIS )); panel . add ( new JLabel ( \"Primera\" )); panel . add ( new JLabel ( \"Segona\" )); panel . add ( new JLabel ( \"Tercera\" )); panel . add ( new JLabel ( \"Quarta\" )); panel . add ( new JLabel ( \"Cinquena\" )); panel . add ( new JLabel ( \"Sisena\" )); add ( panel ); setSize ( AMPLE , ALT ); setVisible ( true ); } public static void main ( String args [] ) { MarcBox miMarcBox = new MarcBox (); miMarcBox . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); } }","title":"Exemple 6. BoxLayout"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#boxlayout-box","text":"Box o caixa, \u00e9s un contenidor que t\u00e9 com gestor de posicionament (LayoutManager) predeterminat un BoxLayout; utilitzant aquest contenidor no cal crear un panel perqu\u00e8 directament es crea un objecte Box i a continuaci\u00f3 s'afegeixen els components. La classe Box disposa de dos m\u00e8todes static (m\u00e8todes factoria) que creen l'objecte, i s\u00f3n: 1 2 Box . createHorizontalBox (); Box . createVerticalBox (); Aleshores, per crear un Box no s'utilitza el constructor sino que es crida a un d'aquestos dos m\u00e8todes; per un objecte Box amb orientaci\u00f3 horitzontal, per exemple: 1 Box caixaHoriz = Box . createHorizontalBox (); Al contenidor se li afegeix el component caixaHoriz.add(element) i despr\u00e9s el contenidor al marc.","title":"BoxLayout - Box"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#exemple-7-boxlayout-box","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import javax.swing.* ; import java.awt.* ; public class Marc2Box extends JFrame { static int AMPLE = 275 ; static int ALT = 175 ; public Marc2Box () { super ( \"El meu marc\" ); JButton b1 = new JButton ( \"Boto1\" ); JButton b2 = new JButton ( \"Boto2\" ); JButton b3 = new JButton ( \"Boto3\" ); JButton b4 = new JButton ( \"Boto4\" ); JButton b5 = new JButton ( \"Boto5\" ); JButton b6 = new JButton ( \"Boto6\" ); Box caixaH = Box . createHorizontalBox (); // m\u00e9todo factor\u00eda caixaH . add ( b1 ); // separaci\u00f3n horizontal de 10 pixeles caixaH . add ( Box . createHorizontalStrut ( 10 )); caixaH . add ( b2 ); // zona r\u00edgida, separaci\u00f3n horizontal caixaH . add ( Box . createRigidArea ( new Dimension ( 5 , 5 ))); caixaH . add ( b3 ); add ( caixaH , BorderLayout . NORTH ); Box caixaV = Box . createVerticalBox (); caixaV . add ( Box . createHorizontalStrut ( 70 )); caixaV . add ( b4 ); // separaci\u00f3n horizontal 10 pixeles caixaV . add ( Box . createVerticalStrut ( 10 )); caixaV . add ( b5 ); caixaV . add ( Box . createRigidArea ( new Dimension ( 5 , 5 ))); caixaV . add ( b6 ); add ( caixaV , BorderLayout . CENTER ); setSize ( AMPLE , ALT ); setVisible ( true ); } public static void main ( String args [] ) { Marc2Box marcBox2 = new Marc2Box (); marcBox2 . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); } }","title":"Exemple 7. BoxLayout - Box"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#combinar-layouts","text":"JFrame, JDialog i JPanel nom\u00e9s poden tindre un gestor de posicionament per\u00f2 si agafem un contenidor de primer nivell com un marc, podr\u00edem combinar diversos layouts niats (nested). Al seg\u00fcent exemple podem veure una combinaci\u00f3 de tres gestors de posicionament en un mateix contenidor.","title":"Combinar Layouts"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#exemple-8-combinacio-de-disposicions-layouts","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import javax.swing.* ; import java.awt.* ; public class MarcGestors extends JFrame { public MarcGestors () { JPanel pa1 = new JPanel ( new FlowLayout ()); JPanel pa2 = new JPanel ( new BorderLayout ()); JPanel pa3 = new JPanel (); pa3 . setLayout ( new BoxLayout ( pa3 , BoxLayout . Y_AXIS )); // componentes del panel 1 String [] opc = { \"Alta mar\" , \"Baixa mar\" , \" Muntanya\" }; pa1 . add ( new JLabel ( \"Tria..\" , JLabel . CENTER )); pa1 . add ( new JList ( opc )); pa1 . add ( new JButton ( \"Pr\u00e8mer\" )); // componentes del panel 2 JTextField j = new JTextField ( \"Raons \" ); j . setEditable ( false ); pa2 . add ( j , BorderLayout . WEST ); pa2 . add ( new JButton ( \"Bot\u00f3\" ), BorderLayout . EAST ); // componentes del panel 3 pa3 . add ( new JCheckBox ( \"Box \" , false )); pa3 . add ( new JLabel ( \"Calendari\" , JLabel . CENTER )); pa3 . add ( new JRadioButton ( \"Bot Radio\" , true )); // asigna layout al marco y se ponen los paneles setLayout ( new BorderLayout ( 10 , 15 )); add ( pa1 , BorderLayout . NORTH ); add ( pa2 , BorderLayout . CENTER ); add ( pa3 , BorderLayout . SOUTH ); } public static void main ( String [] args ) { MarcGestors m ; m = new MarcGestors (); m . setSize ( 200 , 300 ); m . setLocation ( 20 , 200 ); m . setResizable ( false ); m . setVisible ( true ); m . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); } } El resultat seria:","title":"Exemple 8. Combinaci\u00f3 de disposicions (layouts)"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#desactivar-gestor-de-posicionament","text":"Per defecte un contenidor sempre t\u00e9 associat un gestor de posicionament (layout) per\u00f2 de vegades ens pot resultar interessant desactivar aquest gestor de posicionament. Utilitzarem el m\u00e8tode setLayout i li passarem per parametre null.","title":"Desactivar gestor de posicionament"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#etiqutes","text":"Una etiqueta \u00e9s un component nom\u00e9s lectura al qual li podem modificar el text que cont\u00e9 i que normalment s'utilitza per posar algun missatge significatiu de la nostra interf\u00edcie a l'usuari final. En altres paraules, s\u00f3n components de text fixe que nom\u00e9s mostren text per\u00f2 que no reben cap event. Per gestionar les etiquetes a Java utilitzem la classe JLabel","title":"Etiqutes"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#metodes_1","text":"JLabel (): Crea una etiqueta sense text associat. JLabel (String msg): Crea una etiqueta amb el text msg. JLabel (String msg, Icon icona): Crea una etiqueta amb el text msg i la icona icon. JLabel (String msg, int align): crea una etiqueta amb el text msg alineat segons el segon argument que pot ser SwingConstants.CENTER, SwingConstants.LEFT o SwingConstants.RIGHT. public String getText (): torna el text de l'etiqueta public void setText (String msg): estableix el text de l'etiqueta.","title":"M\u00e8todes"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#botons","text":"A Swing es defineixe diversos tipus de botons, la classe base dels quals \u00e9s Abstract Button , \u00e9s una classe abstracta que encapsula propietats i m\u00e8todes comuns als diversos tipus de botons","title":"Botons"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#metodes_2","text":"void setText (String text) : Estableix el text del bot\u00f3. String getText () : Obt\u00e9 el text del bot\u00f3. boolean isSelected() : true si s'ha seleccionat el bot\u00f3. void setSelectes (boolean b) : selecciona el bot\u00f3. void doClick (int temps) : tria el bot\u00f3 durant temps milisegons void setIcon (Icon icona) : estableix la icona del bot\u00f3. void setMnemonic (int mnemonic) : relaciona una tecla amb el bot\u00f3. void addActionListener(ActionListener al) : assigna un listener per controlar events.","title":"M\u00e8todes"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#jbutton","text":"La classe JButton representa el bot\u00f3 com\u00fa; es crea especificament una cadena, una icona, ambdos, o un element encara sense especificar; els constructors de la classe s\u00f3n: - JButton() : Constructor de la classe - JButton(String text) : Constructor amb text del bot\u00f3. - JButton(String text, Icon icona) : Constructor amb text i icona. La classe deriva d'AbstractButton per tant tots els seus m\u00e8todes estaran disponibles tamb\u00e9. 1 2 3 4 JButton b1 , b2 , b3 ; b1 = new JButton (); b2 = new JButton ( \"GROC\" ); b3 = new JButton ( new LibroIcon ());","title":"JButton"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#botons-amb-dos-estats","text":"JToogleButton \u00e9s la classe base dels botons amb dos estats; JRadioButton que s'utilitza per definir un grup de botons d'opci\u00f3 \u00fanica; per agrupar botons d'opci\u00f3 \u00fanica s'utilitza la classe ButtonGroup, primer es crea un objecte ButtonGroup (constructor sense arguments); a continuaci\u00f3 s'afegeix JRadioButton amb el m\u00e8tode de ButtonGroup, add(AbstracButton b).","title":"Botons amb dos estats"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#constructors-de-jradiobutton","text":"JRadioButton() : Constructor per defecte. JRadioButton(String msg) : Constructor amb text del bot\u00f3. JRadioButton(String msg, boolean sel) : Constructor amb el text i si sel \u00e9s true, el bot\u00f3 ja estaria seleccionat.","title":"Constructors de JRadioButton"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#exemple-9-diversons-botons","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import javax.swing.* ; class PanelJRadio extends JPanel { ButtonGroup grb ; JRadioButton jr1 , jr2 , jr3 ; public PanelJRadio () { grb = new ButtonGroup (); setLayout ( new GridLayout ( 4 , 1 )); add ( new JLabel ( \"Selecci\u00f3 excloent\" )); // se crea bot\u00f3n de radio, se a\u00f1ade al panel y a la agrupaci\u00f3n jr1 = new JRadioButton ( \"Avi\u00f3\" , false ); add ( jr1 ); grb . add ( jr1 ); // se crea bot\u00f3n de radio, se a\u00f1ade al panel y a la agrupaci\u00f3n jr2 = new JRadioButton ( \"Tren\" , false ); add ( jr2 ); grb . add ( jr2 ); // se crea bot\u00f3n de radio, se a\u00f1ade al panel y a la agrupaci\u00f3n jr3 = new JRadioButton ( \"Cotxe\" , false ); add ( jr3 ); grb . add ( jr3 ); } } JCheckBox o tamb\u00e9 anomenat: casella de verificaci\u00f3, check o checkbox.","title":"Exemple 9. Diversons botons"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#constructors-de-jcheckbox","text":"JCheckBox(): Constructor per defecte. JCheckBox(String text): : Constructor amb el text associat. JCheckBox(String text, boolean sel): Constructor amb text i si sel \u00e9s true, la casella vindria ja marcada. La classe JComboBox no est\u00e0 a la jerarquia de botons, no deriva d'AbstractButton; combina en un sol component un bot\u00f3 amb una llista d'elements. Una JComboBox s'utilitza per crear una llista desplegable a la que es poden afegir opcions, editarles o fer seleccions.","title":"Constructors de JCheckBox"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#constructors-de-jcombobox","text":"JComboBox(): Constructor per defecte. JComboBox(Object llista[]): Constructor amb una llista d'objectes per par\u00e0metre. Alguns dels seus m\u00e8todes s\u00f3n: - public void addItem(Object q): afegeix un element a la llista (pel final). - public insertItemAt(Object q, int indice): insereix en \u00edndex l'element. - public void setEditable(boolean flag): si flag \u00e9s true l'element de llista seleccionat \u00e9s editable. - public void setMaximumRowCount(int n): posa el m\u00e0xim d'elements a mostrar en el combo, si hi ha m\u00e9s elements apareix la barra d'scroll. - public Object getSelectedItem(): torna l'element seleccionat. Els m\u00e8todes seg\u00fcents s\u00f3n per la gesti\u00f3 d'events al combobox: - public void actionPerformed(ActionEvent ev); - public void addActionListener(ActionListener ae); - public void addItemListener(ItemListener it); - public void addStateChanged(ItemEvent ev);","title":"Constructors de JComboBox"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#exemple-10-combobox","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import javax.swing.* ; import java.awt.* ; import java.awt.event.* ; class PanelJCombo extends JPanel { private JComboBox jcb ; public PanelJCombo () { jcb = new JComboBox (); setLayout ( new BorderLayout ()); jcb . addItem ( \"MAD - BCN\" ); jcb . addItem ( \"MAD - AGP\" ); jcb . addItem ( \"MAD - XRY\" ); jcb . addItem ( \"BRU - TFN\" ); jcb . addItem ( \"LEN - BCN\" ); jcb . addItem ( \"ROM - BCN\" ); jcb . setMaximumRowCount ( 4 ); add ( jcb , BorderLayout . NORTH ); } }","title":"Exemple 10. ComboBox"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#components-de-text","text":"Els components Swing que s'utilitzen per editar o mostrar text formen una jerarquia de classes la base de la qual \u00e9s JTextComponent; aquesta \u00faltima \u00e9s una classe abstracta que es troba al paquet java.swing.text","title":"Components de text"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#jtextcomponent","text":"Els components de text suporten una ampla varietat de caracters de c\u00f2dis alfab\u00e8tics; en ells es pot inserir, esborrar o seleccionar caracters; \u00e9s text modificable per l'usuari; la classe disposa del constructor JTextComponent() que crea una component de text editable. Els seus m\u00e8todes s\u00f3n: - String getText(): torna el text que t\u00e9 el component. - String getText(int dspl,int lon): torna el text del component a partir del despla\u00e7ament dspl i de la longitud lon. - void setText(String txt): : substituieix el text del component per txt; si txt \u00e9s null o \u00e9s una cadena buida, esborra el text del component. - void setEditable(boolean b): un component de text \u00e9s editable per omisi\u00f3; amb aquest m\u00e8tode s'especifica si \u00e9s o no.","title":"JTextComponent"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#jtextfield-jpasswordtext","text":"La classe JTextField representa un camp de text modificable per l'usuar; amb aquest component s'edita una l\u00ednia de text amb l'ample, alineaci\u00f3 i tipus de lletra que es desitge. JPasswordField es deriva de JTextField; representa un camp de text amb la particularitat de que emmascara els caracters quan es visualitza; s'utilitza per editar una clau secreta, contrasenya o password; per omisi\u00f3, cada caracter de un JPasswordField es substitueix per un '*'. Els constructors de JTextField s\u00f3n: - JTextField(): camp de text buit de 0 columnes. - JTextField(int cols): camp de text buit de cols columnes. - JTextField(String msg): camp de text ajustat a la cadena msg. - JTextField(String msg,int col): camp de text amb la cadena msg i de cols columnes. Els constructors de JPasswordField tenen els mateixos arguments que JTextField; els seus m\u00e8todes s\u00f3n: - void setFont(Font tipo) - void setHorizontalAlignment(int alig): alineaci\u00f3 del text; els valors possibles d'alig son les constants de SwingConstants : RIGHT, LEFT, CENTER, TRAILING, LEADING (aquest \u00e9s el predeterminat) - void setColumns(int cols): posa el n\u00famero de columnes preferit per al camp. JPasswordField hereta els m\u00e8todes anteriors i a m\u00e9s a m\u00e9s disposa d'aquestos: - void setEchoChar(char c): coloca c per emmascarar els caracters del camp. - char getEchoChar(): torna el caracter que emmascara; per defecte ' '. - char[] getPassword(): * torna la cadena del camp en un array de caracters.","title":"JTextField, JPasswordText"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#exemple-11-passwords-i-labels","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 import javax.swing.* ; import java.awt.* ; import java.awt.event.* ; public class MarcPassWord extends JFrame { private static final int AMPLE = 300 , ALT = 150 ; private JPasswordField clau = null ; private JLabel et1 = null ; private JLabel res = null ; public MarcPassWord ( String c ) { super ( c ); setSize ( ANCHO , ALTO ); creaComponentes (); pack (); } private void creaComponents () { clau = new JPasswordField ( 20 ); et1 = new JLabel (); // oyente para proceso de la acci\u00f3n del usuario clave . addActionListener ( new ActionListener () { public void actionPerformed ( ActionEvent evt ) { procesoAccionUser ( evt ); } }); // pone el campo de texto con la clave add ( clau , BorderLayout . CENTER ); // crea y pone la etiqueta en el marco et1 . setFont ( new java . awt . Font ( \"Times New Roman\" , 3 , 12 )); et1 . setHorizontalAlignment ( javax . swing . SwingConstants . CENTER ); et1 . setText ( \"PASSWORD \" ); et1 . setToolTipText ( \"Exemple\" ); add ( et1 , BorderLayout . NORTH ); // m\u00e9todo que se ejecuta al actuar el usuario sobre el campo private void procesoAccionUser ( ActionEvent evt ) { char pas [] ; pas = clau . getPassword (); res = new JLabel ( \" \" ); res . setFont ( new Font ( \"Book Antiqua\" , 3 , 14 )); if ( pas . length == 0 ) { System . out . println ( \"Teclejar Password \" ); et1 . setText ( \"PASSWORD(teclejar) \" ); } else { clau . setEditable ( false ); res . setText ( \"Es valida la clau\" ); } add ( res , BorderLayout . SOUTH ); validate (); pack (); } public static void main ( String args [] ) { MarcPassWord marc ; marc = new MarcPassWord ( \"Marc amb password\" ); marc . setVisible ( true ); marc . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); } } } Resultat","title":"Exemple 11. Passwords i Labels"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#jtextarea","text":"El component JTextArea s'utilitza amb la finalitat de mostrar moltes l\u00ednies de text; disposa de m\u00e8todes per fixar l'ample de cada l\u00ednia i l'acci\u00f3 a realitzar si la l\u00ednia que s'insereix \u00e9s major que l'ample prefixat; tamb\u00e9 permet decidir si es trenquen o no les paraules al canvi de l\u00ednia. Aquest component no disposa de barra d'scroll JScrollPane , cal crear l'scroll i associar-lo al component; per exemple: es crea el component areaText: 1 2 3 4 5 JTextArea areaText = new JTextArea (); // A continuaci\u00f3 es crea l'scroll i s'associa a **areaText**: JScrollPane barra = new JScrollPane ( areaText ); // Per \u00faltim, l'scroll es posa al marc areaText . add ( barra ); Els constructors s\u00f3n: - JTextArea(): crea el component amb cadena nula, zero files i columnes. - JTextArea(int filas,int cols): crea amb cadena nula i el n\u00famero de files i columnes especificat. - JTextArea(String t): crea el component amb cadena t i zero files i columnes. - JTextArea(String t,int filas, int col): crea el component amb cadena t i el n\u00famero de files i columnes especificat. Els seus m\u00e8todes s\u00f3n: - public void append(String t): afegeix la cadena t al final del document. - public void insert(String t,int p): insereix la cadena t a partir de la posici\u00f3 p. - void replaceRange(String t, int inici, int fi): substitueix el text del document al rang inici-fi per la cadena t. - public void setColumns(int cols): fixa l'ample de cada l\u00ednia. - public void setLineWrap(boolean f): si f \u00e9s true activa el canvi autom\u00e0tica de l\u00ednia. - public void setWrapStyleWord(boolean f): si f \u00e9s true no 'trenca' les paraules en el canvi de l\u00ednia.","title":"JTextArea"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#esdeveniments","text":"En aquest punt tractarem l'\u00fas dels esdeveniments per tal que la nostra aplicaci\u00f3 interactue amb l'usuari. Esdeveniment: All\u00f2 que s'esdev\u00e9. Fet considerat extraordinari o molt important en la vida d'una persona o col\u00b7lectivitat. Esdeveniment (Inform\u00e0tica): Fet que s'esdev\u00e9 o canvi d'un conjunt particular de circumst\u00e0ncies. En altres paraules un esdeveniment en una aplicaci\u00f3 inform\u00e0tica \u00e9s all\u00f3 que passa sense que necessariament estiga controlat al codi. Exemples d'esdeveniments: - Fer clic a un bot\u00f3. - Fer clic dins d'un textbox. - Minimitzar una finestra. - Escriure al teclat - etc Arribats a aquest punt podriem tindre una interf\u00edcie totalment dissenyada per\u00f2 no completament funcional, \u00e9s a dir, imagineu que hem dissenyat la interf\u00edcie per a una calculadora amb tots els seus controls necessaris. Qu\u00e8 passa si fem clic en algun bot\u00f3 de la calculadora? No res ,veritat. Encara hem de programar el comportament d'aquesta calculadora i per tal d'aconseguir-ho hem de fer \u00fas de la programaci\u00f3 d'esdeveniments. Aquest procediment es diu Event Handling i es pot aplicar a aquells elements gr\u00e0fics que produeixen algun esdeveniment. Els esdeveniments s\u00f3n essencials per als usuaris interactuen amb els components de una aplicaci\u00f3 gr\u00e0fica; el model d'esdeveniments segueix el AWT de Java. Aquest cap\u00edtol estudia la forma general de captura d'esdeveniments, la jerarquia de classes del model i les interfaces desenvolupades per a la seva captura; inclou exemples senzills de captura d\u2019esdeveniments de los botons. Veiem un exemple 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import java.awt.* ; import java.awt.event.* ; import javax.swing.* ; public class EventDemo { JLabel lab ; public EventDemo () { JFrame jfrm = new JFrame ( \"Esdeveniments\" ); jfrm . setLayout ( new FlowLayout ()); jfrm . setSize ( 220 , 90 ); jfrm . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); JButton btnAlpha = new JButton ( \"Alpha\" ); JButton btnBeta = new JButton ( \"Beta\" ); btnAlpha . addActionListener ( new ActionListener () { public void actionPerformed ( ActionEvent ae ) { lab . setText ( \"Alpha Pressed\" ); } }); btnBeta . addActionListener ( new ActionListener () { public void actionPerformed ( ActionEvent ae ) { lab . setText ( \"Beta Pressed\" ); } }); jfrm . add ( btnAlpha ); jfrm . add ( btnBeta ); lab = new JLabel ( \"Apreta un bot\u00f3\" ); jfrm . add ( lab ); jfrm . setVisible ( true ); } public static void main ( String [] args ) { SwingUtilities . invokeLater ( new Runnable () { public void run () { new EventDemo (); } }); } } El resultat seria","title":"Esdeveniments"},{"location":"Tema%2009.%20Gr%C3%A0fics.%20Java%20Swing/#jlist-selection-listener","text":"A continuaci\u00f3 escriurem un 'listener' per a un control JList. Suposem una llista que nom\u00e9s pot sel\u00b7leccionar un element de la llista","title":"Jlist Selection Listener"},{"location":"Tema%2010.%20Acc%C3%A9s%20a%20dades/","text":"Tema 10. Acc\u00e9s a dades Introducci\u00f3 Fins ara hem estat treballant amb aplicacions que si necessitaven desar informaci\u00f3 o carregar-la, ho feiem utilitzant arxius o la consola d'entrada. En aquest tema veurem com podem connectar una aplicaci\u00f3 Java a una base de dades MySql. JDBC Java proporciona l\u2019API Java Database Connectivity (connectivitat Java a bases dedades) com a mecanisme per poder generar i invocar sent\u00e8ncies SQL sobre una base de dades relacional mitjan\u00e7ant codi en programes Java. La seva particularitat \u00e9s que, en contrast amb altres sistemes existents, ofereix una interf\u00edcie comuna per a l\u2019acc\u00e9s a qualsevol tipus de BD, independentment del fabricant. Per al desenvolupador, la BD real que hi ha al darrere \u00e9s totalment transparent i obvia la necessitat d\u2019efectuar cap classe de configuraci\u00f3 en la m\u00e0quina on s\u2019executa l\u2019aplicaci\u00f3 que accedeix ales dades. Aquesta biblioteca es troba principalment en els paquets java.sql i javax.sql . Partint de la suposici\u00f3 que ja hi ha una BD correctament configurada i a la qualvolem accedir des del codi d\u2019un programa Java, el resum de passos que cal fer dins l\u2019aplicaci\u00f3 \u00e9s: Importar correctament els packages corresponents Carregar el controlador (driver) per a l\u2019acc\u00e9s a la BD. Aquest dep\u00e8n de la BD a accedir. Establir la connexi\u00f3 a la BD. A partir d\u2019aqu\u00ed, ja es poden executar sent\u00e8ncies SQL en la BD i processarles respostes. Quan ja no es vol treballar m\u00e9s amb la BD, cal tancar la connexi\u00f3. JDBC, igual que moltes altres API en Java, est\u00e0 dissenyat amb la simplicitat enel pensament i intenta que l\u2019ordre de les operacions que ha de fer l\u2019operador siga gen\u00e8ric i, fins a cert punt, l\u00f2gic. Igual que per llegir dades d\u2019un fitxer el que cal fer\u00e9s dir quina \u00e9s la seva ubicaci\u00f3, obrir-lo, llegir o escriure les dades i tancar-lo, enaquest cas la idea \u00e9s similar. Simplement, \u201cllegir-lo o escriure\u2019l\u201d vol dir invocaruna sent\u00e8ncia SQL, enlloc de posicionar un apuntador. Tot i aix\u00ed, cal tenir un cert domini d\u2019SQL per poder fer correctament aquesta feina. Instal\u00b7laci\u00f3 de drivers Per poder connectar-nos a una base de dades utilitzant JDBC primer hem d'instal\u00b7lar els drivers i afegir-los al classpath per tal que siguen accessibles. Cada fabricant de sistemes gestors de bases de dades ofereix el connector JDBC per a la seua base de dades, aix\u00f2 vol dir que si la nostra aplicaci\u00f3 s'ha de connectar a una base de dades mysql, ser\u00e0 des del lloc web de MySql d'on ens haruem de descarregar el driver, mentre que si el que volem \u00e9s accedir a una base de dades Oracle, haurem d'obtenir el driver JDBC des d'Oracle. Descarregar driver A continuaci\u00f3 podeu entrar i descarregar el driver JDBC per a MySql de de la seg\u00fcent p\u00e0gina: https://dev.mysql.com/downloads/connector/j/ $ > apt install ./mysql-connector-java_8.0.24-1ubuntu20.04_all.deb $ > dpkg -i mysql-connector-java_8.0.24-1ubuntu20.04_all.deb Una vegada executades aquestos commandaments, tindrem didponible el paquest mysql-connector.jar a la ruta /usr/share/java i ara hauriem de podre afegir el paquet al classpath del nostre projecte. Afegir al Classpath All\u00f2 important \u00e9s que el fitxer que cont\u00e9 el driver mysql-connector.jar es trobe dins del classpath del projecte. Ja que anirem a eixe path per carregar-lo i utilitzar-lo al notre programa. La manera m\u00e9s facil d'afegir el paquet al classpath del nostre projecte \u00e9s amb eclipse. Fem clic dret sobre el nostre projecte i seleccionem propietats Al di\u00e0leg que s'ens obre, hem d'anar a Java Build Path i dins de la pestanya Libraries punxar sobre l'opci\u00f3 Classpath per finalment fer clic al bot\u00f3 Add External JARs . Ja nom\u00e9s ens quedaria anar a la carpeta en la qual es troba el fitxer .jar del driver i seleccionar-lo. Finalment premem el bot\u00f3 Aplicar i tancar i ja ho tindriem al path del nostre projecte. Connexi\u00f3 a la base de dades Per tal de podre connectar amb una base de dades utilitzarem els paquets java.sql i javax.sql . Dins d'aquestos paquets disposem d'una s\u00e8rie de classes,interf\u00edcies etc.. que ens serviran per poder interactuar amb el nostre sistema gestor de bases de dades. Els m\u00e9s importants s\u00f3n: la classe DriveManager i les interf\u00edcies: ResultSet , Connection , Statement i DataSource . Per tant primer, importem tant java.sql com javax.sql al nostre projecte. 1 2 import java.sql.* ; import javax.sql.* ; Una vegada ja tenim importats els paquets del driver JDBC, hem d'establir la connexi\u00f3 a la base de dades mitjan\u00e7ant un objecte connexi\u00f3 i aquest objecte connexi\u00f3 estar\u00e0 relacionat amb un String on s'emmagatzemar\u00e0 la cadena de connexi\u00f3 a la base de dades. Veiem alguns exemples de cadenes de connexi\u00f3: jdbc:mysql://localhost:port/BD jdbc:odbc:DSN_BD jdbc:oracle:usuari@servidor:port:BD Cal tindre tamb\u00e9 l'usuari i la contrassenya d'acc\u00e9s a la base de dades. Tamb\u00e9 esl pot donar el cas que es llence una excepci\u00f3, per tant, necessitarem posar el codi dins d'un bloc try..catch. En definitiva per tal d'establir una connexi\u00f3 amb la nostra base de dades en Java ho fariem de la seg\u00fcent forma: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import java.sql.* ; import javax.sql.* ; public class ConnectaBD { private Connection con ; public MySqlConnection () { try { // 1. Establim la connexi\u00f3 amb la base de dades. con = DriverManager . getConnection ( \"jdbc:mysql://localhost:3306/CicleFormatiu\" , \"root\" , \"******\" ); } catch ( Exception e ) { System . out . println ( \"Error Acc\u00e9s BD\" ); } } } I des del main o la classe Test que cont\u00e9 el m\u00e8tode main est\u00e0tic: 1 2 3 4 5 6 7 8 9 10 import java.sql.* ; import javax.sql.* ; public class TestBD { public static void main ( String [] args ) { ConnectaBD m = new ConnectaBD (); } } Arribats a aquest punt ja tindriem establerta la connexio entre la nostra aplicaci\u00f3 i la base de dades Creaci\u00f3 i execuci\u00f3 de sent\u00e8ncies SQL El seg\u00fcent pas, una vegada ja tenim establerta la connexi\u00f3 amb la nostra base de dades hem de crear un objecte Statement des del objecte connexi\u00f3 amb el m\u00e8tode createStatement() que ens retornar\u00e0 un objecte de tipus Statement . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import java.sql.* ; import javax.sql.* ; public class ConnectaBD { private Connection con ; private Statement stat ; public ConnectaBD () { try { // 1. Establim la connexi\u00f3 amb la base de dades. con = DriverManager . getConnection ( \"jdbc:mysql://localhost:3306/CicleFormatiu\" , \"root\" , \"******\" ); // 2. Creem l'objecte Statement. stat = con . createStatement (); } catch ( Exception e ) { System . out . println ( \"Error Acc\u00e9s BD\" ); } } } Ara hauriem de poder executar les sent\u00e8ncies SQL que necessitem. Per poder executar sent\u00e8ncies Sql utilitzarem el m\u00e8tode executeQuery() que \u00e9s un m\u00e8tode que pertany a l'objecte Statement anteriorment creat. Aquest m\u00e8tode ens resornar\u00e0 un ResultSet qu\u00e8 \u00e9s on tindrem la informaci\u00f3 obtesa de la base de dades. En el nostre exemple, crearem un m\u00e8otde nou a la classe MySqlConnection de tipus public al qual se li passar\u00e0 un objecte strQuery de tipus String i ens retornar\u00e0 un ResultSet. Veiem el codi c continuaci\u00f3: 1 2 3 4 5 6 7 8 9 10 11 12 public ResultSet ExecutarSQL ( String strQuery ) { ResultSet rs = null ; if ( strQuery == null ) return null ; try { rs = stat . executeQuery ( strQuery ); } catch ( Exception e ) { System . out . println ( \"Error executant SQL\" ); } return rs ; } Amb aquest codi, des de la nostra classe on es troba el m\u00e8tode main estatic podriem fer el seg\u00fcent: 1 2 3 4 5 6 7 8 9 10 11 import java.sql.* ; import javax.sql.* ; public class TestBD { public static void main ( String [] args ) { ConnectaBD m = new ConnectaBD (); ResultSet rs = m . ExecutarSQL ( \"SELECT * FROM Alumnes;\" ); } } Una vegada executat i comprovat aquest codi, deuriem tindre tots els alumnes de la nostra base de dades al ResultSet rs . Obtenci\u00f3 de dades I ara com llegim els registres de la BD? En el ResultSet que hem obt\u00e9s al pas anterior, el que tindrem ser\u00e0 una esp\u00e8cie de taula on podrem recorrer tota la informaci\u00f3. Per poder accedir a aquest resultSet podem utilitzar els m\u00e8todes getString() i next() de l'objecte resultSet .","title":"Tema 10. Acc\u00e9s a dades"},{"location":"Tema%2010.%20Acc%C3%A9s%20a%20dades/#tema-10-acces-a-dades","text":"","title":"Tema 10. Acc\u00e9s a dades"},{"location":"Tema%2010.%20Acc%C3%A9s%20a%20dades/#introduccio","text":"Fins ara hem estat treballant amb aplicacions que si necessitaven desar informaci\u00f3 o carregar-la, ho feiem utilitzant arxius o la consola d'entrada. En aquest tema veurem com podem connectar una aplicaci\u00f3 Java a una base de dades MySql.","title":"Introducci\u00f3"},{"location":"Tema%2010.%20Acc%C3%A9s%20a%20dades/#jdbc","text":"Java proporciona l\u2019API Java Database Connectivity (connectivitat Java a bases dedades) com a mecanisme per poder generar i invocar sent\u00e8ncies SQL sobre una base de dades relacional mitjan\u00e7ant codi en programes Java. La seva particularitat \u00e9s que, en contrast amb altres sistemes existents, ofereix una interf\u00edcie comuna per a l\u2019acc\u00e9s a qualsevol tipus de BD, independentment del fabricant. Per al desenvolupador, la BD real que hi ha al darrere \u00e9s totalment transparent i obvia la necessitat d\u2019efectuar cap classe de configuraci\u00f3 en la m\u00e0quina on s\u2019executa l\u2019aplicaci\u00f3 que accedeix ales dades. Aquesta biblioteca es troba principalment en els paquets java.sql i javax.sql . Partint de la suposici\u00f3 que ja hi ha una BD correctament configurada i a la qualvolem accedir des del codi d\u2019un programa Java, el resum de passos que cal fer dins l\u2019aplicaci\u00f3 \u00e9s: Importar correctament els packages corresponents Carregar el controlador (driver) per a l\u2019acc\u00e9s a la BD. Aquest dep\u00e8n de la BD a accedir. Establir la connexi\u00f3 a la BD. A partir d\u2019aqu\u00ed, ja es poden executar sent\u00e8ncies SQL en la BD i processarles respostes. Quan ja no es vol treballar m\u00e9s amb la BD, cal tancar la connexi\u00f3. JDBC, igual que moltes altres API en Java, est\u00e0 dissenyat amb la simplicitat enel pensament i intenta que l\u2019ordre de les operacions que ha de fer l\u2019operador siga gen\u00e8ric i, fins a cert punt, l\u00f2gic. Igual que per llegir dades d\u2019un fitxer el que cal fer\u00e9s dir quina \u00e9s la seva ubicaci\u00f3, obrir-lo, llegir o escriure les dades i tancar-lo, enaquest cas la idea \u00e9s similar. Simplement, \u201cllegir-lo o escriure\u2019l\u201d vol dir invocaruna sent\u00e8ncia SQL, enlloc de posicionar un apuntador. Tot i aix\u00ed, cal tenir un cert domini d\u2019SQL per poder fer correctament aquesta feina.","title":"JDBC"},{"location":"Tema%2010.%20Acc%C3%A9s%20a%20dades/#installacio-de-drivers","text":"Per poder connectar-nos a una base de dades utilitzant JDBC primer hem d'instal\u00b7lar els drivers i afegir-los al classpath per tal que siguen accessibles. Cada fabricant de sistemes gestors de bases de dades ofereix el connector JDBC per a la seua base de dades, aix\u00f2 vol dir que si la nostra aplicaci\u00f3 s'ha de connectar a una base de dades mysql, ser\u00e0 des del lloc web de MySql d'on ens haruem de descarregar el driver, mentre que si el que volem \u00e9s accedir a una base de dades Oracle, haurem d'obtenir el driver JDBC des d'Oracle.","title":"Instal\u00b7laci\u00f3 de drivers"},{"location":"Tema%2010.%20Acc%C3%A9s%20a%20dades/#descarregar-driver","text":"A continuaci\u00f3 podeu entrar i descarregar el driver JDBC per a MySql de de la seg\u00fcent p\u00e0gina: https://dev.mysql.com/downloads/connector/j/ $ > apt install ./mysql-connector-java_8.0.24-1ubuntu20.04_all.deb $ > dpkg -i mysql-connector-java_8.0.24-1ubuntu20.04_all.deb Una vegada executades aquestos commandaments, tindrem didponible el paquest mysql-connector.jar a la ruta /usr/share/java i ara hauriem de podre afegir el paquet al classpath del nostre projecte.","title":"Descarregar driver"},{"location":"Tema%2010.%20Acc%C3%A9s%20a%20dades/#afegir-al-classpath","text":"All\u00f2 important \u00e9s que el fitxer que cont\u00e9 el driver mysql-connector.jar es trobe dins del classpath del projecte. Ja que anirem a eixe path per carregar-lo i utilitzar-lo al notre programa. La manera m\u00e9s facil d'afegir el paquet al classpath del nostre projecte \u00e9s amb eclipse. Fem clic dret sobre el nostre projecte i seleccionem propietats Al di\u00e0leg que s'ens obre, hem d'anar a Java Build Path i dins de la pestanya Libraries punxar sobre l'opci\u00f3 Classpath per finalment fer clic al bot\u00f3 Add External JARs . Ja nom\u00e9s ens quedaria anar a la carpeta en la qual es troba el fitxer .jar del driver i seleccionar-lo. Finalment premem el bot\u00f3 Aplicar i tancar i ja ho tindriem al path del nostre projecte.","title":"Afegir al Classpath"},{"location":"Tema%2010.%20Acc%C3%A9s%20a%20dades/#connexio-a-la-base-de-dades","text":"Per tal de podre connectar amb una base de dades utilitzarem els paquets java.sql i javax.sql . Dins d'aquestos paquets disposem d'una s\u00e8rie de classes,interf\u00edcies etc.. que ens serviran per poder interactuar amb el nostre sistema gestor de bases de dades. Els m\u00e9s importants s\u00f3n: la classe DriveManager i les interf\u00edcies: ResultSet , Connection , Statement i DataSource . Per tant primer, importem tant java.sql com javax.sql al nostre projecte. 1 2 import java.sql.* ; import javax.sql.* ; Una vegada ja tenim importats els paquets del driver JDBC, hem d'establir la connexi\u00f3 a la base de dades mitjan\u00e7ant un objecte connexi\u00f3 i aquest objecte connexi\u00f3 estar\u00e0 relacionat amb un String on s'emmagatzemar\u00e0 la cadena de connexi\u00f3 a la base de dades. Veiem alguns exemples de cadenes de connexi\u00f3: jdbc:mysql://localhost:port/BD jdbc:odbc:DSN_BD jdbc:oracle:usuari@servidor:port:BD Cal tindre tamb\u00e9 l'usuari i la contrassenya d'acc\u00e9s a la base de dades. Tamb\u00e9 esl pot donar el cas que es llence una excepci\u00f3, per tant, necessitarem posar el codi dins d'un bloc try..catch. En definitiva per tal d'establir una connexi\u00f3 amb la nostra base de dades en Java ho fariem de la seg\u00fcent forma: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import java.sql.* ; import javax.sql.* ; public class ConnectaBD { private Connection con ; public MySqlConnection () { try { // 1. Establim la connexi\u00f3 amb la base de dades. con = DriverManager . getConnection ( \"jdbc:mysql://localhost:3306/CicleFormatiu\" , \"root\" , \"******\" ); } catch ( Exception e ) { System . out . println ( \"Error Acc\u00e9s BD\" ); } } } I des del main o la classe Test que cont\u00e9 el m\u00e8tode main est\u00e0tic: 1 2 3 4 5 6 7 8 9 10 import java.sql.* ; import javax.sql.* ; public class TestBD { public static void main ( String [] args ) { ConnectaBD m = new ConnectaBD (); } } Arribats a aquest punt ja tindriem establerta la connexio entre la nostra aplicaci\u00f3 i la base de dades","title":"Connexi\u00f3 a la base de dades"},{"location":"Tema%2010.%20Acc%C3%A9s%20a%20dades/#creacio-i-execucio-de-sentencies-sql","text":"El seg\u00fcent pas, una vegada ja tenim establerta la connexi\u00f3 amb la nostra base de dades hem de crear un objecte Statement des del objecte connexi\u00f3 amb el m\u00e8tode createStatement() que ens retornar\u00e0 un objecte de tipus Statement . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import java.sql.* ; import javax.sql.* ; public class ConnectaBD { private Connection con ; private Statement stat ; public ConnectaBD () { try { // 1. Establim la connexi\u00f3 amb la base de dades. con = DriverManager . getConnection ( \"jdbc:mysql://localhost:3306/CicleFormatiu\" , \"root\" , \"******\" ); // 2. Creem l'objecte Statement. stat = con . createStatement (); } catch ( Exception e ) { System . out . println ( \"Error Acc\u00e9s BD\" ); } } } Ara hauriem de poder executar les sent\u00e8ncies SQL que necessitem. Per poder executar sent\u00e8ncies Sql utilitzarem el m\u00e8tode executeQuery() que \u00e9s un m\u00e8tode que pertany a l'objecte Statement anteriorment creat. Aquest m\u00e8tode ens resornar\u00e0 un ResultSet qu\u00e8 \u00e9s on tindrem la informaci\u00f3 obtesa de la base de dades. En el nostre exemple, crearem un m\u00e8otde nou a la classe MySqlConnection de tipus public al qual se li passar\u00e0 un objecte strQuery de tipus String i ens retornar\u00e0 un ResultSet. Veiem el codi c continuaci\u00f3: 1 2 3 4 5 6 7 8 9 10 11 12 public ResultSet ExecutarSQL ( String strQuery ) { ResultSet rs = null ; if ( strQuery == null ) return null ; try { rs = stat . executeQuery ( strQuery ); } catch ( Exception e ) { System . out . println ( \"Error executant SQL\" ); } return rs ; } Amb aquest codi, des de la nostra classe on es troba el m\u00e8tode main estatic podriem fer el seg\u00fcent: 1 2 3 4 5 6 7 8 9 10 11 import java.sql.* ; import javax.sql.* ; public class TestBD { public static void main ( String [] args ) { ConnectaBD m = new ConnectaBD (); ResultSet rs = m . ExecutarSQL ( \"SELECT * FROM Alumnes;\" ); } } Una vegada executat i comprovat aquest codi, deuriem tindre tots els alumnes de la nostra base de dades al ResultSet rs .","title":"Creaci\u00f3 i execuci\u00f3 de sent\u00e8ncies SQL"},{"location":"Tema%2010.%20Acc%C3%A9s%20a%20dades/#obtencio-de-dades","text":"I ara com llegim els registres de la BD? En el ResultSet que hem obt\u00e9s al pas anterior, el que tindrem ser\u00e0 una esp\u00e8cie de taula on podrem recorrer tota la informaci\u00f3. Per poder accedir a aquest resultSet podem utilitzar els m\u00e8todes getString() i next() de l'objecte resultSet .","title":"Obtenci\u00f3 de dades"}]}